// Schema for the Open Reaction Database.
syntax = "proto3";

package ord;

/**
 * Throughout this schema, we introduce enums to encourage consistency in
 * nomenclature and to avoid unnecessary downstream data processing that would
 * otherwise be required to consolidate equivalent entries. However, we do
 * not wish to restrict what users are able to specify if their synthesis
 * does not fit cleanly into a pre-existing enum field. For that reason, we
 * frequently introduce a string field 'custom' in addition to any enumerated
 * values.
 */

message Reaction {
  repeated ReactionIdentifier identifiers = 1;
  // List of reactants, reagents, etc.
  repeated ReactionInput inputs = 2;
  ReactionSetup setup = 3;
  ReactionConditions conditions = 4;
  // Reaction notes largely pertain to safety considerations.
  ReactionNotes notes = 5;
  repeated ReactionObservation observations = 6;
  repeated ReactionWorkup workup = 7;
  repeated ReactionOutcome outcomes = 8;
  ReactionProvenance provenance = 9;
}

/**
 * Reaction identifiers define descriptions of the overall reaction.
 * While we encourage the use of SMILES strings, these do not work well in
 * all cases. The <reaction_smiles> field should be able to be derived
 * from the information present in the ReactionInput and ReactionOutcome
 * fields of any Reaction message.
 */
message ReactionIdentifier {
  // Possible identifier types are listed in an enum for extensibility
  enum IdentifierType {
    UNSPECIFIED = 0;
    REACTION_SMILES = 1;
    ATOM_MAPPED_SMILES = 2;
    RINCHI = 3; // Reaction InChI.
    NAME = 4; // Named reaction or reaction category.
  }
  oneof kind {
    IdentifierType type = 1;
    string custom = 2;
  }
  string value = 3;
}

message ReactionInput {
  // Description or name of this pure substance or mixture that
  // was added to the reaction vessel. This description is 
  // intended to be used for convenience and legibility, and does not 
  // need to be defined.
  string description = 1;

  /**
  * We use the components field for pure substances and mixtures.
  *
  * For example, suppose we are adding
  * 3 mL of a 4 M solution of NaOH in water.
  *
  * input {
  *   description: "3 mL of 4M NaOH solution in water"
  *   components: [
  *     {
  *       identifiers: [
  *         {type: IDENTIFIER_SMILES, value: "O"},
  *         {type: IDENTIFIER_NAME, value: "water"}
  *       ]
  *       amount: {
  *         volume: {value: 3, units: MILLILITER}
  *       }
  *     }
  *  components: [
  *     {
  *       identifiers: [
  *         {type: IDENTIFIER_SMILES, value: "[Na+].[OH-]"},
  *         {type: IDENTIFIER_NAME, value: "sodium hydroxide"}
  *       ]
  *       amount {
  *         moles: {value: 12, units: MILLIMOLES}
  *       }
  *     }
  *   ]
  * }
  */
  repeated Compound components = 2;
  /**
   * Used to define order of addition. ReactionInputs with the same 
   * addition_order were added simultaneously. One ReactionInput with a 
   * lower addition_order than another was added earlier in the procedure.
   * This field is 1-indexed.
   */
  int32 addition_order = 3;
  // When the addition event took place in terms of the reaction time (or, 
  // in the case of flow chemistry, the residence time).
  Time addition_time = 4;
  enum AdditionSpeed {
    // Unspecified.
    UNSPECIFIED = 0;
    ALL_AT_ONCE = 1;
    FAST = 2;
    SLOW = 3;
    DROPWISE = 4;
    CONTINUOUS = 5;
  }
  // The qualitative rate of addition.
  AdditionSpeed addition_speed = 5;
  // For continuous synthesis, we instead specify a flow rate.
  FlowRate flow_rate = 6;
}

message Compound {
  // Set of identifiers used to uniquely define this compound.
  // Solutions or mixed compounds should use the NAME identifier
  // and list all constituent compounds in the "components" field.
  repeated CompoundIdentifier identifiers = 1;
  /**
   * The quantitative Amount of a Compound used in a particular reaction.
   * Compounds added in their pure form should have their value defined by
   * mass, moles, or volume. Compounds prepared as solutions should be defined
   * in terms of their volume. Compounds prepared on solid supports should
   * define the total mass/volume including the support.
   */
  oneof amount {
    Mass mass = 2;
    Moles moles = 3;
    Volume volume = 4;
  }
  enum ReactionRole {
    // Unspecified.
    REACTION_ROLE_UNKNOWN = 0;
    // TODO(ccoley): Do we want to use the definition of a reactant aligned
    // with Reaxys, or say that any species that contributes heavy atoms 
    // to a desired product is a reactant? This field might be kind of a 
    // throwaway anyway...
    REACTANT = 1;
    REAGENT = 2;
    SOLVENT = 3;
    CATALYST = 4;
  }
  ReactionRole reaction_role = 5;
  // Whether this species was intended to be a limiting reactant.
  bool is_limiting = 6;
  /**
   * Compounds may undergo additional preparation before being used in a 
   * reaction after being received from a supplier or vendor. We encourage
   * the use of the 'preparation' enum when possible, even if the description
   * is an oversimplification of the full procedure, which can be detailed 
   * in the 'preparation_details' field.
   */
  message Preparation {
    enum PreparationType {
      // Unspecified or custom.
      COMPOUND_PREPARATION_UNKNOWN = 0;
      // Compound used as received.
      NONE = 1;
      // Compound repurified (e.g., recrystallized).
      REPURIFIED = 2;
      // Compound sparged, most likely to be the case with solvents.
      SPARGED = 3;
      // Moisture removed, e.g., using molecular sieves.
      DRIED = 4;
      // Compound synthesized in-house
      SYNTHESIZED = 5;
    }
    oneof kind {
      PreparationType preparation = 1;
      string custom = 2;
    }
    // Full description of how the received compound was prepared.
    string details = 3;
  }
  Preparation preparation = 7;
  // Name of the vendor or supplier the compound was purchased from.
  string vendor_source = 8;
  // Compound ID in the vendor database or catalog.
  string vendor_id = 9;
  // Batch/lot identification.
  string vendor_lot = 10;
  /**
   * Compounds can accommodate any number of features. These may include simple
   * properties of the compound (e.g., molecular weight), heuristic estimates
   * of physical properties (e.g., ClogP), optimized geometries (e.g., through
   * DFT), and calculated stereoselectronic descriptors. 
   */
  message Feature {
    string name = 1;
    oneof kind {
      string string_value = 2;
      float float_value = 3;
    }
    string how_computed = 4;
  }
  repeated Feature features = 13;
}

/**
 * Compound identifiers uniquely define a single (pure) chemical species.
 * While we encourage the use of SMILES strings, these do not work well in
 * all cases (e.g., handling tautomerism, axial chirality). Multiple
 * identifiers may be specified for a single compound to avoid ambiguity.
 * We discourage chemicals from being defined only by a name. For compounds
 * that are prepared or isolated as salts, the identifier should include
 * specification of which salt.
 */
message CompoundIdentifier {
  enum IdentifierType {
    UNSPECIFIED = 0;
    //  Simplified molecular-input line-entry system.
    SMILES = 1;
    // IUPAC International Chemical Identifier.
    INCHI = 2;
    // MDL Molfile V3000.
    MOLFILE = 3;
    // Chemical name following IUPAC nomenclature recommendations.
    IUPAC_NAME = 4;
    // Any accepted common name, trade name, etc.
    NAME = 5;
    // Chemical Abstracts Service Registry Number (with hyphens).
    CAS_NUMBER = 6;
    // PubChem Compound ID number.
    PUBCHEM_CID = 7;
    // ChemSpider ID number.
    CHEMSPIDER_ID = 8;
    // ChemAxon extended SMILES
    CXSMILES = 9;
    // IUPAC International Chemical Identifier key
    INCHI_KEY = 10;
    // XYZ molecule file
    XYZ = 11;
    // UniProt ID (for enzymes)
    UNIPROT_ID = 12;
    // Protein data bank ID (for enzymes)
    PDB_ID = 13;
  }
  oneof kind {
    IdentifierType type = 1;
    string custom = 2;
  }
  // Value of the compound identifier; certain types (e.g., PUBCHEM_CID) may
  // cast the string as an integer for downstream processing and validation.
  string value = 3;
}

message Vessel {
  message VesselForm {
    enum VesselFormType {
      UNSPECIFIED = 0;
      ROUND_BOTTOM_FLASK = 1;
      VIAL = 2;
      WELL_PLATE = 3;
      MICROWAVE_VIAL = 4;
      TUBE = 5;
      CONTINUOUS_STIRRED_TANK_REACTOR = 6;
      PACKED_BED_REACTOR = 7;
    }
    oneof kind {
      VesselFormType type = 1;
      string custom = 2;
    }
  }
  message VesselMaterial {
    enum VesselMaterialType {
      UNSPECIFIED = 0;
      GLASS = 1;
      POLYPROPYLENE = 2;
      PLASTIC = 3;
    }
    oneof kind {
      VesselMaterial type = 1;
      string customs = 2;
    }
  }
  message VesselPrep {
    enum VesselPrepType {
      UNSPECIFIED = 0;
      NONE = 1;
      OVEN_DRIED = 2;
    }
    oneof kind {
      VesselPrepType type = 1;
      string custom = 2;
    }
  }
  VesselForm form = 1;
  VesselMaterial material = 2;
  VesselPrep prep = 3;
  Volume vessel_volume = 4; // Size (volume) of the vessel.
}

message ReactionSetup {
  Vessel vessel = 1;
  // Specification of automated protocols.
  bool is_automated = 2;
  // Automated platform name, brand, or model number.
  string automation_platform = 3;
  // Raw automation code or synthetic recipe definition.
  map<string, bytes> automation_code = 4;
}

message ReactionConditions {
  TemperatureConditions temperature = 1;
  PressureConditions pressure = 2;
  StirringConditions stirring = 3;
  IlluminationConditions illumination = 4;
  ElectrochemistryConditions electrochemistry = 5;
  FlowConditions flow = 6;
  bool reflux = 7;
  float pH = 8;
}

message TemperatureConditions {
  message TemperatureControl {
    enum TemperatureControlType {
      UNSPECIFIED = 0;
      AMBIENT = 1;
      OIL_BATH = 2;
      WATER_BATH = 3;
      SAND_BATH = 4;
      ICE_BATH = 5;
      DRY_ALUMINUM_PLATE = 6;
      MICROWAVE = 7;
      DRY_ICE_BATH = 8;
      AIR_FAN = 9;
      LIQUID_NITROGEN = 10;
    }
    oneof kind {
      TemperatureControlType type = 1;
      string custom = 2;
    }
  }
  TemperatureControl temperature_control = 1;
  Temperature setpoint = 2;
  message Measurement {
    enum MeasurementType {
      UNSPECIFIED = 0;
      THERMOCOUPLE_INTERNAL = 1; // Physically in reaction solution.
      THERMOCOUPLE_EXTERNAL = 2; // On outside of vessel or, e.g., in oil bath.
      INFRARED = 3; // Contactless infrared probe.
    }
    Time time = 1;
    Temperature temperature = 2;
    oneof kind {
      MeasurementType type = 3;
      string custom = 4;
    }
  }
  repeated Measurement measurements = 3;
}

message PressureConditions {
  message PressureControl {
    enum PressureControlType {
      UNSPECIFIED = 0;
      AMBIENT = 1;
      BALLOON = 2;
      SEALED = 3; // Fully sealed vessel (e.g., microwave vial).
      RELEASEVALVE = 4;
      BPR = 5; // Back pressure regulator, as used in flow synthesis.
    }
    oneof kind {
      PressureControlType type = 1;
      string custom = 2;
    }
  }
  PressureControl pressure_control = 1;
  Pressure setpoint = 2;
  message Atmosphere {
    enum AtmosphereType {
      UNSPECIFIED = 0;
      AIR = 1;
      NITROGEN = 2;
      ARGON = 3;
      OXYGEN = 4;
      HYDROGEN = 5;
    }
    oneof kind {
      AtmosphereType type = 1;
      string custom = 2;
    }
  }
  Atmosphere atmosphere = 3;
  message Measurement {
    // TODO(ccoley) get input on how to expand this enum, among others
    enum MeasurementType {
      UNSPECIFIED = 0;
      PRESSURE_TRANSDUCER = 1;
    }
    Time time = 1;
    Pressure pressure = 2;
    oneof kind {
      MeasurementType type = 3;
      string custom = 4;
    }
  }
  repeated Measurement measurements = 4;
}

message StirringConditions {
  message StirringMethod {
    enum StirringMethodType {
      UNSPECIFIED = 0;
      NONE = 1;
      STIR_BAR = 2;
      OVERHEAD_MIXER = 3;
      AGITATION = 4;
    }
    oneof kind {
      StirringMethodType type = 1;
      string custom = 2;
    }
  }
  StirringMethod method = 1;
  enum StirringRate {
    UNSPECIFIED = 0;
    HIGH = 1;
    MEDIUM = 2;
    LOW = 3;
  }
  StirringRate stirring_rate = 2;
  int32 stirring_rpm = 3;
}

message IlluminationConditions {
  enum IlluminationType {
    UNSPECIFIED = 0;
    AMBIENT = 1;
    DARK = 2;
    LED = 3;
    HALOGEN_LAMP = 4;
    DEUTERIUM_LAMP = 5;
    SOLAR_SIMULATOR = 6;
    BROAD_SPECTRUM = 7;
  }
  oneof kind {
    IlluminationType type = 1;
    string custom = 2;
  }
  Wavelength peak_wavelength = 3;
  string color = 4;
  // Approximate distance to vessel.
  Length distance_to_vessel = 5;
}

message ElectrochemistryConditions {
  enum ElectrochemistryType {
    UNSPECIFIED = 0;
    CONSTANT_CURRENT = 1;
    CONSTANT_VOLTAGE = 2;
  }
  oneof kind {
    ElectrochemistryType type = 1;
    string custom = 2;
  }
  Current current = 3;
  Voltage voltage = 4;
  string anode_material = 5;
  string cathode_material = 6;
  Length electrode_separation = 7;
  message Measurement {
    Time time = 1;
    oneof kind {
      Current current = 2;
      Voltage voltage = 3;
    }
  }
  repeated Measurement measurements = 8;
}

message FlowConditions {
  enum FlowType {
    UNSPECIFIED = 0;
    PLUG_FLOW_REACTOR = 1;
    CONTINUOUS_STIRRED_TANK_REACTOR = 2;
    PACKED_BED_REACTOR = 3;
  }
  oneof kind {
    FlowType type = 1;
    string custom = 2;
  }
  string pump_type = 3;
  message Tube {
    enum TubeMaterialType {
      UNSPECIFIED = 0;
      STEEL = 1;
      COPPER = 2;
      PFA = 3;
      FEP = 4;
      TEFLONAF = 5;
      PTFE = 6;
      GLASS = 7;
      QUARTZ = 8;
      SILICON = 9; // e.g., a chip-based microreactor
      PDMS = 10;
    }
    oneof kind {
      TubeMaterialType type = 1;
      string custom = 2;
    }
    Length diameter = 3;
  }
  Tube tube = 4;
}

message ReactionNotes {
  // Equivalent to "not single phase".
  bool is_heterogeneous = 1;
  // Qualitative exothermicity (primarily for safety).
  bool is_exothermic = 2;
  // Qualitative offgassing (primarily for safety).
  bool is_offgasses = 3;
  bool is_sensitive_to_moisture = 4;
  bool is_sensitive_to_oxygen = 5;
  bool is_sensitive_to_light = 6;
  string safety_notes = 7;
}

message ReactionObservation {
  Time time = 1;
  oneof kind {
    string color = 2;
    bytes image = 3;
    string comment = 4;
  }
}

message ReactionWorkup {
  enum WorkupType {
    UNSPECIFIED = 0;
    THERMAL_QUENCH = 1;
    SOLVENT_QUENCH = 2;
    EXTRACTION = 3;
    FLASH_CHROMATOGRAPHY = 4;
  }
  oneof kind {
    WorkupType type = 1;
    string custom = 2;
  }
  TemperatureConditions thermal_quench = 3;
  Compound solvent_quench = 4;
}

/**
 * The outcomes of a reaction describe the conversion, yield, and/or other
 * analyses of the resulting product mixture after workup step(s). Each
 * outcome is associated with a reaction/residence time. To allow for
 * one Reaction message to contain the results of a full kinetic profiling
 * experiment, this is a repeated field of the Reaction message.
 * 
 * It is the parent message for product characterization and any analytical
 * data.
 */
message ReactionOutcome {
  // Reaction time (for flow, equivalent to residence time or spacetime).
  Time reaction_time = 1;
  // Conversion with respect to the limiting reactant.
  Percentage conversion = 2;
  repeated ReactionProduct products = 3;
  repeated ReactionAnalysis analyses = 4;
}

message ReactionProduct {
  Compound compound = 1;
  bool is_desired_product = 2;
  Percentage compound_yield = 3;
  oneof kind {
    ReactionAnalysis.AnalysisType type = 4;
    string custom = 5;
  }
  Percentage purity = 6;
  message Selectivity {
    enum SelectivityType {
      UNSPECIFIED = 0;
      EE = 1; // Enantiomeric excess as a percentage.
      ER = 2; // Enantiomeric ratio. (x:1)
      DE = 3; // Diasteromeric ratio (x:1)
    }
    oneof kind {
      SelectivityType type = 1;
      string custom = 2;
    }
    float value = 3;
    // TODO(kearnes): What does precision mean in this context?
    float precision = 4;
  }
  // TODO(ccoley): How to allow specification of the state of matter of the 
  // purified compound? For example, "___ was recovered as a white powder in
  // x% yield (y.z mg)". Or oils, crystal texture, etc. This is only relevant 
  // for compounds that are isolated.
  // TODO(kearnes): Should this be an Observation message?
  string isolated_color = 7;
  message Texture {
    enum TextureType {
      UNSPECIFIED = 0;
      POWDER = 1;
      CRYSTAL = 2;
      OIL = 3;
    }
    oneof kind {
      TextureType type = 1;
      string custom = 2;
    }
  }
  Texture texture = 8;
}

// TODO(ccoley): If we want the DateTime to be a string that we parse as
// needed, should it simply be "string datetime" when used? Or is there any 
// benefit to having a separate message type that could be changed in the 
// future if needed?
message DateTime {
  string value = 1;
}

message ReactionAnalysis {
  // TODO(ccoley): Solicit more feedback from experimentalists
  enum AnalysisType {
    ANALYSIS_TYPE_UNKNOWN = 0;
    LC = 1; // Liquid chromatography.
    GC = 2; // Gas chromatography.
    IR = 3; // Infrared spectroscopy.
    NMR = 4; // NMR spectroscopy.
    MP = 5; // Melting point characterization.
    UV = 6; // Ultraviolet spectroscopy.
    TLC = 7; // Thin-layer chromatography.
    MS = 8; // Mass spectrometry.
    HRMS = 9; // High resolution mass spectrometry.
    MSMS = 10; // Two-dimensional mass spectrometry.
    WEIGHT = 11; // Weight of an isolated compound.
    LCMS = 12; // Combined LC/MS.
    GCMS = 13; // Combined GC/MS.
    ELSD = 14; // Evaporative light scattering detector.
  }
  oneof kind {
    AnalysisType type = 1;
    string custom = 2;
  }
  // Any details about analysis (e.g., NMR type, columns, gradients, conditions)
  string analysis_details = 3;
  // Data files (processed or annotated).
  map<string, bytes> data_processed = 4;
  // Data files (raw) obtained directly from the instrument
  map<string, bytes> data_raw = 5;
  string instrument_manufacturer = 6;
  DateTime instrument_last_calibrated = 7;
}

message ReactionProvenance {
  Person experimenter = 1;
  string city = 2;
  DateTime experiment_start = 3;
  string doi = 4;
  string patent = 5;
  string publication_url = 6;
  DateTime record_created = 7;
  DateTime record_modified = 8;
  // TODO(ccoley): is it useful to create a unique ID field 
  // that the centralized database can write to? (I know uniqueness is not
  // enforceable)
  int32 id = 9;
}

message Person {
  string username = 1;
  string name = 2;
  string orcid = 3;
  string organization = 4;
}

/**
 * To allow users to describe synthetic processes in whatever units they find
 * most natural, we define a fixed list of allowable units for each measurement
 * type. Upon submission to a centralized database, or using a validation and
 * canonicalization script, we will convert all values to the default units
 * (the first nonzero item in each enum).
 *
 * Each message also contains a `precision` field, which specifies the precision
 * of the measurement in the same units as the measurement itself. Often the
 * precision will be the standard deviation from an instrument calibration.
 */
message Time {
  enum TimeUnit {
    TIME_UNIT_UNKNOWN = 0;
    HOUR = 1;
    MINUTE = 2;
    SECOND = 3;
  }
  float value = 1;
  // Precision of the measurement (with the same units as `value`).
  float precision = 2;
  TimeUnit units = 3;
}
message Mass {
  enum MassUnit {
    MASS_UNIT_UNKNOWN = 0;
    GRAM = 1;
    MILLIGRAM = 2;
    MICROGRAM = 3;
    KILOGRAM = 4;
  }
  float value = 1;
  // Precision of the measurement (with the same units as `value`).
  float precision = 2;
  MassUnit units = 3;
}
message Moles {
  enum MolesUnit {
    MOLES_UNIT_UNKNOWN = 0;
    MOLES = 1;
    MILLIMOLES = 2;
    MICROMOLES = 3;
    NANOMOLES = 4;
  }
  float value = 1;
  // Precision of the measurement (with the same units as `value`).
  float precision = 2;
  MolesUnit units = 3;
}
message Volume {
  enum VolumeUnit {
    VOLUME_UNIT_UNKNOWN = 0;
    MILLILITER = 1;
    MICROLITER = 2;
    LITER = 3;
  }
  float value = 1;
  // Precision of the measurement (with the same units as `value`).
  float precision = 2;
  VolumeUnit units = 3;
}
message Concentration {
  enum ConcentrationUnit {
    CONCENTRATION_UNIT_UNKNOWN = 0;
    MOLAR = 1;
    MILLIMOLAR = 2;
    MICROMOLAR = 3;
  }
  float value = 1;
  // Precision of the measurement (with the same units as `value`).
  float precision = 2;
  ConcentrationUnit units = 3;
}
message Pressure {
  enum PressureUnit {
    PRESSURE_UNIT_UNKNOWN = 0;
    BAR = 1;
    ATMOSPHERE = 2;
    PSI = 3;
    KPSI = 4;
    PASCAL = 5; // Pascal
    KILOPASCAL = 6; // KiloPascal
  }
  float value = 1;
  // Precision of the measurement (with the same units as `value`).
  float precision = 2;
  PressureUnit units = 3;
}
message Temperature {
  enum TemperatureUnit {
    TEMPERATURE_UNIT_UNKNOWN = 0;
    CELSIUS = 1;
    FAHRENHEIT = 2;
    KELVIN = 3;
  }
  float value = 1;
  // Precision of the measurement (with the same units as `value`).
  float precision = 2;
  TemperatureUnit units = 3;
}
message Current {
  enum CurrentUnit {
    CURRENT_UNIT_UNKNOWN = 0;
    AMPERE = 1;
    MILLIAMPERE = 2;
  }
  float value = 1;
  // Precision of the measurement (with the same units as `value`).
  float precision = 2;
  CurrentUnit units = 3;
}
message Voltage {
  enum VoltageUnit {
    VOLTAGE_UNIT_UNKNOWN = 0;
    VOLT = 1;
    MILLIVOLT = 2;
  }
  float value = 1;
  // Precision of the measurement (with the same units as `value`).
  float precision = 2;
  VoltageUnit units = 3;
}
message Length {
  enum LengthUnit {
    LENGTH_UNIT_UNKNOWN = 0;
    CENTIMETER = 1;
    MILLIMETER = 2;
    METER = 3;
    INCH = 4;
    FOOT = 5;
  }
  float value = 1;
  // Precision of the measurement (with the same units as `value`).
  float precision = 2;
  LengthUnit units = 3;
}
message Wavelength {
  enum WavelengthUnit {
    WAVELENGTH_UNIT_UNKNOWN = 0;
    NANOMETER = 1;
    WAVENUMBER = 2; // cm^{-1}
  }
  float value = 1;
  // Precision of the measurement (with the same units as `value`).
  float precision = 2;
  WavelengthUnit units = 3;
}
message FlowRate {
  enum FlowRateUnit {
    FLOW_RATE_UNIT_UNKNOWN = 0;
    MICROLITER_PER_MINUTE = 1;
    MICROLITER_PER_SECOND = 2;
    MILLILITER_PER_MINUTE = 3;
    MILLILITER_PER_SECOND = 4;
    MICROLITER_PER_HOUR = 5;
  }
  float value = 1;
  // Precision of the measurement (with the same units as `value`).
  float precision = 2;
  FlowRateUnit units = 3;
}
// Used for things like conversion and yield.
message Percentage {
  float value = 1;
  // Precision of the measurement (with the same units as `value`).
  float precision = 2;
}
