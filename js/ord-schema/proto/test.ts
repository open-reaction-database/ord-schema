/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 4.22.3
 * source: ord-schema/proto/test.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export namespace ord_test {
    export class Scalar extends pb_1.Message {
        #one_of_decls: number[][] = [[3], [6]];
        constructor(data?: any[] | ({
            int32_value?: number;
            int64_value?: number;
            string_value?: string;
            bytes_value?: Uint8Array;
        } & (({
            float_value?: number;
        }) | ({
            bool_value?: boolean;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("int32_value" in data && data.int32_value != undefined) {
                    this.int32_value = data.int32_value;
                }
                if ("int64_value" in data && data.int64_value != undefined) {
                    this.int64_value = data.int64_value;
                }
                if ("float_value" in data && data.float_value != undefined) {
                    this.float_value = data.float_value;
                }
                if ("string_value" in data && data.string_value != undefined) {
                    this.string_value = data.string_value;
                }
                if ("bytes_value" in data && data.bytes_value != undefined) {
                    this.bytes_value = data.bytes_value;
                }
                if ("bool_value" in data && data.bool_value != undefined) {
                    this.bool_value = data.bool_value;
                }
            }
        }
        get int32_value() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set int32_value(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get int64_value() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set int64_value(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get float_value() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set float_value(value: number) {
            pb_1.Message.setOneofField(this, 3, this.#one_of_decls[0], value);
        }
        get has_float_value() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get string_value() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set string_value(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get bytes_value() {
            return pb_1.Message.getFieldWithDefault(this, 5, new Uint8Array(0)) as Uint8Array;
        }
        set bytes_value(value: Uint8Array) {
            pb_1.Message.setField(this, 5, value);
        }
        get bool_value() {
            return pb_1.Message.getFieldWithDefault(this, 6, false) as boolean;
        }
        set bool_value(value: boolean) {
            pb_1.Message.setOneofField(this, 6, this.#one_of_decls[1], value);
        }
        get has_bool_value() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get _float_value() {
            const cases: {
                [index: number]: "none" | "float_value";
            } = {
                0: "none",
                3: "float_value"
            };
            return cases[pb_1.Message.computeOneofCase(this, [3])];
        }
        get _bool_value() {
            const cases: {
                [index: number]: "none" | "bool_value";
            } = {
                0: "none",
                6: "bool_value"
            };
            return cases[pb_1.Message.computeOneofCase(this, [6])];
        }
        static fromObject(data: {
            int32_value?: number;
            int64_value?: number;
            float_value?: number;
            string_value?: string;
            bytes_value?: Uint8Array;
            bool_value?: boolean;
        }): Scalar {
            const message = new Scalar({});
            if (data.int32_value != null) {
                message.int32_value = data.int32_value;
            }
            if (data.int64_value != null) {
                message.int64_value = data.int64_value;
            }
            if (data.float_value != null) {
                message.float_value = data.float_value;
            }
            if (data.string_value != null) {
                message.string_value = data.string_value;
            }
            if (data.bytes_value != null) {
                message.bytes_value = data.bytes_value;
            }
            if (data.bool_value != null) {
                message.bool_value = data.bool_value;
            }
            return message;
        }
        toObject() {
            const data: {
                int32_value?: number;
                int64_value?: number;
                float_value?: number;
                string_value?: string;
                bytes_value?: Uint8Array;
                bool_value?: boolean;
            } = {};
            if (this.int32_value != null) {
                data.int32_value = this.int32_value;
            }
            if (this.int64_value != null) {
                data.int64_value = this.int64_value;
            }
            if (this.float_value != null) {
                data.float_value = this.float_value;
            }
            if (this.string_value != null) {
                data.string_value = this.string_value;
            }
            if (this.bytes_value != null) {
                data.bytes_value = this.bytes_value;
            }
            if (this.bool_value != null) {
                data.bool_value = this.bool_value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.int32_value != 0)
                writer.writeInt32(1, this.int32_value);
            if (this.int64_value != 0)
                writer.writeInt64(2, this.int64_value);
            if (this.has_float_value)
                writer.writeFloat(3, this.float_value);
            if (this.string_value.length)
                writer.writeString(4, this.string_value);
            if (this.bytes_value.length)
                writer.writeBytes(5, this.bytes_value);
            if (this.has_bool_value)
                writer.writeBool(6, this.bool_value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Scalar {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Scalar();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.int32_value = reader.readInt32();
                        break;
                    case 2:
                        message.int64_value = reader.readInt64();
                        break;
                    case 3:
                        message.float_value = reader.readFloat();
                        break;
                    case 4:
                        message.string_value = reader.readString();
                        break;
                    case 5:
                        message.bytes_value = reader.readBytes();
                        break;
                    case 6:
                        message.bool_value = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Scalar {
            return Scalar.deserialize(bytes);
        }
    }
    export class RepeatedScalar extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            values?: number[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("values" in data && data.values != undefined) {
                    this.values = data.values;
                }
            }
        }
        get values() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as number[];
        }
        set values(value: number[]) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            values?: number[];
        }): RepeatedScalar {
            const message = new RepeatedScalar({});
            if (data.values != null) {
                message.values = data.values;
            }
            return message;
        }
        toObject() {
            const data: {
                values?: number[];
            } = {};
            if (this.values != null) {
                data.values = this.values;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.values.length)
                writer.writePackedFloat(1, this.values);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RepeatedScalar {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RepeatedScalar();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.values = reader.readPackedFloat();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): RepeatedScalar {
            return RepeatedScalar.deserialize(bytes);
        }
    }
    export class Enum extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            value?: Enum.EnumValues;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, Enum.EnumValues.UNSPECIFIED) as Enum.EnumValues;
        }
        set value(value: Enum.EnumValues) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            value?: Enum.EnumValues;
        }): Enum {
            const message = new Enum({});
            if (data.value != null) {
                message.value = data.value;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: Enum.EnumValues;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.value != Enum.EnumValues.UNSPECIFIED)
                writer.writeEnum(1, this.value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Enum {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Enum();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Enum {
            return Enum.deserialize(bytes);
        }
    }
    export namespace Enum {
        export enum EnumValues {
            UNSPECIFIED = 0,
            FIRST = 1,
            SECOND = 2
        }
    }
    export class RepeatedEnum extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            values?: RepeatedEnum.EnumValues[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("values" in data && data.values != undefined) {
                    this.values = data.values;
                }
            }
        }
        get values() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as RepeatedEnum.EnumValues[];
        }
        set values(value: RepeatedEnum.EnumValues[]) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            values?: RepeatedEnum.EnumValues[];
        }): RepeatedEnum {
            const message = new RepeatedEnum({});
            if (data.values != null) {
                message.values = data.values;
            }
            return message;
        }
        toObject() {
            const data: {
                values?: RepeatedEnum.EnumValues[];
            } = {};
            if (this.values != null) {
                data.values = this.values;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.values.length)
                writer.writePackedEnum(1, this.values);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RepeatedEnum {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RepeatedEnum();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.values = reader.readPackedEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): RepeatedEnum {
            return RepeatedEnum.deserialize(bytes);
        }
    }
    export namespace RepeatedEnum {
        export enum EnumValues {
            UNSPECIFIED = 0,
            FIRST = 1,
            SECOND = 2
        }
    }
    export class Nested extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            child?: Nested.Child;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("child" in data && data.child != undefined) {
                    this.child = data.child;
                }
            }
        }
        get child() {
            return pb_1.Message.getWrapperField(this, Nested.Child, 1) as Nested.Child;
        }
        set child(value: Nested.Child) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_child() {
            return pb_1.Message.getField(this, 1) != null;
        }
        static fromObject(data: {
            child?: ReturnType<typeof Nested.Child.prototype.toObject>;
        }): Nested {
            const message = new Nested({});
            if (data.child != null) {
                message.child = Nested.Child.fromObject(data.child);
            }
            return message;
        }
        toObject() {
            const data: {
                child?: ReturnType<typeof Nested.Child.prototype.toObject>;
            } = {};
            if (this.child != null) {
                data.child = this.child.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_child)
                writer.writeMessage(1, this.child, () => this.child.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Nested {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Nested();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.child, () => message.child = Nested.Child.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Nested {
            return Nested.deserialize(bytes);
        }
    }
    export namespace Nested {
        export class Child extends pb_1.Message {
            #one_of_decls: number[][] = [[1]];
            constructor(data?: any[] | ({} & (({
                value?: number;
            })))) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("value" in data && data.value != undefined) {
                        this.value = data.value;
                    }
                }
            }
            get value() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set value(value: number) {
                pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
            }
            get has_value() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get _value() {
                const cases: {
                    [index: number]: "none" | "value";
                } = {
                    0: "none",
                    1: "value"
                };
                return cases[pb_1.Message.computeOneofCase(this, [1])];
            }
            static fromObject(data: {
                value?: number;
            }): Child {
                const message = new Child({});
                if (data.value != null) {
                    message.value = data.value;
                }
                return message;
            }
            toObject() {
                const data: {
                    value?: number;
                } = {};
                if (this.value != null) {
                    data.value = this.value;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_value)
                    writer.writeFloat(1, this.value);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Child {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Child();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.value = reader.readFloat();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Child {
                return Child.deserialize(bytes);
            }
        }
    }
    export class RepeatedNested extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            children?: RepeatedNested.Child[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("children" in data && data.children != undefined) {
                    this.children = data.children;
                }
            }
        }
        get children() {
            return pb_1.Message.getRepeatedWrapperField(this, RepeatedNested.Child, 1) as RepeatedNested.Child[];
        }
        set children(value: RepeatedNested.Child[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            children?: ReturnType<typeof RepeatedNested.Child.prototype.toObject>[];
        }): RepeatedNested {
            const message = new RepeatedNested({});
            if (data.children != null) {
                message.children = data.children.map(item => RepeatedNested.Child.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                children?: ReturnType<typeof RepeatedNested.Child.prototype.toObject>[];
            } = {};
            if (this.children != null) {
                data.children = this.children.map((item: RepeatedNested.Child) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.children.length)
                writer.writeRepeatedMessage(1, this.children, (item: RepeatedNested.Child) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RepeatedNested {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RepeatedNested();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.children, () => pb_1.Message.addToRepeatedWrapperField(message, 1, RepeatedNested.Child.deserialize(reader), RepeatedNested.Child));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): RepeatedNested {
            return RepeatedNested.deserialize(bytes);
        }
    }
    export namespace RepeatedNested {
        export class Child extends pb_1.Message {
            #one_of_decls: number[][] = [[1]];
            constructor(data?: any[] | ({} & (({
                value?: number;
            })))) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("value" in data && data.value != undefined) {
                        this.value = data.value;
                    }
                }
            }
            get value() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set value(value: number) {
                pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
            }
            get has_value() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get _value() {
                const cases: {
                    [index: number]: "none" | "value";
                } = {
                    0: "none",
                    1: "value"
                };
                return cases[pb_1.Message.computeOneofCase(this, [1])];
            }
            static fromObject(data: {
                value?: number;
            }): Child {
                const message = new Child({});
                if (data.value != null) {
                    message.value = data.value;
                }
                return message;
            }
            toObject() {
                const data: {
                    value?: number;
                } = {};
                if (this.value != null) {
                    data.value = this.value;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_value)
                    writer.writeFloat(1, this.value);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Child {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Child();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.value = reader.readFloat();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Child {
                return Child.deserialize(bytes);
            }
        }
    }
    export class Map extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            values?: Map<string, number>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("values" in data && data.values != undefined) {
                    this.values = data.values;
                }
            }
            if (!this.values)
                this.values = new Map();
        }
        get values() {
            return pb_1.Message.getField(this, 1) as any as Map<string, number>;
        }
        set values(value: Map<string, number>) {
            pb_1.Message.setField(this, 1, value as any);
        }
        static fromObject(data: {
            values?: {
                [key: string]: number;
            };
        }): Map {
            const message = new Map({});
            if (typeof data.values == "object") {
                message.values = new Map(Object.entries(data.values));
            }
            return message;
        }
        toObject() {
            const data: {
                values?: {
                    [key: string]: number;
                };
            } = {};
            if (this.values != null) {
                data.values = (Object.fromEntries)(this.values);
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            for (const [key, value] of this.values) {
                writer.writeMessage(1, this.values, () => {
                    writer.writeString(1, key);
                    writer.writeFloat(2, value);
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Map {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Map();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.values as any, reader, reader.readString, reader.readFloat));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Map {
            return Map.deserialize(bytes);
        }
    }
    export class MapNested extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            children?: Map<string, MapNested.Child>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("children" in data && data.children != undefined) {
                    this.children = data.children;
                }
            }
            if (!this.children)
                this.children = new Map();
        }
        get children() {
            return pb_1.Message.getField(this, 1) as any as Map<string, MapNested.Child>;
        }
        set children(value: Map<string, MapNested.Child>) {
            pb_1.Message.setField(this, 1, value as any);
        }
        static fromObject(data: {
            children?: {
                [key: string]: ReturnType<typeof MapNested.Child.prototype.toObject>;
            };
        }): MapNested {
            const message = new MapNested({});
            if (typeof data.children == "object") {
                message.children = new Map(Object.entries(data.children).map(([key, value]) => [key, MapNested.Child.fromObject(value)]));
            }
            return message;
        }
        toObject() {
            const data: {
                children?: {
                    [key: string]: ReturnType<typeof MapNested.Child.prototype.toObject>;
                };
            } = {};
            if (this.children != null) {
                data.children = (Object.fromEntries)((Array.from)(this.children).map(([key, value]) => [key, value.toObject()]));
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            for (const [key, value] of this.children) {
                writer.writeMessage(1, this.children, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MapNested {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MapNested();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.children as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = MapNested.Child.deserialize(reader));
                            return value;
                        }));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MapNested {
            return MapNested.deserialize(bytes);
        }
    }
    export namespace MapNested {
        export class Child extends pb_1.Message {
            #one_of_decls: number[][] = [[1]];
            constructor(data?: any[] | ({} & (({
                value?: number;
            })))) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("value" in data && data.value != undefined) {
                        this.value = data.value;
                    }
                }
            }
            get value() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set value(value: number) {
                pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
            }
            get has_value() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get _value() {
                const cases: {
                    [index: number]: "none" | "value";
                } = {
                    0: "none",
                    1: "value"
                };
                return cases[pb_1.Message.computeOneofCase(this, [1])];
            }
            static fromObject(data: {
                value?: number;
            }): Child {
                const message = new Child({});
                if (data.value != null) {
                    message.value = data.value;
                }
                return message;
            }
            toObject() {
                const data: {
                    value?: number;
                } = {};
                if (this.value != null) {
                    data.value = this.value;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_value)
                    writer.writeFloat(1, this.value);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Child {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Child();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.value = reader.readFloat();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Child {
                return Child.deserialize(bytes);
            }
        }
    }
}
