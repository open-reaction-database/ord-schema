/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 4.22.3
 * source: ord-schema/proto/reaction.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export namespace ord {
    export class Reaction extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            identifiers?: ReactionIdentifier[];
            inputs?: Map<string, ReactionInput>;
            setup?: ReactionSetup;
            conditions?: ReactionConditions;
            notes?: ReactionNotes;
            observations?: ReactionObservation[];
            workups?: ReactionWorkup[];
            outcomes?: ReactionOutcome[];
            provenance?: ReactionProvenance;
            reaction_id?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 6, 7, 8], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("identifiers" in data && data.identifiers != undefined) {
                    this.identifiers = data.identifiers;
                }
                if ("inputs" in data && data.inputs != undefined) {
                    this.inputs = data.inputs;
                }
                if ("setup" in data && data.setup != undefined) {
                    this.setup = data.setup;
                }
                if ("conditions" in data && data.conditions != undefined) {
                    this.conditions = data.conditions;
                }
                if ("notes" in data && data.notes != undefined) {
                    this.notes = data.notes;
                }
                if ("observations" in data && data.observations != undefined) {
                    this.observations = data.observations;
                }
                if ("workups" in data && data.workups != undefined) {
                    this.workups = data.workups;
                }
                if ("outcomes" in data && data.outcomes != undefined) {
                    this.outcomes = data.outcomes;
                }
                if ("provenance" in data && data.provenance != undefined) {
                    this.provenance = data.provenance;
                }
                if ("reaction_id" in data && data.reaction_id != undefined) {
                    this.reaction_id = data.reaction_id;
                }
            }
            if (!this.inputs)
                this.inputs = new Map();
        }
        get identifiers() {
            return pb_1.Message.getRepeatedWrapperField(this, ReactionIdentifier, 1) as ReactionIdentifier[];
        }
        set identifiers(value: ReactionIdentifier[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get inputs() {
            return pb_1.Message.getField(this, 2) as any as Map<string, ReactionInput>;
        }
        set inputs(value: Map<string, ReactionInput>) {
            pb_1.Message.setField(this, 2, value as any);
        }
        get setup() {
            return pb_1.Message.getWrapperField(this, ReactionSetup, 3) as ReactionSetup;
        }
        set setup(value: ReactionSetup) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_setup() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get conditions() {
            return pb_1.Message.getWrapperField(this, ReactionConditions, 4) as ReactionConditions;
        }
        set conditions(value: ReactionConditions) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get has_conditions() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get notes() {
            return pb_1.Message.getWrapperField(this, ReactionNotes, 5) as ReactionNotes;
        }
        set notes(value: ReactionNotes) {
            pb_1.Message.setWrapperField(this, 5, value);
        }
        get has_notes() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get observations() {
            return pb_1.Message.getRepeatedWrapperField(this, ReactionObservation, 6) as ReactionObservation[];
        }
        set observations(value: ReactionObservation[]) {
            pb_1.Message.setRepeatedWrapperField(this, 6, value);
        }
        get workups() {
            return pb_1.Message.getRepeatedWrapperField(this, ReactionWorkup, 7) as ReactionWorkup[];
        }
        set workups(value: ReactionWorkup[]) {
            pb_1.Message.setRepeatedWrapperField(this, 7, value);
        }
        get outcomes() {
            return pb_1.Message.getRepeatedWrapperField(this, ReactionOutcome, 8) as ReactionOutcome[];
        }
        set outcomes(value: ReactionOutcome[]) {
            pb_1.Message.setRepeatedWrapperField(this, 8, value);
        }
        get provenance() {
            return pb_1.Message.getWrapperField(this, ReactionProvenance, 9) as ReactionProvenance;
        }
        set provenance(value: ReactionProvenance) {
            pb_1.Message.setWrapperField(this, 9, value);
        }
        get has_provenance() {
            return pb_1.Message.getField(this, 9) != null;
        }
        get reaction_id() {
            return pb_1.Message.getFieldWithDefault(this, 10, "") as string;
        }
        set reaction_id(value: string) {
            pb_1.Message.setField(this, 10, value);
        }
        static fromObject(data: {
            identifiers?: ReturnType<typeof ReactionIdentifier.prototype.toObject>[];
            inputs?: {
                [key: string]: ReturnType<typeof ReactionInput.prototype.toObject>;
            };
            setup?: ReturnType<typeof ReactionSetup.prototype.toObject>;
            conditions?: ReturnType<typeof ReactionConditions.prototype.toObject>;
            notes?: ReturnType<typeof ReactionNotes.prototype.toObject>;
            observations?: ReturnType<typeof ReactionObservation.prototype.toObject>[];
            workups?: ReturnType<typeof ReactionWorkup.prototype.toObject>[];
            outcomes?: ReturnType<typeof ReactionOutcome.prototype.toObject>[];
            provenance?: ReturnType<typeof ReactionProvenance.prototype.toObject>;
            reaction_id?: string;
        }): Reaction {
            const message = new Reaction({});
            if (data.identifiers != null) {
                message.identifiers = data.identifiers.map(item => ReactionIdentifier.fromObject(item));
            }
            if (typeof data.inputs == "object") {
                message.inputs = new Map(Object.entries(data.inputs).map(([key, value]) => [key, ReactionInput.fromObject(value)]));
            }
            if (data.setup != null) {
                message.setup = ReactionSetup.fromObject(data.setup);
            }
            if (data.conditions != null) {
                message.conditions = ReactionConditions.fromObject(data.conditions);
            }
            if (data.notes != null) {
                message.notes = ReactionNotes.fromObject(data.notes);
            }
            if (data.observations != null) {
                message.observations = data.observations.map(item => ReactionObservation.fromObject(item));
            }
            if (data.workups != null) {
                message.workups = data.workups.map(item => ReactionWorkup.fromObject(item));
            }
            if (data.outcomes != null) {
                message.outcomes = data.outcomes.map(item => ReactionOutcome.fromObject(item));
            }
            if (data.provenance != null) {
                message.provenance = ReactionProvenance.fromObject(data.provenance);
            }
            if (data.reaction_id != null) {
                message.reaction_id = data.reaction_id;
            }
            return message;
        }
        toObject() {
            const data: {
                identifiers?: ReturnType<typeof ReactionIdentifier.prototype.toObject>[];
                inputs?: {
                    [key: string]: ReturnType<typeof ReactionInput.prototype.toObject>;
                };
                setup?: ReturnType<typeof ReactionSetup.prototype.toObject>;
                conditions?: ReturnType<typeof ReactionConditions.prototype.toObject>;
                notes?: ReturnType<typeof ReactionNotes.prototype.toObject>;
                observations?: ReturnType<typeof ReactionObservation.prototype.toObject>[];
                workups?: ReturnType<typeof ReactionWorkup.prototype.toObject>[];
                outcomes?: ReturnType<typeof ReactionOutcome.prototype.toObject>[];
                provenance?: ReturnType<typeof ReactionProvenance.prototype.toObject>;
                reaction_id?: string;
            } = {};
            if (this.identifiers != null) {
                data.identifiers = this.identifiers.map((item: ReactionIdentifier) => item.toObject());
            }
            if (this.inputs != null) {
                data.inputs = (Object.fromEntries)((Array.from)(this.inputs).map(([key, value]) => [key, value.toObject()]));
            }
            if (this.setup != null) {
                data.setup = this.setup.toObject();
            }
            if (this.conditions != null) {
                data.conditions = this.conditions.toObject();
            }
            if (this.notes != null) {
                data.notes = this.notes.toObject();
            }
            if (this.observations != null) {
                data.observations = this.observations.map((item: ReactionObservation) => item.toObject());
            }
            if (this.workups != null) {
                data.workups = this.workups.map((item: ReactionWorkup) => item.toObject());
            }
            if (this.outcomes != null) {
                data.outcomes = this.outcomes.map((item: ReactionOutcome) => item.toObject());
            }
            if (this.provenance != null) {
                data.provenance = this.provenance.toObject();
            }
            if (this.reaction_id != null) {
                data.reaction_id = this.reaction_id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.identifiers.length)
                writer.writeRepeatedMessage(1, this.identifiers, (item: ReactionIdentifier) => item.serialize(writer));
            for (const [key, value] of this.inputs) {
                writer.writeMessage(2, this.inputs, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (this.has_setup)
                writer.writeMessage(3, this.setup, () => this.setup.serialize(writer));
            if (this.has_conditions)
                writer.writeMessage(4, this.conditions, () => this.conditions.serialize(writer));
            if (this.has_notes)
                writer.writeMessage(5, this.notes, () => this.notes.serialize(writer));
            if (this.observations.length)
                writer.writeRepeatedMessage(6, this.observations, (item: ReactionObservation) => item.serialize(writer));
            if (this.workups.length)
                writer.writeRepeatedMessage(7, this.workups, (item: ReactionWorkup) => item.serialize(writer));
            if (this.outcomes.length)
                writer.writeRepeatedMessage(8, this.outcomes, (item: ReactionOutcome) => item.serialize(writer));
            if (this.has_provenance)
                writer.writeMessage(9, this.provenance, () => this.provenance.serialize(writer));
            if (this.reaction_id.length)
                writer.writeString(10, this.reaction_id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Reaction {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Reaction();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.identifiers, () => pb_1.Message.addToRepeatedWrapperField(message, 1, ReactionIdentifier.deserialize(reader), ReactionIdentifier));
                        break;
                    case 2:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.inputs as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = ReactionInput.deserialize(reader));
                            return value;
                        }));
                        break;
                    case 3:
                        reader.readMessage(message.setup, () => message.setup = ReactionSetup.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.conditions, () => message.conditions = ReactionConditions.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.notes, () => message.notes = ReactionNotes.deserialize(reader));
                        break;
                    case 6:
                        reader.readMessage(message.observations, () => pb_1.Message.addToRepeatedWrapperField(message, 6, ReactionObservation.deserialize(reader), ReactionObservation));
                        break;
                    case 7:
                        reader.readMessage(message.workups, () => pb_1.Message.addToRepeatedWrapperField(message, 7, ReactionWorkup.deserialize(reader), ReactionWorkup));
                        break;
                    case 8:
                        reader.readMessage(message.outcomes, () => pb_1.Message.addToRepeatedWrapperField(message, 8, ReactionOutcome.deserialize(reader), ReactionOutcome));
                        break;
                    case 9:
                        reader.readMessage(message.provenance, () => message.provenance = ReactionProvenance.deserialize(reader));
                        break;
                    case 10:
                        message.reaction_id = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Reaction {
            return Reaction.deserialize(bytes);
        }
    }
    export class ReactionIdentifier extends pb_1.Message {
        #one_of_decls: number[][] = [[4]];
        constructor(data?: any[] | ({
            type?: ReactionIdentifier.ReactionIdentifierType;
            details?: string;
            value?: string;
        } & (({
            is_mapped?: boolean;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("details" in data && data.details != undefined) {
                    this.details = data.details;
                }
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
                if ("is_mapped" in data && data.is_mapped != undefined) {
                    this.is_mapped = data.is_mapped;
                }
            }
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 1, ReactionIdentifier.ReactionIdentifierType.UNSPECIFIED) as ReactionIdentifier.ReactionIdentifierType;
        }
        set type(value: ReactionIdentifier.ReactionIdentifierType) {
            pb_1.Message.setField(this, 1, value);
        }
        get details() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set details(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set value(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get is_mapped() {
            return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
        }
        set is_mapped(value: boolean) {
            pb_1.Message.setOneofField(this, 4, this.#one_of_decls[0], value);
        }
        get has_is_mapped() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get _is_mapped() {
            const cases: {
                [index: number]: "none" | "is_mapped";
            } = {
                0: "none",
                4: "is_mapped"
            };
            return cases[pb_1.Message.computeOneofCase(this, [4])];
        }
        static fromObject(data: {
            type?: ReactionIdentifier.ReactionIdentifierType;
            details?: string;
            value?: string;
            is_mapped?: boolean;
        }): ReactionIdentifier {
            const message = new ReactionIdentifier({});
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.details != null) {
                message.details = data.details;
            }
            if (data.value != null) {
                message.value = data.value;
            }
            if (data.is_mapped != null) {
                message.is_mapped = data.is_mapped;
            }
            return message;
        }
        toObject() {
            const data: {
                type?: ReactionIdentifier.ReactionIdentifierType;
                details?: string;
                value?: string;
                is_mapped?: boolean;
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.details != null) {
                data.details = this.details;
            }
            if (this.value != null) {
                data.value = this.value;
            }
            if (this.is_mapped != null) {
                data.is_mapped = this.is_mapped;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type != ReactionIdentifier.ReactionIdentifierType.UNSPECIFIED)
                writer.writeEnum(1, this.type);
            if (this.details.length)
                writer.writeString(2, this.details);
            if (this.value.length)
                writer.writeString(3, this.value);
            if (this.has_is_mapped)
                writer.writeBool(4, this.is_mapped);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ReactionIdentifier {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ReactionIdentifier();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readEnum();
                        break;
                    case 2:
                        message.details = reader.readString();
                        break;
                    case 3:
                        message.value = reader.readString();
                        break;
                    case 4:
                        message.is_mapped = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ReactionIdentifier {
            return ReactionIdentifier.deserialize(bytes);
        }
    }
    export namespace ReactionIdentifier {
        export enum ReactionIdentifierType {
            UNSPECIFIED = 0,
            CUSTOM = 1,
            REACTION_SMILES = 2,
            REACTION_CXSMILES = 6,
            RDFILE = 3,
            RINCHI = 4,
            REACTION_TYPE = 5,
            SUBSET = 7,
            INDEX = 8
        }
    }
    export class ReactionInput extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            components?: Compound[];
            crude_components?: CrudeComponent[];
            addition_order?: number;
            addition_time?: Time;
            addition_speed?: ReactionInput.AdditionSpeed;
            addition_duration?: Time;
            flow_rate?: FlowRate;
            addition_device?: ReactionInput.AdditionDevice;
            addition_temperature?: Temperature;
            texture?: Texture;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("components" in data && data.components != undefined) {
                    this.components = data.components;
                }
                if ("crude_components" in data && data.crude_components != undefined) {
                    this.crude_components = data.crude_components;
                }
                if ("addition_order" in data && data.addition_order != undefined) {
                    this.addition_order = data.addition_order;
                }
                if ("addition_time" in data && data.addition_time != undefined) {
                    this.addition_time = data.addition_time;
                }
                if ("addition_speed" in data && data.addition_speed != undefined) {
                    this.addition_speed = data.addition_speed;
                }
                if ("addition_duration" in data && data.addition_duration != undefined) {
                    this.addition_duration = data.addition_duration;
                }
                if ("flow_rate" in data && data.flow_rate != undefined) {
                    this.flow_rate = data.flow_rate;
                }
                if ("addition_device" in data && data.addition_device != undefined) {
                    this.addition_device = data.addition_device;
                }
                if ("addition_temperature" in data && data.addition_temperature != undefined) {
                    this.addition_temperature = data.addition_temperature;
                }
                if ("texture" in data && data.texture != undefined) {
                    this.texture = data.texture;
                }
            }
        }
        get components() {
            return pb_1.Message.getRepeatedWrapperField(this, Compound, 1) as Compound[];
        }
        set components(value: Compound[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get crude_components() {
            return pb_1.Message.getRepeatedWrapperField(this, CrudeComponent, 2) as CrudeComponent[];
        }
        set crude_components(value: CrudeComponent[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get addition_order() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set addition_order(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get addition_time() {
            return pb_1.Message.getWrapperField(this, Time, 4) as Time;
        }
        set addition_time(value: Time) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get has_addition_time() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get addition_speed() {
            return pb_1.Message.getWrapperField(this, ReactionInput.AdditionSpeed, 5) as ReactionInput.AdditionSpeed;
        }
        set addition_speed(value: ReactionInput.AdditionSpeed) {
            pb_1.Message.setWrapperField(this, 5, value);
        }
        get has_addition_speed() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get addition_duration() {
            return pb_1.Message.getWrapperField(this, Time, 6) as Time;
        }
        set addition_duration(value: Time) {
            pb_1.Message.setWrapperField(this, 6, value);
        }
        get has_addition_duration() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get flow_rate() {
            return pb_1.Message.getWrapperField(this, FlowRate, 7) as FlowRate;
        }
        set flow_rate(value: FlowRate) {
            pb_1.Message.setWrapperField(this, 7, value);
        }
        get has_flow_rate() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get addition_device() {
            return pb_1.Message.getWrapperField(this, ReactionInput.AdditionDevice, 8) as ReactionInput.AdditionDevice;
        }
        set addition_device(value: ReactionInput.AdditionDevice) {
            pb_1.Message.setWrapperField(this, 8, value);
        }
        get has_addition_device() {
            return pb_1.Message.getField(this, 8) != null;
        }
        get addition_temperature() {
            return pb_1.Message.getWrapperField(this, Temperature, 9) as Temperature;
        }
        set addition_temperature(value: Temperature) {
            pb_1.Message.setWrapperField(this, 9, value);
        }
        get has_addition_temperature() {
            return pb_1.Message.getField(this, 9) != null;
        }
        get texture() {
            return pb_1.Message.getWrapperField(this, Texture, 10) as Texture;
        }
        set texture(value: Texture) {
            pb_1.Message.setWrapperField(this, 10, value);
        }
        get has_texture() {
            return pb_1.Message.getField(this, 10) != null;
        }
        static fromObject(data: {
            components?: ReturnType<typeof Compound.prototype.toObject>[];
            crude_components?: ReturnType<typeof CrudeComponent.prototype.toObject>[];
            addition_order?: number;
            addition_time?: ReturnType<typeof Time.prototype.toObject>;
            addition_speed?: ReturnType<typeof ReactionInput.AdditionSpeed.prototype.toObject>;
            addition_duration?: ReturnType<typeof Time.prototype.toObject>;
            flow_rate?: ReturnType<typeof FlowRate.prototype.toObject>;
            addition_device?: ReturnType<typeof ReactionInput.AdditionDevice.prototype.toObject>;
            addition_temperature?: ReturnType<typeof Temperature.prototype.toObject>;
            texture?: ReturnType<typeof Texture.prototype.toObject>;
        }): ReactionInput {
            const message = new ReactionInput({});
            if (data.components != null) {
                message.components = data.components.map(item => Compound.fromObject(item));
            }
            if (data.crude_components != null) {
                message.crude_components = data.crude_components.map(item => CrudeComponent.fromObject(item));
            }
            if (data.addition_order != null) {
                message.addition_order = data.addition_order;
            }
            if (data.addition_time != null) {
                message.addition_time = Time.fromObject(data.addition_time);
            }
            if (data.addition_speed != null) {
                message.addition_speed = ReactionInput.AdditionSpeed.fromObject(data.addition_speed);
            }
            if (data.addition_duration != null) {
                message.addition_duration = Time.fromObject(data.addition_duration);
            }
            if (data.flow_rate != null) {
                message.flow_rate = FlowRate.fromObject(data.flow_rate);
            }
            if (data.addition_device != null) {
                message.addition_device = ReactionInput.AdditionDevice.fromObject(data.addition_device);
            }
            if (data.addition_temperature != null) {
                message.addition_temperature = Temperature.fromObject(data.addition_temperature);
            }
            if (data.texture != null) {
                message.texture = Texture.fromObject(data.texture);
            }
            return message;
        }
        toObject() {
            const data: {
                components?: ReturnType<typeof Compound.prototype.toObject>[];
                crude_components?: ReturnType<typeof CrudeComponent.prototype.toObject>[];
                addition_order?: number;
                addition_time?: ReturnType<typeof Time.prototype.toObject>;
                addition_speed?: ReturnType<typeof ReactionInput.AdditionSpeed.prototype.toObject>;
                addition_duration?: ReturnType<typeof Time.prototype.toObject>;
                flow_rate?: ReturnType<typeof FlowRate.prototype.toObject>;
                addition_device?: ReturnType<typeof ReactionInput.AdditionDevice.prototype.toObject>;
                addition_temperature?: ReturnType<typeof Temperature.prototype.toObject>;
                texture?: ReturnType<typeof Texture.prototype.toObject>;
            } = {};
            if (this.components != null) {
                data.components = this.components.map((item: Compound) => item.toObject());
            }
            if (this.crude_components != null) {
                data.crude_components = this.crude_components.map((item: CrudeComponent) => item.toObject());
            }
            if (this.addition_order != null) {
                data.addition_order = this.addition_order;
            }
            if (this.addition_time != null) {
                data.addition_time = this.addition_time.toObject();
            }
            if (this.addition_speed != null) {
                data.addition_speed = this.addition_speed.toObject();
            }
            if (this.addition_duration != null) {
                data.addition_duration = this.addition_duration.toObject();
            }
            if (this.flow_rate != null) {
                data.flow_rate = this.flow_rate.toObject();
            }
            if (this.addition_device != null) {
                data.addition_device = this.addition_device.toObject();
            }
            if (this.addition_temperature != null) {
                data.addition_temperature = this.addition_temperature.toObject();
            }
            if (this.texture != null) {
                data.texture = this.texture.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.components.length)
                writer.writeRepeatedMessage(1, this.components, (item: Compound) => item.serialize(writer));
            if (this.crude_components.length)
                writer.writeRepeatedMessage(2, this.crude_components, (item: CrudeComponent) => item.serialize(writer));
            if (this.addition_order != 0)
                writer.writeInt32(3, this.addition_order);
            if (this.has_addition_time)
                writer.writeMessage(4, this.addition_time, () => this.addition_time.serialize(writer));
            if (this.has_addition_speed)
                writer.writeMessage(5, this.addition_speed, () => this.addition_speed.serialize(writer));
            if (this.has_addition_duration)
                writer.writeMessage(6, this.addition_duration, () => this.addition_duration.serialize(writer));
            if (this.has_flow_rate)
                writer.writeMessage(7, this.flow_rate, () => this.flow_rate.serialize(writer));
            if (this.has_addition_device)
                writer.writeMessage(8, this.addition_device, () => this.addition_device.serialize(writer));
            if (this.has_addition_temperature)
                writer.writeMessage(9, this.addition_temperature, () => this.addition_temperature.serialize(writer));
            if (this.has_texture)
                writer.writeMessage(10, this.texture, () => this.texture.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ReactionInput {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ReactionInput();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.components, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Compound.deserialize(reader), Compound));
                        break;
                    case 2:
                        reader.readMessage(message.crude_components, () => pb_1.Message.addToRepeatedWrapperField(message, 2, CrudeComponent.deserialize(reader), CrudeComponent));
                        break;
                    case 3:
                        message.addition_order = reader.readInt32();
                        break;
                    case 4:
                        reader.readMessage(message.addition_time, () => message.addition_time = Time.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.addition_speed, () => message.addition_speed = ReactionInput.AdditionSpeed.deserialize(reader));
                        break;
                    case 6:
                        reader.readMessage(message.addition_duration, () => message.addition_duration = Time.deserialize(reader));
                        break;
                    case 7:
                        reader.readMessage(message.flow_rate, () => message.flow_rate = FlowRate.deserialize(reader));
                        break;
                    case 8:
                        reader.readMessage(message.addition_device, () => message.addition_device = ReactionInput.AdditionDevice.deserialize(reader));
                        break;
                    case 9:
                        reader.readMessage(message.addition_temperature, () => message.addition_temperature = Temperature.deserialize(reader));
                        break;
                    case 10:
                        reader.readMessage(message.texture, () => message.texture = Texture.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ReactionInput {
            return ReactionInput.deserialize(bytes);
        }
    }
    export namespace ReactionInput {
        export class AdditionSpeed extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                type?: ReactionInput.AdditionSpeed.AdditionSpeedType;
                details?: string;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("type" in data && data.type != undefined) {
                        this.type = data.type;
                    }
                    if ("details" in data && data.details != undefined) {
                        this.details = data.details;
                    }
                }
            }
            get type() {
                return pb_1.Message.getFieldWithDefault(this, 1, ReactionInput.AdditionSpeed.AdditionSpeedType.UNSPECIFIED) as ReactionInput.AdditionSpeed.AdditionSpeedType;
            }
            set type(value: ReactionInput.AdditionSpeed.AdditionSpeedType) {
                pb_1.Message.setField(this, 1, value);
            }
            get details() {
                return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
            }
            set details(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            static fromObject(data: {
                type?: ReactionInput.AdditionSpeed.AdditionSpeedType;
                details?: string;
            }): AdditionSpeed {
                const message = new AdditionSpeed({});
                if (data.type != null) {
                    message.type = data.type;
                }
                if (data.details != null) {
                    message.details = data.details;
                }
                return message;
            }
            toObject() {
                const data: {
                    type?: ReactionInput.AdditionSpeed.AdditionSpeedType;
                    details?: string;
                } = {};
                if (this.type != null) {
                    data.type = this.type;
                }
                if (this.details != null) {
                    data.details = this.details;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.type != ReactionInput.AdditionSpeed.AdditionSpeedType.UNSPECIFIED)
                    writer.writeEnum(1, this.type);
                if (this.details.length)
                    writer.writeString(2, this.details);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AdditionSpeed {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AdditionSpeed();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.type = reader.readEnum();
                            break;
                        case 2:
                            message.details = reader.readString();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): AdditionSpeed {
                return AdditionSpeed.deserialize(bytes);
            }
        }
        export namespace AdditionSpeed {
            export enum AdditionSpeedType {
                UNSPECIFIED = 0,
                ALL_AT_ONCE = 1,
                FAST = 2,
                SLOW = 3,
                DROPWISE = 4,
                CONTINUOUS = 5,
                PORTIONWISE = 6
            }
        }
        export class AdditionDevice extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                type?: ReactionInput.AdditionDevice.AdditionDeviceType;
                details?: string;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("type" in data && data.type != undefined) {
                        this.type = data.type;
                    }
                    if ("details" in data && data.details != undefined) {
                        this.details = data.details;
                    }
                }
            }
            get type() {
                return pb_1.Message.getFieldWithDefault(this, 1, ReactionInput.AdditionDevice.AdditionDeviceType.UNSPECIFIED) as ReactionInput.AdditionDevice.AdditionDeviceType;
            }
            set type(value: ReactionInput.AdditionDevice.AdditionDeviceType) {
                pb_1.Message.setField(this, 1, value);
            }
            get details() {
                return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
            }
            set details(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            static fromObject(data: {
                type?: ReactionInput.AdditionDevice.AdditionDeviceType;
                details?: string;
            }): AdditionDevice {
                const message = new AdditionDevice({});
                if (data.type != null) {
                    message.type = data.type;
                }
                if (data.details != null) {
                    message.details = data.details;
                }
                return message;
            }
            toObject() {
                const data: {
                    type?: ReactionInput.AdditionDevice.AdditionDeviceType;
                    details?: string;
                } = {};
                if (this.type != null) {
                    data.type = this.type;
                }
                if (this.details != null) {
                    data.details = this.details;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.type != ReactionInput.AdditionDevice.AdditionDeviceType.UNSPECIFIED)
                    writer.writeEnum(1, this.type);
                if (this.details.length)
                    writer.writeString(2, this.details);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AdditionDevice {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AdditionDevice();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.type = reader.readEnum();
                            break;
                        case 2:
                            message.details = reader.readString();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): AdditionDevice {
                return AdditionDevice.deserialize(bytes);
            }
        }
        export namespace AdditionDevice {
            export enum AdditionDeviceType {
                UNSPECIFIED = 0,
                CUSTOM = 1,
                NONE = 2,
                SYRINGE = 3,
                CANNULA = 4,
                ADDITION_FUNNEL = 5,
                PIPETTE = 6,
                POSITIVE_DISPLACEMENT_PIPETTE = 7,
                PISTON_PUMP = 8,
                SYRINGE_PUMP = 9,
                PERISTALTIC_PUMP = 10
            }
        }
    }
    export class Amount extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2, 3, 5], [4]];
        constructor(data?: any[] | ({} & (({
            mass?: Mass;
            moles?: never;
            volume?: never;
            unmeasured?: never;
        } | {
            mass?: never;
            moles?: Moles;
            volume?: never;
            unmeasured?: never;
        } | {
            mass?: never;
            moles?: never;
            volume?: Volume;
            unmeasured?: never;
        } | {
            mass?: never;
            moles?: never;
            volume?: never;
            unmeasured?: UnmeasuredAmount;
        }) | ({
            volume_includes_solutes?: boolean;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("mass" in data && data.mass != undefined) {
                    this.mass = data.mass;
                }
                if ("moles" in data && data.moles != undefined) {
                    this.moles = data.moles;
                }
                if ("volume" in data && data.volume != undefined) {
                    this.volume = data.volume;
                }
                if ("unmeasured" in data && data.unmeasured != undefined) {
                    this.unmeasured = data.unmeasured;
                }
                if ("volume_includes_solutes" in data && data.volume_includes_solutes != undefined) {
                    this.volume_includes_solutes = data.volume_includes_solutes;
                }
            }
        }
        get mass() {
            return pb_1.Message.getWrapperField(this, Mass, 1) as Mass;
        }
        set mass(value: Mass) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_mass() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get moles() {
            return pb_1.Message.getWrapperField(this, Moles, 2) as Moles;
        }
        set moles(value: Moles) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_moles() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get volume() {
            return pb_1.Message.getWrapperField(this, Volume, 3) as Volume;
        }
        set volume(value: Volume) {
            pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
        }
        get has_volume() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get unmeasured() {
            return pb_1.Message.getWrapperField(this, UnmeasuredAmount, 5) as UnmeasuredAmount;
        }
        set unmeasured(value: UnmeasuredAmount) {
            pb_1.Message.setOneofWrapperField(this, 5, this.#one_of_decls[0], value);
        }
        get has_unmeasured() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get volume_includes_solutes() {
            return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
        }
        set volume_includes_solutes(value: boolean) {
            pb_1.Message.setOneofField(this, 4, this.#one_of_decls[1], value);
        }
        get has_volume_includes_solutes() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get kind() {
            const cases: {
                [index: number]: "none" | "mass" | "moles" | "volume" | "unmeasured";
            } = {
                0: "none",
                1: "mass",
                2: "moles",
                3: "volume",
                5: "unmeasured"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3, 5])];
        }
        get _volume_includes_solutes() {
            const cases: {
                [index: number]: "none" | "volume_includes_solutes";
            } = {
                0: "none",
                4: "volume_includes_solutes"
            };
            return cases[pb_1.Message.computeOneofCase(this, [4])];
        }
        static fromObject(data: {
            mass?: ReturnType<typeof Mass.prototype.toObject>;
            moles?: ReturnType<typeof Moles.prototype.toObject>;
            volume?: ReturnType<typeof Volume.prototype.toObject>;
            unmeasured?: ReturnType<typeof UnmeasuredAmount.prototype.toObject>;
            volume_includes_solutes?: boolean;
        }): Amount {
            const message = new Amount({});
            if (data.mass != null) {
                message.mass = Mass.fromObject(data.mass);
            }
            if (data.moles != null) {
                message.moles = Moles.fromObject(data.moles);
            }
            if (data.volume != null) {
                message.volume = Volume.fromObject(data.volume);
            }
            if (data.unmeasured != null) {
                message.unmeasured = UnmeasuredAmount.fromObject(data.unmeasured);
            }
            if (data.volume_includes_solutes != null) {
                message.volume_includes_solutes = data.volume_includes_solutes;
            }
            return message;
        }
        toObject() {
            const data: {
                mass?: ReturnType<typeof Mass.prototype.toObject>;
                moles?: ReturnType<typeof Moles.prototype.toObject>;
                volume?: ReturnType<typeof Volume.prototype.toObject>;
                unmeasured?: ReturnType<typeof UnmeasuredAmount.prototype.toObject>;
                volume_includes_solutes?: boolean;
            } = {};
            if (this.mass != null) {
                data.mass = this.mass.toObject();
            }
            if (this.moles != null) {
                data.moles = this.moles.toObject();
            }
            if (this.volume != null) {
                data.volume = this.volume.toObject();
            }
            if (this.unmeasured != null) {
                data.unmeasured = this.unmeasured.toObject();
            }
            if (this.volume_includes_solutes != null) {
                data.volume_includes_solutes = this.volume_includes_solutes;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_mass)
                writer.writeMessage(1, this.mass, () => this.mass.serialize(writer));
            if (this.has_moles)
                writer.writeMessage(2, this.moles, () => this.moles.serialize(writer));
            if (this.has_volume)
                writer.writeMessage(3, this.volume, () => this.volume.serialize(writer));
            if (this.has_unmeasured)
                writer.writeMessage(5, this.unmeasured, () => this.unmeasured.serialize(writer));
            if (this.has_volume_includes_solutes)
                writer.writeBool(4, this.volume_includes_solutes);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Amount {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Amount();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.mass, () => message.mass = Mass.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.moles, () => message.moles = Moles.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.volume, () => message.volume = Volume.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.unmeasured, () => message.unmeasured = UnmeasuredAmount.deserialize(reader));
                        break;
                    case 4:
                        message.volume_includes_solutes = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Amount {
            return Amount.deserialize(bytes);
        }
    }
    export class UnmeasuredAmount extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            type?: UnmeasuredAmount.UnmeasuredAmountType;
            details?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("details" in data && data.details != undefined) {
                    this.details = data.details;
                }
            }
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 1, UnmeasuredAmount.UnmeasuredAmountType.UNSPECIFIED) as UnmeasuredAmount.UnmeasuredAmountType;
        }
        set type(value: UnmeasuredAmount.UnmeasuredAmountType) {
            pb_1.Message.setField(this, 1, value);
        }
        get details() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set details(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            type?: UnmeasuredAmount.UnmeasuredAmountType;
            details?: string;
        }): UnmeasuredAmount {
            const message = new UnmeasuredAmount({});
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.details != null) {
                message.details = data.details;
            }
            return message;
        }
        toObject() {
            const data: {
                type?: UnmeasuredAmount.UnmeasuredAmountType;
                details?: string;
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.details != null) {
                data.details = this.details;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type != UnmeasuredAmount.UnmeasuredAmountType.UNSPECIFIED)
                writer.writeEnum(1, this.type);
            if (this.details.length)
                writer.writeString(2, this.details);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UnmeasuredAmount {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UnmeasuredAmount();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readEnum();
                        break;
                    case 2:
                        message.details = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): UnmeasuredAmount {
            return UnmeasuredAmount.deserialize(bytes);
        }
    }
    export namespace UnmeasuredAmount {
        export enum UnmeasuredAmountType {
            UNSPECIFIED = 0,
            CUSTOM = 1,
            SATURATED = 2,
            CATALYTIC = 3,
            TITRATED = 4
        }
    }
    export class Texture extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            type?: Texture.TextureType;
            details?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("details" in data && data.details != undefined) {
                    this.details = data.details;
                }
            }
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 1, Texture.TextureType.UNSPECIFIED) as Texture.TextureType;
        }
        set type(value: Texture.TextureType) {
            pb_1.Message.setField(this, 1, value);
        }
        get details() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set details(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            type?: Texture.TextureType;
            details?: string;
        }): Texture {
            const message = new Texture({});
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.details != null) {
                message.details = data.details;
            }
            return message;
        }
        toObject() {
            const data: {
                type?: Texture.TextureType;
                details?: string;
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.details != null) {
                data.details = this.details;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type != Texture.TextureType.UNSPECIFIED)
                writer.writeEnum(1, this.type);
            if (this.details.length)
                writer.writeString(2, this.details);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Texture {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Texture();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readEnum();
                        break;
                    case 2:
                        message.details = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Texture {
            return Texture.deserialize(bytes);
        }
    }
    export namespace Texture {
        export enum TextureType {
            UNSPECIFIED = 0,
            CUSTOM = 1,
            POWDER = 2,
            CRYSTAL = 3,
            OIL = 4,
            AMORPHOUS_SOLID = 5,
            FOAM = 6,
            WAX = 7,
            SEMI_SOLID = 8,
            SOLID = 9,
            LIQUID = 10,
            GAS = 11
        }
    }
    export class CrudeComponent extends pb_1.Message {
        #one_of_decls: number[][] = [[2], [3]];
        constructor(data?: any[] | ({
            reaction_id?: string;
            amount?: Amount;
            texture?: Texture;
        } & (({
            includes_workup?: boolean;
        }) | ({
            has_derived_amount?: boolean;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("reaction_id" in data && data.reaction_id != undefined) {
                    this.reaction_id = data.reaction_id;
                }
                if ("includes_workup" in data && data.includes_workup != undefined) {
                    this.includes_workup = data.includes_workup;
                }
                if ("has_derived_amount" in data && data.has_derived_amount != undefined) {
                    this.has_derived_amount = data.has_derived_amount;
                }
                if ("amount" in data && data.amount != undefined) {
                    this.amount = data.amount;
                }
                if ("texture" in data && data.texture != undefined) {
                    this.texture = data.texture;
                }
            }
        }
        get reaction_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set reaction_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get includes_workup() {
            return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
        }
        set includes_workup(value: boolean) {
            pb_1.Message.setOneofField(this, 2, this.#one_of_decls[0], value);
        }
        get has_includes_workup() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get has_derived_amount() {
            return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
        }
        set has_derived_amount(value: boolean) {
            pb_1.Message.setOneofField(this, 3, this.#one_of_decls[1], value);
        }
        get has_has_derived_amount() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get amount() {
            return pb_1.Message.getWrapperField(this, Amount, 4) as Amount;
        }
        set amount(value: Amount) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get has_amount() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get texture() {
            return pb_1.Message.getWrapperField(this, Texture, 5) as Texture;
        }
        set texture(value: Texture) {
            pb_1.Message.setWrapperField(this, 5, value);
        }
        get has_texture() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get _includes_workup() {
            const cases: {
                [index: number]: "none" | "includes_workup";
            } = {
                0: "none",
                2: "includes_workup"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        get _has_derived_amount() {
            const cases: {
                [index: number]: "none" | "has_derived_amount";
            } = {
                0: "none",
                3: "has_derived_amount"
            };
            return cases[pb_1.Message.computeOneofCase(this, [3])];
        }
        static fromObject(data: {
            reaction_id?: string;
            includes_workup?: boolean;
            has_derived_amount?: boolean;
            amount?: ReturnType<typeof Amount.prototype.toObject>;
            texture?: ReturnType<typeof Texture.prototype.toObject>;
        }): CrudeComponent {
            const message = new CrudeComponent({});
            if (data.reaction_id != null) {
                message.reaction_id = data.reaction_id;
            }
            if (data.includes_workup != null) {
                message.includes_workup = data.includes_workup;
            }
            if (data.has_derived_amount != null) {
                message.has_derived_amount = data.has_derived_amount;
            }
            if (data.amount != null) {
                message.amount = Amount.fromObject(data.amount);
            }
            if (data.texture != null) {
                message.texture = Texture.fromObject(data.texture);
            }
            return message;
        }
        toObject() {
            const data: {
                reaction_id?: string;
                includes_workup?: boolean;
                has_derived_amount?: boolean;
                amount?: ReturnType<typeof Amount.prototype.toObject>;
                texture?: ReturnType<typeof Texture.prototype.toObject>;
            } = {};
            if (this.reaction_id != null) {
                data.reaction_id = this.reaction_id;
            }
            if (this.includes_workup != null) {
                data.includes_workup = this.includes_workup;
            }
            if (this.has_derived_amount != null) {
                data.has_derived_amount = this.has_derived_amount;
            }
            if (this.amount != null) {
                data.amount = this.amount.toObject();
            }
            if (this.texture != null) {
                data.texture = this.texture.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.reaction_id.length)
                writer.writeString(1, this.reaction_id);
            if (this.has_includes_workup)
                writer.writeBool(2, this.includes_workup);
            if (this.has_has_derived_amount)
                writer.writeBool(3, this.has_derived_amount);
            if (this.has_amount)
                writer.writeMessage(4, this.amount, () => this.amount.serialize(writer));
            if (this.has_texture)
                writer.writeMessage(5, this.texture, () => this.texture.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CrudeComponent {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CrudeComponent();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.reaction_id = reader.readString();
                        break;
                    case 2:
                        message.includes_workup = reader.readBool();
                        break;
                    case 3:
                        message.has_derived_amount = reader.readBool();
                        break;
                    case 4:
                        reader.readMessage(message.amount, () => message.amount = Amount.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.texture, () => message.texture = Texture.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CrudeComponent {
            return CrudeComponent.deserialize(bytes);
        }
    }
    export class Compound extends pb_1.Message {
        #one_of_decls: number[][] = [[4]];
        constructor(data?: any[] | ({
            identifiers?: CompoundIdentifier[];
            amount?: Amount;
            reaction_role?: ReactionRole.ReactionRoleType;
            preparations?: CompoundPreparation[];
            source?: Compound.Source;
            features?: Map<string, Data>;
            analyses?: Map<string, Analysis>;
            texture?: Texture;
        } & (({
            is_limiting?: boolean;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 5], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("identifiers" in data && data.identifiers != undefined) {
                    this.identifiers = data.identifiers;
                }
                if ("amount" in data && data.amount != undefined) {
                    this.amount = data.amount;
                }
                if ("reaction_role" in data && data.reaction_role != undefined) {
                    this.reaction_role = data.reaction_role;
                }
                if ("is_limiting" in data && data.is_limiting != undefined) {
                    this.is_limiting = data.is_limiting;
                }
                if ("preparations" in data && data.preparations != undefined) {
                    this.preparations = data.preparations;
                }
                if ("source" in data && data.source != undefined) {
                    this.source = data.source;
                }
                if ("features" in data && data.features != undefined) {
                    this.features = data.features;
                }
                if ("analyses" in data && data.analyses != undefined) {
                    this.analyses = data.analyses;
                }
                if ("texture" in data && data.texture != undefined) {
                    this.texture = data.texture;
                }
            }
            if (!this.features)
                this.features = new Map();
            if (!this.analyses)
                this.analyses = new Map();
        }
        get identifiers() {
            return pb_1.Message.getRepeatedWrapperField(this, CompoundIdentifier, 1) as CompoundIdentifier[];
        }
        set identifiers(value: CompoundIdentifier[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get amount() {
            return pb_1.Message.getWrapperField(this, Amount, 2) as Amount;
        }
        set amount(value: Amount) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_amount() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get reaction_role() {
            return pb_1.Message.getFieldWithDefault(this, 3, ReactionRole.ReactionRoleType.UNSPECIFIED) as ReactionRole.ReactionRoleType;
        }
        set reaction_role(value: ReactionRole.ReactionRoleType) {
            pb_1.Message.setField(this, 3, value);
        }
        get is_limiting() {
            return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
        }
        set is_limiting(value: boolean) {
            pb_1.Message.setOneofField(this, 4, this.#one_of_decls[0], value);
        }
        get has_is_limiting() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get preparations() {
            return pb_1.Message.getRepeatedWrapperField(this, CompoundPreparation, 5) as CompoundPreparation[];
        }
        set preparations(value: CompoundPreparation[]) {
            pb_1.Message.setRepeatedWrapperField(this, 5, value);
        }
        get source() {
            return pb_1.Message.getWrapperField(this, Compound.Source, 6) as Compound.Source;
        }
        set source(value: Compound.Source) {
            pb_1.Message.setWrapperField(this, 6, value);
        }
        get has_source() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get features() {
            return pb_1.Message.getField(this, 7) as any as Map<string, Data>;
        }
        set features(value: Map<string, Data>) {
            pb_1.Message.setField(this, 7, value as any);
        }
        get analyses() {
            return pb_1.Message.getField(this, 8) as any as Map<string, Analysis>;
        }
        set analyses(value: Map<string, Analysis>) {
            pb_1.Message.setField(this, 8, value as any);
        }
        get texture() {
            return pb_1.Message.getWrapperField(this, Texture, 9) as Texture;
        }
        set texture(value: Texture) {
            pb_1.Message.setWrapperField(this, 9, value);
        }
        get has_texture() {
            return pb_1.Message.getField(this, 9) != null;
        }
        get _is_limiting() {
            const cases: {
                [index: number]: "none" | "is_limiting";
            } = {
                0: "none",
                4: "is_limiting"
            };
            return cases[pb_1.Message.computeOneofCase(this, [4])];
        }
        static fromObject(data: {
            identifiers?: ReturnType<typeof CompoundIdentifier.prototype.toObject>[];
            amount?: ReturnType<typeof Amount.prototype.toObject>;
            reaction_role?: ReactionRole.ReactionRoleType;
            is_limiting?: boolean;
            preparations?: ReturnType<typeof CompoundPreparation.prototype.toObject>[];
            source?: ReturnType<typeof Compound.Source.prototype.toObject>;
            features?: {
                [key: string]: ReturnType<typeof Data.prototype.toObject>;
            };
            analyses?: {
                [key: string]: ReturnType<typeof Analysis.prototype.toObject>;
            };
            texture?: ReturnType<typeof Texture.prototype.toObject>;
        }): Compound {
            const message = new Compound({});
            if (data.identifiers != null) {
                message.identifiers = data.identifiers.map(item => CompoundIdentifier.fromObject(item));
            }
            if (data.amount != null) {
                message.amount = Amount.fromObject(data.amount);
            }
            if (data.reaction_role != null) {
                message.reaction_role = data.reaction_role;
            }
            if (data.is_limiting != null) {
                message.is_limiting = data.is_limiting;
            }
            if (data.preparations != null) {
                message.preparations = data.preparations.map(item => CompoundPreparation.fromObject(item));
            }
            if (data.source != null) {
                message.source = Compound.Source.fromObject(data.source);
            }
            if (typeof data.features == "object") {
                message.features = new Map(Object.entries(data.features).map(([key, value]) => [key, Data.fromObject(value)]));
            }
            if (typeof data.analyses == "object") {
                message.analyses = new Map(Object.entries(data.analyses).map(([key, value]) => [key, Analysis.fromObject(value)]));
            }
            if (data.texture != null) {
                message.texture = Texture.fromObject(data.texture);
            }
            return message;
        }
        toObject() {
            const data: {
                identifiers?: ReturnType<typeof CompoundIdentifier.prototype.toObject>[];
                amount?: ReturnType<typeof Amount.prototype.toObject>;
                reaction_role?: ReactionRole.ReactionRoleType;
                is_limiting?: boolean;
                preparations?: ReturnType<typeof CompoundPreparation.prototype.toObject>[];
                source?: ReturnType<typeof Compound.Source.prototype.toObject>;
                features?: {
                    [key: string]: ReturnType<typeof Data.prototype.toObject>;
                };
                analyses?: {
                    [key: string]: ReturnType<typeof Analysis.prototype.toObject>;
                };
                texture?: ReturnType<typeof Texture.prototype.toObject>;
            } = {};
            if (this.identifiers != null) {
                data.identifiers = this.identifiers.map((item: CompoundIdentifier) => item.toObject());
            }
            if (this.amount != null) {
                data.amount = this.amount.toObject();
            }
            if (this.reaction_role != null) {
                data.reaction_role = this.reaction_role;
            }
            if (this.is_limiting != null) {
                data.is_limiting = this.is_limiting;
            }
            if (this.preparations != null) {
                data.preparations = this.preparations.map((item: CompoundPreparation) => item.toObject());
            }
            if (this.source != null) {
                data.source = this.source.toObject();
            }
            if (this.features != null) {
                data.features = (Object.fromEntries)((Array.from)(this.features).map(([key, value]) => [key, value.toObject()]));
            }
            if (this.analyses != null) {
                data.analyses = (Object.fromEntries)((Array.from)(this.analyses).map(([key, value]) => [key, value.toObject()]));
            }
            if (this.texture != null) {
                data.texture = this.texture.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.identifiers.length)
                writer.writeRepeatedMessage(1, this.identifiers, (item: CompoundIdentifier) => item.serialize(writer));
            if (this.has_amount)
                writer.writeMessage(2, this.amount, () => this.amount.serialize(writer));
            if (this.reaction_role != ReactionRole.ReactionRoleType.UNSPECIFIED)
                writer.writeEnum(3, this.reaction_role);
            if (this.has_is_limiting)
                writer.writeBool(4, this.is_limiting);
            if (this.preparations.length)
                writer.writeRepeatedMessage(5, this.preparations, (item: CompoundPreparation) => item.serialize(writer));
            if (this.has_source)
                writer.writeMessage(6, this.source, () => this.source.serialize(writer));
            for (const [key, value] of this.features) {
                writer.writeMessage(7, this.features, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            for (const [key, value] of this.analyses) {
                writer.writeMessage(8, this.analyses, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (this.has_texture)
                writer.writeMessage(9, this.texture, () => this.texture.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Compound {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Compound();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.identifiers, () => pb_1.Message.addToRepeatedWrapperField(message, 1, CompoundIdentifier.deserialize(reader), CompoundIdentifier));
                        break;
                    case 2:
                        reader.readMessage(message.amount, () => message.amount = Amount.deserialize(reader));
                        break;
                    case 3:
                        message.reaction_role = reader.readEnum();
                        break;
                    case 4:
                        message.is_limiting = reader.readBool();
                        break;
                    case 5:
                        reader.readMessage(message.preparations, () => pb_1.Message.addToRepeatedWrapperField(message, 5, CompoundPreparation.deserialize(reader), CompoundPreparation));
                        break;
                    case 6:
                        reader.readMessage(message.source, () => message.source = Compound.Source.deserialize(reader));
                        break;
                    case 7:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.features as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = Data.deserialize(reader));
                            return value;
                        }));
                        break;
                    case 8:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.analyses as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = Analysis.deserialize(reader));
                            return value;
                        }));
                        break;
                    case 9:
                        reader.readMessage(message.texture, () => message.texture = Texture.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Compound {
            return Compound.deserialize(bytes);
        }
    }
    export namespace Compound {
        export class Source extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                vendor?: string;
                catalog_id?: string;
                lot?: string;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("vendor" in data && data.vendor != undefined) {
                        this.vendor = data.vendor;
                    }
                    if ("catalog_id" in data && data.catalog_id != undefined) {
                        this.catalog_id = data.catalog_id;
                    }
                    if ("lot" in data && data.lot != undefined) {
                        this.lot = data.lot;
                    }
                }
            }
            get vendor() {
                return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
            }
            set vendor(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get catalog_id() {
                return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
            }
            set catalog_id(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            get lot() {
                return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
            }
            set lot(value: string) {
                pb_1.Message.setField(this, 3, value);
            }
            static fromObject(data: {
                vendor?: string;
                catalog_id?: string;
                lot?: string;
            }): Source {
                const message = new Source({});
                if (data.vendor != null) {
                    message.vendor = data.vendor;
                }
                if (data.catalog_id != null) {
                    message.catalog_id = data.catalog_id;
                }
                if (data.lot != null) {
                    message.lot = data.lot;
                }
                return message;
            }
            toObject() {
                const data: {
                    vendor?: string;
                    catalog_id?: string;
                    lot?: string;
                } = {};
                if (this.vendor != null) {
                    data.vendor = this.vendor;
                }
                if (this.catalog_id != null) {
                    data.catalog_id = this.catalog_id;
                }
                if (this.lot != null) {
                    data.lot = this.lot;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.vendor.length)
                    writer.writeString(1, this.vendor);
                if (this.catalog_id.length)
                    writer.writeString(2, this.catalog_id);
                if (this.lot.length)
                    writer.writeString(3, this.lot);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Source {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Source();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.vendor = reader.readString();
                            break;
                        case 2:
                            message.catalog_id = reader.readString();
                            break;
                        case 3:
                            message.lot = reader.readString();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Source {
                return Source.deserialize(bytes);
            }
        }
    }
    export class ReactionRole extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): ReactionRole {
            const message = new ReactionRole({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ReactionRole {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ReactionRole();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ReactionRole {
            return ReactionRole.deserialize(bytes);
        }
    }
    export namespace ReactionRole {
        export enum ReactionRoleType {
            UNSPECIFIED = 0,
            REACTANT = 1,
            REAGENT = 2,
            SOLVENT = 3,
            CATALYST = 4,
            WORKUP = 5,
            INTERNAL_STANDARD = 6,
            AUTHENTIC_STANDARD = 7,
            PRODUCT = 8,
            BYPRODUCT = 9,
            SIDE_PRODUCT = 10
        }
    }
    export class CompoundPreparation extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            type?: CompoundPreparation.CompoundPreparationType;
            details?: string;
            reaction_id?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("details" in data && data.details != undefined) {
                    this.details = data.details;
                }
                if ("reaction_id" in data && data.reaction_id != undefined) {
                    this.reaction_id = data.reaction_id;
                }
            }
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 1, CompoundPreparation.CompoundPreparationType.UNSPECIFIED) as CompoundPreparation.CompoundPreparationType;
        }
        set type(value: CompoundPreparation.CompoundPreparationType) {
            pb_1.Message.setField(this, 1, value);
        }
        get details() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set details(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get reaction_id() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set reaction_id(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            type?: CompoundPreparation.CompoundPreparationType;
            details?: string;
            reaction_id?: string;
        }): CompoundPreparation {
            const message = new CompoundPreparation({});
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.details != null) {
                message.details = data.details;
            }
            if (data.reaction_id != null) {
                message.reaction_id = data.reaction_id;
            }
            return message;
        }
        toObject() {
            const data: {
                type?: CompoundPreparation.CompoundPreparationType;
                details?: string;
                reaction_id?: string;
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.details != null) {
                data.details = this.details;
            }
            if (this.reaction_id != null) {
                data.reaction_id = this.reaction_id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type != CompoundPreparation.CompoundPreparationType.UNSPECIFIED)
                writer.writeEnum(1, this.type);
            if (this.details.length)
                writer.writeString(2, this.details);
            if (this.reaction_id.length)
                writer.writeString(3, this.reaction_id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CompoundPreparation {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CompoundPreparation();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readEnum();
                        break;
                    case 2:
                        message.details = reader.readString();
                        break;
                    case 3:
                        message.reaction_id = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CompoundPreparation {
            return CompoundPreparation.deserialize(bytes);
        }
    }
    export namespace CompoundPreparation {
        export enum CompoundPreparationType {
            UNSPECIFIED = 0,
            CUSTOM = 1,
            NONE = 2,
            REPURIFIED = 3,
            SPARGED = 4,
            DRIED = 5,
            SYNTHESIZED = 6
        }
    }
    export class CompoundIdentifier extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            type?: CompoundIdentifier.CompoundIdentifierType;
            details?: string;
            value?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("details" in data && data.details != undefined) {
                    this.details = data.details;
                }
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
            }
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 1, CompoundIdentifier.CompoundIdentifierType.UNSPECIFIED) as CompoundIdentifier.CompoundIdentifierType;
        }
        set type(value: CompoundIdentifier.CompoundIdentifierType) {
            pb_1.Message.setField(this, 1, value);
        }
        get details() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set details(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set value(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            type?: CompoundIdentifier.CompoundIdentifierType;
            details?: string;
            value?: string;
        }): CompoundIdentifier {
            const message = new CompoundIdentifier({});
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.details != null) {
                message.details = data.details;
            }
            if (data.value != null) {
                message.value = data.value;
            }
            return message;
        }
        toObject() {
            const data: {
                type?: CompoundIdentifier.CompoundIdentifierType;
                details?: string;
                value?: string;
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.details != null) {
                data.details = this.details;
            }
            if (this.value != null) {
                data.value = this.value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type != CompoundIdentifier.CompoundIdentifierType.UNSPECIFIED)
                writer.writeEnum(1, this.type);
            if (this.details.length)
                writer.writeString(2, this.details);
            if (this.value.length)
                writer.writeString(3, this.value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CompoundIdentifier {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CompoundIdentifier();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readEnum();
                        break;
                    case 2:
                        message.details = reader.readString();
                        break;
                    case 3:
                        message.value = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CompoundIdentifier {
            return CompoundIdentifier.deserialize(bytes);
        }
    }
    export namespace CompoundIdentifier {
        export enum CompoundIdentifierType {
            UNSPECIFIED = 0,
            CUSTOM = 1,
            SMILES = 2,
            INCHI = 3,
            MOLBLOCK = 4,
            IUPAC_NAME = 5,
            NAME = 6,
            CAS_NUMBER = 7,
            PUBCHEM_CID = 8,
            CHEMSPIDER_ID = 9,
            CXSMILES = 10,
            INCHI_KEY = 11,
            XYZ = 12,
            UNIPROT_ID = 13,
            PDB_ID = 14,
            AMINO_ACID_SEQUENCE = 15,
            HELM = 16,
            MDL = 17
        }
    }
    export class Vessel extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            type?: Vessel.VesselType;
            details?: string;
            material?: VesselMaterial;
            preparations?: VesselPreparation[];
            attachments?: VesselAttachment[];
            volume?: Volume;
            vessel_id?: string;
            position?: string;
            row?: string;
            col?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [4, 5], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("details" in data && data.details != undefined) {
                    this.details = data.details;
                }
                if ("material" in data && data.material != undefined) {
                    this.material = data.material;
                }
                if ("preparations" in data && data.preparations != undefined) {
                    this.preparations = data.preparations;
                }
                if ("attachments" in data && data.attachments != undefined) {
                    this.attachments = data.attachments;
                }
                if ("volume" in data && data.volume != undefined) {
                    this.volume = data.volume;
                }
                if ("vessel_id" in data && data.vessel_id != undefined) {
                    this.vessel_id = data.vessel_id;
                }
                if ("position" in data && data.position != undefined) {
                    this.position = data.position;
                }
                if ("row" in data && data.row != undefined) {
                    this.row = data.row;
                }
                if ("col" in data && data.col != undefined) {
                    this.col = data.col;
                }
            }
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 1, Vessel.VesselType.UNSPECIFIED) as Vessel.VesselType;
        }
        set type(value: Vessel.VesselType) {
            pb_1.Message.setField(this, 1, value);
        }
        get details() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set details(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get material() {
            return pb_1.Message.getWrapperField(this, VesselMaterial, 3) as VesselMaterial;
        }
        set material(value: VesselMaterial) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_material() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get preparations() {
            return pb_1.Message.getRepeatedWrapperField(this, VesselPreparation, 4) as VesselPreparation[];
        }
        set preparations(value: VesselPreparation[]) {
            pb_1.Message.setRepeatedWrapperField(this, 4, value);
        }
        get attachments() {
            return pb_1.Message.getRepeatedWrapperField(this, VesselAttachment, 5) as VesselAttachment[];
        }
        set attachments(value: VesselAttachment[]) {
            pb_1.Message.setRepeatedWrapperField(this, 5, value);
        }
        get volume() {
            return pb_1.Message.getWrapperField(this, Volume, 6) as Volume;
        }
        set volume(value: Volume) {
            pb_1.Message.setWrapperField(this, 6, value);
        }
        get has_volume() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get vessel_id() {
            return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
        }
        set vessel_id(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        get position() {
            return pb_1.Message.getFieldWithDefault(this, 8, "") as string;
        }
        set position(value: string) {
            pb_1.Message.setField(this, 8, value);
        }
        get row() {
            return pb_1.Message.getFieldWithDefault(this, 9, "") as string;
        }
        set row(value: string) {
            pb_1.Message.setField(this, 9, value);
        }
        get col() {
            return pb_1.Message.getFieldWithDefault(this, 10, "") as string;
        }
        set col(value: string) {
            pb_1.Message.setField(this, 10, value);
        }
        static fromObject(data: {
            type?: Vessel.VesselType;
            details?: string;
            material?: ReturnType<typeof VesselMaterial.prototype.toObject>;
            preparations?: ReturnType<typeof VesselPreparation.prototype.toObject>[];
            attachments?: ReturnType<typeof VesselAttachment.prototype.toObject>[];
            volume?: ReturnType<typeof Volume.prototype.toObject>;
            vessel_id?: string;
            position?: string;
            row?: string;
            col?: string;
        }): Vessel {
            const message = new Vessel({});
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.details != null) {
                message.details = data.details;
            }
            if (data.material != null) {
                message.material = VesselMaterial.fromObject(data.material);
            }
            if (data.preparations != null) {
                message.preparations = data.preparations.map(item => VesselPreparation.fromObject(item));
            }
            if (data.attachments != null) {
                message.attachments = data.attachments.map(item => VesselAttachment.fromObject(item));
            }
            if (data.volume != null) {
                message.volume = Volume.fromObject(data.volume);
            }
            if (data.vessel_id != null) {
                message.vessel_id = data.vessel_id;
            }
            if (data.position != null) {
                message.position = data.position;
            }
            if (data.row != null) {
                message.row = data.row;
            }
            if (data.col != null) {
                message.col = data.col;
            }
            return message;
        }
        toObject() {
            const data: {
                type?: Vessel.VesselType;
                details?: string;
                material?: ReturnType<typeof VesselMaterial.prototype.toObject>;
                preparations?: ReturnType<typeof VesselPreparation.prototype.toObject>[];
                attachments?: ReturnType<typeof VesselAttachment.prototype.toObject>[];
                volume?: ReturnType<typeof Volume.prototype.toObject>;
                vessel_id?: string;
                position?: string;
                row?: string;
                col?: string;
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.details != null) {
                data.details = this.details;
            }
            if (this.material != null) {
                data.material = this.material.toObject();
            }
            if (this.preparations != null) {
                data.preparations = this.preparations.map((item: VesselPreparation) => item.toObject());
            }
            if (this.attachments != null) {
                data.attachments = this.attachments.map((item: VesselAttachment) => item.toObject());
            }
            if (this.volume != null) {
                data.volume = this.volume.toObject();
            }
            if (this.vessel_id != null) {
                data.vessel_id = this.vessel_id;
            }
            if (this.position != null) {
                data.position = this.position;
            }
            if (this.row != null) {
                data.row = this.row;
            }
            if (this.col != null) {
                data.col = this.col;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type != Vessel.VesselType.UNSPECIFIED)
                writer.writeEnum(1, this.type);
            if (this.details.length)
                writer.writeString(2, this.details);
            if (this.has_material)
                writer.writeMessage(3, this.material, () => this.material.serialize(writer));
            if (this.preparations.length)
                writer.writeRepeatedMessage(4, this.preparations, (item: VesselPreparation) => item.serialize(writer));
            if (this.attachments.length)
                writer.writeRepeatedMessage(5, this.attachments, (item: VesselAttachment) => item.serialize(writer));
            if (this.has_volume)
                writer.writeMessage(6, this.volume, () => this.volume.serialize(writer));
            if (this.vessel_id.length)
                writer.writeString(7, this.vessel_id);
            if (this.position.length)
                writer.writeString(8, this.position);
            if (this.row.length)
                writer.writeString(9, this.row);
            if (this.col.length)
                writer.writeString(10, this.col);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Vessel {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Vessel();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readEnum();
                        break;
                    case 2:
                        message.details = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.material, () => message.material = VesselMaterial.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.preparations, () => pb_1.Message.addToRepeatedWrapperField(message, 4, VesselPreparation.deserialize(reader), VesselPreparation));
                        break;
                    case 5:
                        reader.readMessage(message.attachments, () => pb_1.Message.addToRepeatedWrapperField(message, 5, VesselAttachment.deserialize(reader), VesselAttachment));
                        break;
                    case 6:
                        reader.readMessage(message.volume, () => message.volume = Volume.deserialize(reader));
                        break;
                    case 7:
                        message.vessel_id = reader.readString();
                        break;
                    case 8:
                        message.position = reader.readString();
                        break;
                    case 9:
                        message.row = reader.readString();
                        break;
                    case 10:
                        message.col = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Vessel {
            return Vessel.deserialize(bytes);
        }
    }
    export namespace Vessel {
        export enum VesselType {
            UNSPECIFIED = 0,
            CUSTOM = 1,
            ROUND_BOTTOM_FLASK = 2,
            VIAL = 3,
            WELL_PLATE = 4,
            MICROWAVE_VIAL = 5,
            TUBE = 6,
            CONTINUOUS_STIRRED_TANK_REACTOR = 7,
            PACKED_BED_REACTOR = 8,
            NMR_TUBE = 9,
            PRESSURE_FLASK = 10,
            PRESSURE_REACTOR = 11,
            ELECTROCHEMICAL_CELL = 12
        }
    }
    export class VesselMaterial extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            type?: VesselMaterial.VesselMaterialType;
            details?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("details" in data && data.details != undefined) {
                    this.details = data.details;
                }
            }
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 1, VesselMaterial.VesselMaterialType.UNSPECIFIED) as VesselMaterial.VesselMaterialType;
        }
        set type(value: VesselMaterial.VesselMaterialType) {
            pb_1.Message.setField(this, 1, value);
        }
        get details() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set details(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            type?: VesselMaterial.VesselMaterialType;
            details?: string;
        }): VesselMaterial {
            const message = new VesselMaterial({});
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.details != null) {
                message.details = data.details;
            }
            return message;
        }
        toObject() {
            const data: {
                type?: VesselMaterial.VesselMaterialType;
                details?: string;
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.details != null) {
                data.details = this.details;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type != VesselMaterial.VesselMaterialType.UNSPECIFIED)
                writer.writeEnum(1, this.type);
            if (this.details.length)
                writer.writeString(2, this.details);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): VesselMaterial {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new VesselMaterial();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readEnum();
                        break;
                    case 2:
                        message.details = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): VesselMaterial {
            return VesselMaterial.deserialize(bytes);
        }
    }
    export namespace VesselMaterial {
        export enum VesselMaterialType {
            UNSPECIFIED = 0,
            CUSTOM = 1,
            GLASS = 2,
            POLYPROPYLENE = 3,
            PLASTIC = 4,
            METAL = 5,
            QUARTZ = 6
        }
    }
    export class VesselAttachment extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            type?: VesselAttachment.VesselAttachmentType;
            details?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("details" in data && data.details != undefined) {
                    this.details = data.details;
                }
            }
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 1, VesselAttachment.VesselAttachmentType.UNSPECIFIED) as VesselAttachment.VesselAttachmentType;
        }
        set type(value: VesselAttachment.VesselAttachmentType) {
            pb_1.Message.setField(this, 1, value);
        }
        get details() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set details(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            type?: VesselAttachment.VesselAttachmentType;
            details?: string;
        }): VesselAttachment {
            const message = new VesselAttachment({});
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.details != null) {
                message.details = data.details;
            }
            return message;
        }
        toObject() {
            const data: {
                type?: VesselAttachment.VesselAttachmentType;
                details?: string;
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.details != null) {
                data.details = this.details;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type != VesselAttachment.VesselAttachmentType.UNSPECIFIED)
                writer.writeEnum(1, this.type);
            if (this.details.length)
                writer.writeString(2, this.details);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): VesselAttachment {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new VesselAttachment();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readEnum();
                        break;
                    case 2:
                        message.details = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): VesselAttachment {
            return VesselAttachment.deserialize(bytes);
        }
    }
    export namespace VesselAttachment {
        export enum VesselAttachmentType {
            UNSPECIFIED = 0,
            NONE = 1,
            CUSTOM = 2,
            SEPTUM = 3,
            CAP = 4,
            MAT = 5,
            REFLUX_CONDENSER = 6,
            VENT_NEEDLE = 7,
            DEAN_STARK = 8,
            VACUUM_TUBE = 9,
            ADDITION_FUNNEL = 10,
            DRYING_TUBE = 11,
            ALUMINUM_FOIL = 12,
            THERMOCOUPLE = 13,
            BALLOON = 14,
            GAS_ADAPTER = 15,
            PRESSURE_REGULATOR = 16,
            RELEASE_VALVE = 17
        }
    }
    export class VesselPreparation extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            type?: VesselPreparation.VesselPreparationType;
            details?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("details" in data && data.details != undefined) {
                    this.details = data.details;
                }
            }
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 1, VesselPreparation.VesselPreparationType.UNSPECIFIED) as VesselPreparation.VesselPreparationType;
        }
        set type(value: VesselPreparation.VesselPreparationType) {
            pb_1.Message.setField(this, 1, value);
        }
        get details() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set details(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            type?: VesselPreparation.VesselPreparationType;
            details?: string;
        }): VesselPreparation {
            const message = new VesselPreparation({});
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.details != null) {
                message.details = data.details;
            }
            return message;
        }
        toObject() {
            const data: {
                type?: VesselPreparation.VesselPreparationType;
                details?: string;
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.details != null) {
                data.details = this.details;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type != VesselPreparation.VesselPreparationType.UNSPECIFIED)
                writer.writeEnum(1, this.type);
            if (this.details.length)
                writer.writeString(2, this.details);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): VesselPreparation {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new VesselPreparation();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readEnum();
                        break;
                    case 2:
                        message.details = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): VesselPreparation {
            return VesselPreparation.deserialize(bytes);
        }
    }
    export namespace VesselPreparation {
        export enum VesselPreparationType {
            UNSPECIFIED = 0,
            CUSTOM = 1,
            NONE = 2,
            OVEN_DRIED = 3,
            FLAME_DRIED = 4,
            EVACUATED_BACKFILLED = 5,
            PURGED = 6
        }
    }
    export class ReactionSetup extends pb_1.Message {
        #one_of_decls: number[][] = [[2]];
        constructor(data?: any[] | ({
            vessel?: Vessel;
            automation_platform?: string;
            automation_code?: Map<string, Data>;
            environment?: ReactionSetup.ReactionEnvironment;
        } & (({
            is_automated?: boolean;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("vessel" in data && data.vessel != undefined) {
                    this.vessel = data.vessel;
                }
                if ("is_automated" in data && data.is_automated != undefined) {
                    this.is_automated = data.is_automated;
                }
                if ("automation_platform" in data && data.automation_platform != undefined) {
                    this.automation_platform = data.automation_platform;
                }
                if ("automation_code" in data && data.automation_code != undefined) {
                    this.automation_code = data.automation_code;
                }
                if ("environment" in data && data.environment != undefined) {
                    this.environment = data.environment;
                }
            }
            if (!this.automation_code)
                this.automation_code = new Map();
        }
        get vessel() {
            return pb_1.Message.getWrapperField(this, Vessel, 1) as Vessel;
        }
        set vessel(value: Vessel) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_vessel() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get is_automated() {
            return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
        }
        set is_automated(value: boolean) {
            pb_1.Message.setOneofField(this, 2, this.#one_of_decls[0], value);
        }
        get has_is_automated() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get automation_platform() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set automation_platform(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get automation_code() {
            return pb_1.Message.getField(this, 4) as any as Map<string, Data>;
        }
        set automation_code(value: Map<string, Data>) {
            pb_1.Message.setField(this, 4, value as any);
        }
        get environment() {
            return pb_1.Message.getWrapperField(this, ReactionSetup.ReactionEnvironment, 5) as ReactionSetup.ReactionEnvironment;
        }
        set environment(value: ReactionSetup.ReactionEnvironment) {
            pb_1.Message.setWrapperField(this, 5, value);
        }
        get has_environment() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get _is_automated() {
            const cases: {
                [index: number]: "none" | "is_automated";
            } = {
                0: "none",
                2: "is_automated"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        static fromObject(data: {
            vessel?: ReturnType<typeof Vessel.prototype.toObject>;
            is_automated?: boolean;
            automation_platform?: string;
            automation_code?: {
                [key: string]: ReturnType<typeof Data.prototype.toObject>;
            };
            environment?: ReturnType<typeof ReactionSetup.ReactionEnvironment.prototype.toObject>;
        }): ReactionSetup {
            const message = new ReactionSetup({});
            if (data.vessel != null) {
                message.vessel = Vessel.fromObject(data.vessel);
            }
            if (data.is_automated != null) {
                message.is_automated = data.is_automated;
            }
            if (data.automation_platform != null) {
                message.automation_platform = data.automation_platform;
            }
            if (typeof data.automation_code == "object") {
                message.automation_code = new Map(Object.entries(data.automation_code).map(([key, value]) => [key, Data.fromObject(value)]));
            }
            if (data.environment != null) {
                message.environment = ReactionSetup.ReactionEnvironment.fromObject(data.environment);
            }
            return message;
        }
        toObject() {
            const data: {
                vessel?: ReturnType<typeof Vessel.prototype.toObject>;
                is_automated?: boolean;
                automation_platform?: string;
                automation_code?: {
                    [key: string]: ReturnType<typeof Data.prototype.toObject>;
                };
                environment?: ReturnType<typeof ReactionSetup.ReactionEnvironment.prototype.toObject>;
            } = {};
            if (this.vessel != null) {
                data.vessel = this.vessel.toObject();
            }
            if (this.is_automated != null) {
                data.is_automated = this.is_automated;
            }
            if (this.automation_platform != null) {
                data.automation_platform = this.automation_platform;
            }
            if (this.automation_code != null) {
                data.automation_code = (Object.fromEntries)((Array.from)(this.automation_code).map(([key, value]) => [key, value.toObject()]));
            }
            if (this.environment != null) {
                data.environment = this.environment.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_vessel)
                writer.writeMessage(1, this.vessel, () => this.vessel.serialize(writer));
            if (this.has_is_automated)
                writer.writeBool(2, this.is_automated);
            if (this.automation_platform.length)
                writer.writeString(3, this.automation_platform);
            for (const [key, value] of this.automation_code) {
                writer.writeMessage(4, this.automation_code, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (this.has_environment)
                writer.writeMessage(5, this.environment, () => this.environment.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ReactionSetup {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ReactionSetup();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.vessel, () => message.vessel = Vessel.deserialize(reader));
                        break;
                    case 2:
                        message.is_automated = reader.readBool();
                        break;
                    case 3:
                        message.automation_platform = reader.readString();
                        break;
                    case 4:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.automation_code as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = Data.deserialize(reader));
                            return value;
                        }));
                        break;
                    case 5:
                        reader.readMessage(message.environment, () => message.environment = ReactionSetup.ReactionEnvironment.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ReactionSetup {
            return ReactionSetup.deserialize(bytes);
        }
    }
    export namespace ReactionSetup {
        export class ReactionEnvironment extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                type?: ReactionSetup.ReactionEnvironment.ReactionEnvironmentType;
                details?: string;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("type" in data && data.type != undefined) {
                        this.type = data.type;
                    }
                    if ("details" in data && data.details != undefined) {
                        this.details = data.details;
                    }
                }
            }
            get type() {
                return pb_1.Message.getFieldWithDefault(this, 1, ReactionSetup.ReactionEnvironment.ReactionEnvironmentType.UNSPECIFIED) as ReactionSetup.ReactionEnvironment.ReactionEnvironmentType;
            }
            set type(value: ReactionSetup.ReactionEnvironment.ReactionEnvironmentType) {
                pb_1.Message.setField(this, 1, value);
            }
            get details() {
                return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
            }
            set details(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            static fromObject(data: {
                type?: ReactionSetup.ReactionEnvironment.ReactionEnvironmentType;
                details?: string;
            }): ReactionEnvironment {
                const message = new ReactionEnvironment({});
                if (data.type != null) {
                    message.type = data.type;
                }
                if (data.details != null) {
                    message.details = data.details;
                }
                return message;
            }
            toObject() {
                const data: {
                    type?: ReactionSetup.ReactionEnvironment.ReactionEnvironmentType;
                    details?: string;
                } = {};
                if (this.type != null) {
                    data.type = this.type;
                }
                if (this.details != null) {
                    data.details = this.details;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.type != ReactionSetup.ReactionEnvironment.ReactionEnvironmentType.UNSPECIFIED)
                    writer.writeEnum(1, this.type);
                if (this.details.length)
                    writer.writeString(2, this.details);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ReactionEnvironment {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ReactionEnvironment();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.type = reader.readEnum();
                            break;
                        case 2:
                            message.details = reader.readString();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): ReactionEnvironment {
                return ReactionEnvironment.deserialize(bytes);
            }
        }
        export namespace ReactionEnvironment {
            export enum ReactionEnvironmentType {
                UNSPECIFIED = 0,
                CUSTOM = 1,
                FUME_HOOD = 2,
                BENCH_TOP = 3,
                GLOVE_BOX = 4,
                GLOVE_BAG = 5
            }
        }
    }
    export class ReactionConditions extends pb_1.Message {
        #one_of_decls: number[][] = [[7], [8], [9]];
        constructor(data?: any[] | ({
            temperature?: TemperatureConditions;
            pressure?: PressureConditions;
            stirring?: StirringConditions;
            illumination?: IlluminationConditions;
            electrochemistry?: ElectrochemistryConditions;
            flow?: FlowConditions;
            details?: string;
        } & (({
            reflux?: boolean;
        }) | ({
            ph?: number;
        }) | ({
            conditions_are_dynamic?: boolean;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("temperature" in data && data.temperature != undefined) {
                    this.temperature = data.temperature;
                }
                if ("pressure" in data && data.pressure != undefined) {
                    this.pressure = data.pressure;
                }
                if ("stirring" in data && data.stirring != undefined) {
                    this.stirring = data.stirring;
                }
                if ("illumination" in data && data.illumination != undefined) {
                    this.illumination = data.illumination;
                }
                if ("electrochemistry" in data && data.electrochemistry != undefined) {
                    this.electrochemistry = data.electrochemistry;
                }
                if ("flow" in data && data.flow != undefined) {
                    this.flow = data.flow;
                }
                if ("reflux" in data && data.reflux != undefined) {
                    this.reflux = data.reflux;
                }
                if ("ph" in data && data.ph != undefined) {
                    this.ph = data.ph;
                }
                if ("conditions_are_dynamic" in data && data.conditions_are_dynamic != undefined) {
                    this.conditions_are_dynamic = data.conditions_are_dynamic;
                }
                if ("details" in data && data.details != undefined) {
                    this.details = data.details;
                }
            }
        }
        get temperature() {
            return pb_1.Message.getWrapperField(this, TemperatureConditions, 1) as TemperatureConditions;
        }
        set temperature(value: TemperatureConditions) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_temperature() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get pressure() {
            return pb_1.Message.getWrapperField(this, PressureConditions, 2) as PressureConditions;
        }
        set pressure(value: PressureConditions) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_pressure() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get stirring() {
            return pb_1.Message.getWrapperField(this, StirringConditions, 3) as StirringConditions;
        }
        set stirring(value: StirringConditions) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_stirring() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get illumination() {
            return pb_1.Message.getWrapperField(this, IlluminationConditions, 4) as IlluminationConditions;
        }
        set illumination(value: IlluminationConditions) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get has_illumination() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get electrochemistry() {
            return pb_1.Message.getWrapperField(this, ElectrochemistryConditions, 5) as ElectrochemistryConditions;
        }
        set electrochemistry(value: ElectrochemistryConditions) {
            pb_1.Message.setWrapperField(this, 5, value);
        }
        get has_electrochemistry() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get flow() {
            return pb_1.Message.getWrapperField(this, FlowConditions, 6) as FlowConditions;
        }
        set flow(value: FlowConditions) {
            pb_1.Message.setWrapperField(this, 6, value);
        }
        get has_flow() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get reflux() {
            return pb_1.Message.getFieldWithDefault(this, 7, false) as boolean;
        }
        set reflux(value: boolean) {
            pb_1.Message.setOneofField(this, 7, this.#one_of_decls[0], value);
        }
        get has_reflux() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get ph() {
            return pb_1.Message.getFieldWithDefault(this, 8, 0) as number;
        }
        set ph(value: number) {
            pb_1.Message.setOneofField(this, 8, this.#one_of_decls[1], value);
        }
        get has_ph() {
            return pb_1.Message.getField(this, 8) != null;
        }
        get conditions_are_dynamic() {
            return pb_1.Message.getFieldWithDefault(this, 9, false) as boolean;
        }
        set conditions_are_dynamic(value: boolean) {
            pb_1.Message.setOneofField(this, 9, this.#one_of_decls[2], value);
        }
        get has_conditions_are_dynamic() {
            return pb_1.Message.getField(this, 9) != null;
        }
        get details() {
            return pb_1.Message.getFieldWithDefault(this, 10, "") as string;
        }
        set details(value: string) {
            pb_1.Message.setField(this, 10, value);
        }
        get _reflux() {
            const cases: {
                [index: number]: "none" | "reflux";
            } = {
                0: "none",
                7: "reflux"
            };
            return cases[pb_1.Message.computeOneofCase(this, [7])];
        }
        get _ph() {
            const cases: {
                [index: number]: "none" | "ph";
            } = {
                0: "none",
                8: "ph"
            };
            return cases[pb_1.Message.computeOneofCase(this, [8])];
        }
        get _conditions_are_dynamic() {
            const cases: {
                [index: number]: "none" | "conditions_are_dynamic";
            } = {
                0: "none",
                9: "conditions_are_dynamic"
            };
            return cases[pb_1.Message.computeOneofCase(this, [9])];
        }
        static fromObject(data: {
            temperature?: ReturnType<typeof TemperatureConditions.prototype.toObject>;
            pressure?: ReturnType<typeof PressureConditions.prototype.toObject>;
            stirring?: ReturnType<typeof StirringConditions.prototype.toObject>;
            illumination?: ReturnType<typeof IlluminationConditions.prototype.toObject>;
            electrochemistry?: ReturnType<typeof ElectrochemistryConditions.prototype.toObject>;
            flow?: ReturnType<typeof FlowConditions.prototype.toObject>;
            reflux?: boolean;
            ph?: number;
            conditions_are_dynamic?: boolean;
            details?: string;
        }): ReactionConditions {
            const message = new ReactionConditions({});
            if (data.temperature != null) {
                message.temperature = TemperatureConditions.fromObject(data.temperature);
            }
            if (data.pressure != null) {
                message.pressure = PressureConditions.fromObject(data.pressure);
            }
            if (data.stirring != null) {
                message.stirring = StirringConditions.fromObject(data.stirring);
            }
            if (data.illumination != null) {
                message.illumination = IlluminationConditions.fromObject(data.illumination);
            }
            if (data.electrochemistry != null) {
                message.electrochemistry = ElectrochemistryConditions.fromObject(data.electrochemistry);
            }
            if (data.flow != null) {
                message.flow = FlowConditions.fromObject(data.flow);
            }
            if (data.reflux != null) {
                message.reflux = data.reflux;
            }
            if (data.ph != null) {
                message.ph = data.ph;
            }
            if (data.conditions_are_dynamic != null) {
                message.conditions_are_dynamic = data.conditions_are_dynamic;
            }
            if (data.details != null) {
                message.details = data.details;
            }
            return message;
        }
        toObject() {
            const data: {
                temperature?: ReturnType<typeof TemperatureConditions.prototype.toObject>;
                pressure?: ReturnType<typeof PressureConditions.prototype.toObject>;
                stirring?: ReturnType<typeof StirringConditions.prototype.toObject>;
                illumination?: ReturnType<typeof IlluminationConditions.prototype.toObject>;
                electrochemistry?: ReturnType<typeof ElectrochemistryConditions.prototype.toObject>;
                flow?: ReturnType<typeof FlowConditions.prototype.toObject>;
                reflux?: boolean;
                ph?: number;
                conditions_are_dynamic?: boolean;
                details?: string;
            } = {};
            if (this.temperature != null) {
                data.temperature = this.temperature.toObject();
            }
            if (this.pressure != null) {
                data.pressure = this.pressure.toObject();
            }
            if (this.stirring != null) {
                data.stirring = this.stirring.toObject();
            }
            if (this.illumination != null) {
                data.illumination = this.illumination.toObject();
            }
            if (this.electrochemistry != null) {
                data.electrochemistry = this.electrochemistry.toObject();
            }
            if (this.flow != null) {
                data.flow = this.flow.toObject();
            }
            if (this.reflux != null) {
                data.reflux = this.reflux;
            }
            if (this.ph != null) {
                data.ph = this.ph;
            }
            if (this.conditions_are_dynamic != null) {
                data.conditions_are_dynamic = this.conditions_are_dynamic;
            }
            if (this.details != null) {
                data.details = this.details;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_temperature)
                writer.writeMessage(1, this.temperature, () => this.temperature.serialize(writer));
            if (this.has_pressure)
                writer.writeMessage(2, this.pressure, () => this.pressure.serialize(writer));
            if (this.has_stirring)
                writer.writeMessage(3, this.stirring, () => this.stirring.serialize(writer));
            if (this.has_illumination)
                writer.writeMessage(4, this.illumination, () => this.illumination.serialize(writer));
            if (this.has_electrochemistry)
                writer.writeMessage(5, this.electrochemistry, () => this.electrochemistry.serialize(writer));
            if (this.has_flow)
                writer.writeMessage(6, this.flow, () => this.flow.serialize(writer));
            if (this.has_reflux)
                writer.writeBool(7, this.reflux);
            if (this.has_ph)
                writer.writeFloat(8, this.ph);
            if (this.has_conditions_are_dynamic)
                writer.writeBool(9, this.conditions_are_dynamic);
            if (this.details.length)
                writer.writeString(10, this.details);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ReactionConditions {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ReactionConditions();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.temperature, () => message.temperature = TemperatureConditions.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.pressure, () => message.pressure = PressureConditions.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.stirring, () => message.stirring = StirringConditions.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.illumination, () => message.illumination = IlluminationConditions.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.electrochemistry, () => message.electrochemistry = ElectrochemistryConditions.deserialize(reader));
                        break;
                    case 6:
                        reader.readMessage(message.flow, () => message.flow = FlowConditions.deserialize(reader));
                        break;
                    case 7:
                        message.reflux = reader.readBool();
                        break;
                    case 8:
                        message.ph = reader.readFloat();
                        break;
                    case 9:
                        message.conditions_are_dynamic = reader.readBool();
                        break;
                    case 10:
                        message.details = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ReactionConditions {
            return ReactionConditions.deserialize(bytes);
        }
    }
    export class TemperatureConditions extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            control?: TemperatureConditions.TemperatureControl;
            setpoint?: Temperature;
            measurements?: TemperatureConditions.TemperatureMeasurement[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("control" in data && data.control != undefined) {
                    this.control = data.control;
                }
                if ("setpoint" in data && data.setpoint != undefined) {
                    this.setpoint = data.setpoint;
                }
                if ("measurements" in data && data.measurements != undefined) {
                    this.measurements = data.measurements;
                }
            }
        }
        get control() {
            return pb_1.Message.getWrapperField(this, TemperatureConditions.TemperatureControl, 1) as TemperatureConditions.TemperatureControl;
        }
        set control(value: TemperatureConditions.TemperatureControl) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_control() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get setpoint() {
            return pb_1.Message.getWrapperField(this, Temperature, 2) as Temperature;
        }
        set setpoint(value: Temperature) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_setpoint() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get measurements() {
            return pb_1.Message.getRepeatedWrapperField(this, TemperatureConditions.TemperatureMeasurement, 3) as TemperatureConditions.TemperatureMeasurement[];
        }
        set measurements(value: TemperatureConditions.TemperatureMeasurement[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        static fromObject(data: {
            control?: ReturnType<typeof TemperatureConditions.TemperatureControl.prototype.toObject>;
            setpoint?: ReturnType<typeof Temperature.prototype.toObject>;
            measurements?: ReturnType<typeof TemperatureConditions.TemperatureMeasurement.prototype.toObject>[];
        }): TemperatureConditions {
            const message = new TemperatureConditions({});
            if (data.control != null) {
                message.control = TemperatureConditions.TemperatureControl.fromObject(data.control);
            }
            if (data.setpoint != null) {
                message.setpoint = Temperature.fromObject(data.setpoint);
            }
            if (data.measurements != null) {
                message.measurements = data.measurements.map(item => TemperatureConditions.TemperatureMeasurement.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                control?: ReturnType<typeof TemperatureConditions.TemperatureControl.prototype.toObject>;
                setpoint?: ReturnType<typeof Temperature.prototype.toObject>;
                measurements?: ReturnType<typeof TemperatureConditions.TemperatureMeasurement.prototype.toObject>[];
            } = {};
            if (this.control != null) {
                data.control = this.control.toObject();
            }
            if (this.setpoint != null) {
                data.setpoint = this.setpoint.toObject();
            }
            if (this.measurements != null) {
                data.measurements = this.measurements.map((item: TemperatureConditions.TemperatureMeasurement) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_control)
                writer.writeMessage(1, this.control, () => this.control.serialize(writer));
            if (this.has_setpoint)
                writer.writeMessage(2, this.setpoint, () => this.setpoint.serialize(writer));
            if (this.measurements.length)
                writer.writeRepeatedMessage(3, this.measurements, (item: TemperatureConditions.TemperatureMeasurement) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TemperatureConditions {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TemperatureConditions();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.control, () => message.control = TemperatureConditions.TemperatureControl.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.setpoint, () => message.setpoint = Temperature.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.measurements, () => pb_1.Message.addToRepeatedWrapperField(message, 3, TemperatureConditions.TemperatureMeasurement.deserialize(reader), TemperatureConditions.TemperatureMeasurement));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TemperatureConditions {
            return TemperatureConditions.deserialize(bytes);
        }
    }
    export namespace TemperatureConditions {
        export class TemperatureControl extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                type?: TemperatureConditions.TemperatureControl.TemperatureControlType;
                details?: string;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("type" in data && data.type != undefined) {
                        this.type = data.type;
                    }
                    if ("details" in data && data.details != undefined) {
                        this.details = data.details;
                    }
                }
            }
            get type() {
                return pb_1.Message.getFieldWithDefault(this, 1, TemperatureConditions.TemperatureControl.TemperatureControlType.UNSPECIFIED) as TemperatureConditions.TemperatureControl.TemperatureControlType;
            }
            set type(value: TemperatureConditions.TemperatureControl.TemperatureControlType) {
                pb_1.Message.setField(this, 1, value);
            }
            get details() {
                return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
            }
            set details(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            static fromObject(data: {
                type?: TemperatureConditions.TemperatureControl.TemperatureControlType;
                details?: string;
            }): TemperatureControl {
                const message = new TemperatureControl({});
                if (data.type != null) {
                    message.type = data.type;
                }
                if (data.details != null) {
                    message.details = data.details;
                }
                return message;
            }
            toObject() {
                const data: {
                    type?: TemperatureConditions.TemperatureControl.TemperatureControlType;
                    details?: string;
                } = {};
                if (this.type != null) {
                    data.type = this.type;
                }
                if (this.details != null) {
                    data.details = this.details;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.type != TemperatureConditions.TemperatureControl.TemperatureControlType.UNSPECIFIED)
                    writer.writeEnum(1, this.type);
                if (this.details.length)
                    writer.writeString(2, this.details);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TemperatureControl {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TemperatureControl();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.type = reader.readEnum();
                            break;
                        case 2:
                            message.details = reader.readString();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): TemperatureControl {
                return TemperatureControl.deserialize(bytes);
            }
        }
        export namespace TemperatureControl {
            export enum TemperatureControlType {
                UNSPECIFIED = 0,
                CUSTOM = 1,
                AMBIENT = 2,
                OIL_BATH = 3,
                WATER_BATH = 4,
                SAND_BATH = 5,
                ICE_BATH = 6,
                DRY_ALUMINUM_PLATE = 7,
                MICROWAVE = 8,
                DRY_ICE_BATH = 9,
                AIR_FAN = 10,
                LIQUID_NITROGEN = 11
            }
        }
        export class TemperatureMeasurement extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                type?: TemperatureConditions.TemperatureMeasurement.TemperatureMeasurementType;
                details?: string;
                time?: Time;
                temperature?: Temperature;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("type" in data && data.type != undefined) {
                        this.type = data.type;
                    }
                    if ("details" in data && data.details != undefined) {
                        this.details = data.details;
                    }
                    if ("time" in data && data.time != undefined) {
                        this.time = data.time;
                    }
                    if ("temperature" in data && data.temperature != undefined) {
                        this.temperature = data.temperature;
                    }
                }
            }
            get type() {
                return pb_1.Message.getFieldWithDefault(this, 1, TemperatureConditions.TemperatureMeasurement.TemperatureMeasurementType.UNSPECIFIED) as TemperatureConditions.TemperatureMeasurement.TemperatureMeasurementType;
            }
            set type(value: TemperatureConditions.TemperatureMeasurement.TemperatureMeasurementType) {
                pb_1.Message.setField(this, 1, value);
            }
            get details() {
                return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
            }
            set details(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            get time() {
                return pb_1.Message.getWrapperField(this, Time, 3) as Time;
            }
            set time(value: Time) {
                pb_1.Message.setWrapperField(this, 3, value);
            }
            get has_time() {
                return pb_1.Message.getField(this, 3) != null;
            }
            get temperature() {
                return pb_1.Message.getWrapperField(this, Temperature, 4) as Temperature;
            }
            set temperature(value: Temperature) {
                pb_1.Message.setWrapperField(this, 4, value);
            }
            get has_temperature() {
                return pb_1.Message.getField(this, 4) != null;
            }
            static fromObject(data: {
                type?: TemperatureConditions.TemperatureMeasurement.TemperatureMeasurementType;
                details?: string;
                time?: ReturnType<typeof Time.prototype.toObject>;
                temperature?: ReturnType<typeof Temperature.prototype.toObject>;
            }): TemperatureMeasurement {
                const message = new TemperatureMeasurement({});
                if (data.type != null) {
                    message.type = data.type;
                }
                if (data.details != null) {
                    message.details = data.details;
                }
                if (data.time != null) {
                    message.time = Time.fromObject(data.time);
                }
                if (data.temperature != null) {
                    message.temperature = Temperature.fromObject(data.temperature);
                }
                return message;
            }
            toObject() {
                const data: {
                    type?: TemperatureConditions.TemperatureMeasurement.TemperatureMeasurementType;
                    details?: string;
                    time?: ReturnType<typeof Time.prototype.toObject>;
                    temperature?: ReturnType<typeof Temperature.prototype.toObject>;
                } = {};
                if (this.type != null) {
                    data.type = this.type;
                }
                if (this.details != null) {
                    data.details = this.details;
                }
                if (this.time != null) {
                    data.time = this.time.toObject();
                }
                if (this.temperature != null) {
                    data.temperature = this.temperature.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.type != TemperatureConditions.TemperatureMeasurement.TemperatureMeasurementType.UNSPECIFIED)
                    writer.writeEnum(1, this.type);
                if (this.details.length)
                    writer.writeString(2, this.details);
                if (this.has_time)
                    writer.writeMessage(3, this.time, () => this.time.serialize(writer));
                if (this.has_temperature)
                    writer.writeMessage(4, this.temperature, () => this.temperature.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TemperatureMeasurement {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TemperatureMeasurement();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.type = reader.readEnum();
                            break;
                        case 2:
                            message.details = reader.readString();
                            break;
                        case 3:
                            reader.readMessage(message.time, () => message.time = Time.deserialize(reader));
                            break;
                        case 4:
                            reader.readMessage(message.temperature, () => message.temperature = Temperature.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): TemperatureMeasurement {
                return TemperatureMeasurement.deserialize(bytes);
            }
        }
        export namespace TemperatureMeasurement {
            export enum TemperatureMeasurementType {
                UNSPECIFIED = 0,
                CUSTOM = 1,
                THERMOCOUPLE_INTERNAL = 2,
                THERMOCOUPLE_EXTERNAL = 3,
                INFRARED = 4
            }
        }
    }
    export class PressureConditions extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            control?: PressureConditions.PressureControl;
            setpoint?: Pressure;
            atmosphere?: PressureConditions.Atmosphere;
            measurements?: PressureConditions.PressureMeasurement[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [4], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("control" in data && data.control != undefined) {
                    this.control = data.control;
                }
                if ("setpoint" in data && data.setpoint != undefined) {
                    this.setpoint = data.setpoint;
                }
                if ("atmosphere" in data && data.atmosphere != undefined) {
                    this.atmosphere = data.atmosphere;
                }
                if ("measurements" in data && data.measurements != undefined) {
                    this.measurements = data.measurements;
                }
            }
        }
        get control() {
            return pb_1.Message.getWrapperField(this, PressureConditions.PressureControl, 1) as PressureConditions.PressureControl;
        }
        set control(value: PressureConditions.PressureControl) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_control() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get setpoint() {
            return pb_1.Message.getWrapperField(this, Pressure, 2) as Pressure;
        }
        set setpoint(value: Pressure) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_setpoint() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get atmosphere() {
            return pb_1.Message.getWrapperField(this, PressureConditions.Atmosphere, 3) as PressureConditions.Atmosphere;
        }
        set atmosphere(value: PressureConditions.Atmosphere) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_atmosphere() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get measurements() {
            return pb_1.Message.getRepeatedWrapperField(this, PressureConditions.PressureMeasurement, 4) as PressureConditions.PressureMeasurement[];
        }
        set measurements(value: PressureConditions.PressureMeasurement[]) {
            pb_1.Message.setRepeatedWrapperField(this, 4, value);
        }
        static fromObject(data: {
            control?: ReturnType<typeof PressureConditions.PressureControl.prototype.toObject>;
            setpoint?: ReturnType<typeof Pressure.prototype.toObject>;
            atmosphere?: ReturnType<typeof PressureConditions.Atmosphere.prototype.toObject>;
            measurements?: ReturnType<typeof PressureConditions.PressureMeasurement.prototype.toObject>[];
        }): PressureConditions {
            const message = new PressureConditions({});
            if (data.control != null) {
                message.control = PressureConditions.PressureControl.fromObject(data.control);
            }
            if (data.setpoint != null) {
                message.setpoint = Pressure.fromObject(data.setpoint);
            }
            if (data.atmosphere != null) {
                message.atmosphere = PressureConditions.Atmosphere.fromObject(data.atmosphere);
            }
            if (data.measurements != null) {
                message.measurements = data.measurements.map(item => PressureConditions.PressureMeasurement.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                control?: ReturnType<typeof PressureConditions.PressureControl.prototype.toObject>;
                setpoint?: ReturnType<typeof Pressure.prototype.toObject>;
                atmosphere?: ReturnType<typeof PressureConditions.Atmosphere.prototype.toObject>;
                measurements?: ReturnType<typeof PressureConditions.PressureMeasurement.prototype.toObject>[];
            } = {};
            if (this.control != null) {
                data.control = this.control.toObject();
            }
            if (this.setpoint != null) {
                data.setpoint = this.setpoint.toObject();
            }
            if (this.atmosphere != null) {
                data.atmosphere = this.atmosphere.toObject();
            }
            if (this.measurements != null) {
                data.measurements = this.measurements.map((item: PressureConditions.PressureMeasurement) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_control)
                writer.writeMessage(1, this.control, () => this.control.serialize(writer));
            if (this.has_setpoint)
                writer.writeMessage(2, this.setpoint, () => this.setpoint.serialize(writer));
            if (this.has_atmosphere)
                writer.writeMessage(3, this.atmosphere, () => this.atmosphere.serialize(writer));
            if (this.measurements.length)
                writer.writeRepeatedMessage(4, this.measurements, (item: PressureConditions.PressureMeasurement) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PressureConditions {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PressureConditions();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.control, () => message.control = PressureConditions.PressureControl.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.setpoint, () => message.setpoint = Pressure.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.atmosphere, () => message.atmosphere = PressureConditions.Atmosphere.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.measurements, () => pb_1.Message.addToRepeatedWrapperField(message, 4, PressureConditions.PressureMeasurement.deserialize(reader), PressureConditions.PressureMeasurement));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PressureConditions {
            return PressureConditions.deserialize(bytes);
        }
    }
    export namespace PressureConditions {
        export class PressureControl extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                type?: PressureConditions.PressureControl.PressureControlType;
                details?: string;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("type" in data && data.type != undefined) {
                        this.type = data.type;
                    }
                    if ("details" in data && data.details != undefined) {
                        this.details = data.details;
                    }
                }
            }
            get type() {
                return pb_1.Message.getFieldWithDefault(this, 1, PressureConditions.PressureControl.PressureControlType.UNSPECIFIED) as PressureConditions.PressureControl.PressureControlType;
            }
            set type(value: PressureConditions.PressureControl.PressureControlType) {
                pb_1.Message.setField(this, 1, value);
            }
            get details() {
                return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
            }
            set details(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            static fromObject(data: {
                type?: PressureConditions.PressureControl.PressureControlType;
                details?: string;
            }): PressureControl {
                const message = new PressureControl({});
                if (data.type != null) {
                    message.type = data.type;
                }
                if (data.details != null) {
                    message.details = data.details;
                }
                return message;
            }
            toObject() {
                const data: {
                    type?: PressureConditions.PressureControl.PressureControlType;
                    details?: string;
                } = {};
                if (this.type != null) {
                    data.type = this.type;
                }
                if (this.details != null) {
                    data.details = this.details;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.type != PressureConditions.PressureControl.PressureControlType.UNSPECIFIED)
                    writer.writeEnum(1, this.type);
                if (this.details.length)
                    writer.writeString(2, this.details);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PressureControl {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PressureControl();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.type = reader.readEnum();
                            break;
                        case 2:
                            message.details = reader.readString();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): PressureControl {
                return PressureControl.deserialize(bytes);
            }
        }
        export namespace PressureControl {
            export enum PressureControlType {
                UNSPECIFIED = 0,
                CUSTOM = 1,
                AMBIENT = 2,
                SLIGHT_POSITIVE = 3,
                SEALED = 4,
                PRESSURIZED = 5
            }
        }
        export class Atmosphere extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                type?: PressureConditions.Atmosphere.AtmosphereType;
                details?: string;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("type" in data && data.type != undefined) {
                        this.type = data.type;
                    }
                    if ("details" in data && data.details != undefined) {
                        this.details = data.details;
                    }
                }
            }
            get type() {
                return pb_1.Message.getFieldWithDefault(this, 1, PressureConditions.Atmosphere.AtmosphereType.UNSPECIFIED) as PressureConditions.Atmosphere.AtmosphereType;
            }
            set type(value: PressureConditions.Atmosphere.AtmosphereType) {
                pb_1.Message.setField(this, 1, value);
            }
            get details() {
                return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
            }
            set details(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            static fromObject(data: {
                type?: PressureConditions.Atmosphere.AtmosphereType;
                details?: string;
            }): Atmosphere {
                const message = new Atmosphere({});
                if (data.type != null) {
                    message.type = data.type;
                }
                if (data.details != null) {
                    message.details = data.details;
                }
                return message;
            }
            toObject() {
                const data: {
                    type?: PressureConditions.Atmosphere.AtmosphereType;
                    details?: string;
                } = {};
                if (this.type != null) {
                    data.type = this.type;
                }
                if (this.details != null) {
                    data.details = this.details;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.type != PressureConditions.Atmosphere.AtmosphereType.UNSPECIFIED)
                    writer.writeEnum(1, this.type);
                if (this.details.length)
                    writer.writeString(2, this.details);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Atmosphere {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Atmosphere();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.type = reader.readEnum();
                            break;
                        case 2:
                            message.details = reader.readString();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Atmosphere {
                return Atmosphere.deserialize(bytes);
            }
        }
        export namespace Atmosphere {
            export enum AtmosphereType {
                UNSPECIFIED = 0,
                CUSTOM = 1,
                AIR = 2,
                NITROGEN = 3,
                ARGON = 4,
                OXYGEN = 5,
                HYDROGEN = 6,
                CARBON_MONOXIDE = 7,
                CARBON_DIOXIDE = 8,
                METHANE = 9,
                AMMONIA = 10,
                OZONE = 11,
                ETHYLENE = 12,
                ACETYLENE = 13
            }
        }
        export class PressureMeasurement extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                type?: PressureConditions.PressureMeasurement.PressureMeasurementType;
                details?: string;
                time?: Time;
                pressure?: Pressure;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("type" in data && data.type != undefined) {
                        this.type = data.type;
                    }
                    if ("details" in data && data.details != undefined) {
                        this.details = data.details;
                    }
                    if ("time" in data && data.time != undefined) {
                        this.time = data.time;
                    }
                    if ("pressure" in data && data.pressure != undefined) {
                        this.pressure = data.pressure;
                    }
                }
            }
            get type() {
                return pb_1.Message.getFieldWithDefault(this, 1, PressureConditions.PressureMeasurement.PressureMeasurementType.UNSPECIFIED) as PressureConditions.PressureMeasurement.PressureMeasurementType;
            }
            set type(value: PressureConditions.PressureMeasurement.PressureMeasurementType) {
                pb_1.Message.setField(this, 1, value);
            }
            get details() {
                return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
            }
            set details(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            get time() {
                return pb_1.Message.getWrapperField(this, Time, 3) as Time;
            }
            set time(value: Time) {
                pb_1.Message.setWrapperField(this, 3, value);
            }
            get has_time() {
                return pb_1.Message.getField(this, 3) != null;
            }
            get pressure() {
                return pb_1.Message.getWrapperField(this, Pressure, 4) as Pressure;
            }
            set pressure(value: Pressure) {
                pb_1.Message.setWrapperField(this, 4, value);
            }
            get has_pressure() {
                return pb_1.Message.getField(this, 4) != null;
            }
            static fromObject(data: {
                type?: PressureConditions.PressureMeasurement.PressureMeasurementType;
                details?: string;
                time?: ReturnType<typeof Time.prototype.toObject>;
                pressure?: ReturnType<typeof Pressure.prototype.toObject>;
            }): PressureMeasurement {
                const message = new PressureMeasurement({});
                if (data.type != null) {
                    message.type = data.type;
                }
                if (data.details != null) {
                    message.details = data.details;
                }
                if (data.time != null) {
                    message.time = Time.fromObject(data.time);
                }
                if (data.pressure != null) {
                    message.pressure = Pressure.fromObject(data.pressure);
                }
                return message;
            }
            toObject() {
                const data: {
                    type?: PressureConditions.PressureMeasurement.PressureMeasurementType;
                    details?: string;
                    time?: ReturnType<typeof Time.prototype.toObject>;
                    pressure?: ReturnType<typeof Pressure.prototype.toObject>;
                } = {};
                if (this.type != null) {
                    data.type = this.type;
                }
                if (this.details != null) {
                    data.details = this.details;
                }
                if (this.time != null) {
                    data.time = this.time.toObject();
                }
                if (this.pressure != null) {
                    data.pressure = this.pressure.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.type != PressureConditions.PressureMeasurement.PressureMeasurementType.UNSPECIFIED)
                    writer.writeEnum(1, this.type);
                if (this.details.length)
                    writer.writeString(2, this.details);
                if (this.has_time)
                    writer.writeMessage(3, this.time, () => this.time.serialize(writer));
                if (this.has_pressure)
                    writer.writeMessage(4, this.pressure, () => this.pressure.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PressureMeasurement {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PressureMeasurement();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.type = reader.readEnum();
                            break;
                        case 2:
                            message.details = reader.readString();
                            break;
                        case 3:
                            reader.readMessage(message.time, () => message.time = Time.deserialize(reader));
                            break;
                        case 4:
                            reader.readMessage(message.pressure, () => message.pressure = Pressure.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): PressureMeasurement {
                return PressureMeasurement.deserialize(bytes);
            }
        }
        export namespace PressureMeasurement {
            export enum PressureMeasurementType {
                UNSPECIFIED = 0,
                CUSTOM = 1,
                PRESSURE_TRANSDUCER = 2
            }
        }
    }
    export class StirringConditions extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            type?: StirringConditions.StirringMethodType;
            details?: string;
            rate?: StirringConditions.StirringRate;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("details" in data && data.details != undefined) {
                    this.details = data.details;
                }
                if ("rate" in data && data.rate != undefined) {
                    this.rate = data.rate;
                }
            }
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 1, StirringConditions.StirringMethodType.UNSPECIFIED) as StirringConditions.StirringMethodType;
        }
        set type(value: StirringConditions.StirringMethodType) {
            pb_1.Message.setField(this, 1, value);
        }
        get details() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set details(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get rate() {
            return pb_1.Message.getWrapperField(this, StirringConditions.StirringRate, 3) as StirringConditions.StirringRate;
        }
        set rate(value: StirringConditions.StirringRate) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_rate() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            type?: StirringConditions.StirringMethodType;
            details?: string;
            rate?: ReturnType<typeof StirringConditions.StirringRate.prototype.toObject>;
        }): StirringConditions {
            const message = new StirringConditions({});
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.details != null) {
                message.details = data.details;
            }
            if (data.rate != null) {
                message.rate = StirringConditions.StirringRate.fromObject(data.rate);
            }
            return message;
        }
        toObject() {
            const data: {
                type?: StirringConditions.StirringMethodType;
                details?: string;
                rate?: ReturnType<typeof StirringConditions.StirringRate.prototype.toObject>;
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.details != null) {
                data.details = this.details;
            }
            if (this.rate != null) {
                data.rate = this.rate.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type != StirringConditions.StirringMethodType.UNSPECIFIED)
                writer.writeEnum(1, this.type);
            if (this.details.length)
                writer.writeString(2, this.details);
            if (this.has_rate)
                writer.writeMessage(3, this.rate, () => this.rate.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StirringConditions {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StirringConditions();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readEnum();
                        break;
                    case 2:
                        message.details = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.rate, () => message.rate = StirringConditions.StirringRate.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StirringConditions {
            return StirringConditions.deserialize(bytes);
        }
    }
    export namespace StirringConditions {
        export enum StirringMethodType {
            UNSPECIFIED = 0,
            CUSTOM = 1,
            NONE = 2,
            STIR_BAR = 3,
            OVERHEAD_MIXER = 4,
            AGITATION = 5,
            BALL_MILLING = 6,
            SONICATION = 7
        }
        export class StirringRate extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                type?: StirringConditions.StirringRate.StirringRateType;
                details?: string;
                rpm?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("type" in data && data.type != undefined) {
                        this.type = data.type;
                    }
                    if ("details" in data && data.details != undefined) {
                        this.details = data.details;
                    }
                    if ("rpm" in data && data.rpm != undefined) {
                        this.rpm = data.rpm;
                    }
                }
            }
            get type() {
                return pb_1.Message.getFieldWithDefault(this, 1, StirringConditions.StirringRate.StirringRateType.UNSPECIFIED) as StirringConditions.StirringRate.StirringRateType;
            }
            set type(value: StirringConditions.StirringRate.StirringRateType) {
                pb_1.Message.setField(this, 1, value);
            }
            get details() {
                return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
            }
            set details(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            get rpm() {
                return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
            }
            set rpm(value: number) {
                pb_1.Message.setField(this, 3, value);
            }
            static fromObject(data: {
                type?: StirringConditions.StirringRate.StirringRateType;
                details?: string;
                rpm?: number;
            }): StirringRate {
                const message = new StirringRate({});
                if (data.type != null) {
                    message.type = data.type;
                }
                if (data.details != null) {
                    message.details = data.details;
                }
                if (data.rpm != null) {
                    message.rpm = data.rpm;
                }
                return message;
            }
            toObject() {
                const data: {
                    type?: StirringConditions.StirringRate.StirringRateType;
                    details?: string;
                    rpm?: number;
                } = {};
                if (this.type != null) {
                    data.type = this.type;
                }
                if (this.details != null) {
                    data.details = this.details;
                }
                if (this.rpm != null) {
                    data.rpm = this.rpm;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.type != StirringConditions.StirringRate.StirringRateType.UNSPECIFIED)
                    writer.writeEnum(1, this.type);
                if (this.details.length)
                    writer.writeString(2, this.details);
                if (this.rpm != 0)
                    writer.writeInt32(3, this.rpm);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StirringRate {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StirringRate();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.type = reader.readEnum();
                            break;
                        case 2:
                            message.details = reader.readString();
                            break;
                        case 3:
                            message.rpm = reader.readInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): StirringRate {
                return StirringRate.deserialize(bytes);
            }
        }
        export namespace StirringRate {
            export enum StirringRateType {
                UNSPECIFIED = 0,
                HIGH = 1,
                MEDIUM = 2,
                LOW = 3
            }
        }
    }
    export class IlluminationConditions extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            type?: IlluminationConditions.IlluminationType;
            details?: string;
            peak_wavelength?: Wavelength;
            color?: string;
            distance_to_vessel?: Length;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("details" in data && data.details != undefined) {
                    this.details = data.details;
                }
                if ("peak_wavelength" in data && data.peak_wavelength != undefined) {
                    this.peak_wavelength = data.peak_wavelength;
                }
                if ("color" in data && data.color != undefined) {
                    this.color = data.color;
                }
                if ("distance_to_vessel" in data && data.distance_to_vessel != undefined) {
                    this.distance_to_vessel = data.distance_to_vessel;
                }
            }
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 1, IlluminationConditions.IlluminationType.UNSPECIFIED) as IlluminationConditions.IlluminationType;
        }
        set type(value: IlluminationConditions.IlluminationType) {
            pb_1.Message.setField(this, 1, value);
        }
        get details() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set details(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get peak_wavelength() {
            return pb_1.Message.getWrapperField(this, Wavelength, 3) as Wavelength;
        }
        set peak_wavelength(value: Wavelength) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_peak_wavelength() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get color() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set color(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get distance_to_vessel() {
            return pb_1.Message.getWrapperField(this, Length, 5) as Length;
        }
        set distance_to_vessel(value: Length) {
            pb_1.Message.setWrapperField(this, 5, value);
        }
        get has_distance_to_vessel() {
            return pb_1.Message.getField(this, 5) != null;
        }
        static fromObject(data: {
            type?: IlluminationConditions.IlluminationType;
            details?: string;
            peak_wavelength?: ReturnType<typeof Wavelength.prototype.toObject>;
            color?: string;
            distance_to_vessel?: ReturnType<typeof Length.prototype.toObject>;
        }): IlluminationConditions {
            const message = new IlluminationConditions({});
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.details != null) {
                message.details = data.details;
            }
            if (data.peak_wavelength != null) {
                message.peak_wavelength = Wavelength.fromObject(data.peak_wavelength);
            }
            if (data.color != null) {
                message.color = data.color;
            }
            if (data.distance_to_vessel != null) {
                message.distance_to_vessel = Length.fromObject(data.distance_to_vessel);
            }
            return message;
        }
        toObject() {
            const data: {
                type?: IlluminationConditions.IlluminationType;
                details?: string;
                peak_wavelength?: ReturnType<typeof Wavelength.prototype.toObject>;
                color?: string;
                distance_to_vessel?: ReturnType<typeof Length.prototype.toObject>;
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.details != null) {
                data.details = this.details;
            }
            if (this.peak_wavelength != null) {
                data.peak_wavelength = this.peak_wavelength.toObject();
            }
            if (this.color != null) {
                data.color = this.color;
            }
            if (this.distance_to_vessel != null) {
                data.distance_to_vessel = this.distance_to_vessel.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type != IlluminationConditions.IlluminationType.UNSPECIFIED)
                writer.writeEnum(1, this.type);
            if (this.details.length)
                writer.writeString(2, this.details);
            if (this.has_peak_wavelength)
                writer.writeMessage(3, this.peak_wavelength, () => this.peak_wavelength.serialize(writer));
            if (this.color.length)
                writer.writeString(4, this.color);
            if (this.has_distance_to_vessel)
                writer.writeMessage(5, this.distance_to_vessel, () => this.distance_to_vessel.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IlluminationConditions {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IlluminationConditions();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readEnum();
                        break;
                    case 2:
                        message.details = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.peak_wavelength, () => message.peak_wavelength = Wavelength.deserialize(reader));
                        break;
                    case 4:
                        message.color = reader.readString();
                        break;
                    case 5:
                        reader.readMessage(message.distance_to_vessel, () => message.distance_to_vessel = Length.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): IlluminationConditions {
            return IlluminationConditions.deserialize(bytes);
        }
    }
    export namespace IlluminationConditions {
        export enum IlluminationType {
            UNSPECIFIED = 0,
            CUSTOM = 1,
            AMBIENT = 2,
            DARK = 3,
            LED = 4,
            HALOGEN_LAMP = 5,
            DEUTERIUM_LAMP = 6,
            SOLAR_SIMULATOR = 7,
            BROAD_SPECTRUM = 8
        }
    }
    export class ElectrochemistryConditions extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            type?: ElectrochemistryConditions.ElectrochemistryType;
            details?: string;
            current?: Current;
            voltage?: Voltage;
            anode_material?: string;
            cathode_material?: string;
            electrode_separation?: Length;
            measurements?: ElectrochemistryConditions.ElectrochemistryMeasurement[];
            cell?: ElectrochemistryConditions.ElectrochemistryCell;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [8], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("details" in data && data.details != undefined) {
                    this.details = data.details;
                }
                if ("current" in data && data.current != undefined) {
                    this.current = data.current;
                }
                if ("voltage" in data && data.voltage != undefined) {
                    this.voltage = data.voltage;
                }
                if ("anode_material" in data && data.anode_material != undefined) {
                    this.anode_material = data.anode_material;
                }
                if ("cathode_material" in data && data.cathode_material != undefined) {
                    this.cathode_material = data.cathode_material;
                }
                if ("electrode_separation" in data && data.electrode_separation != undefined) {
                    this.electrode_separation = data.electrode_separation;
                }
                if ("measurements" in data && data.measurements != undefined) {
                    this.measurements = data.measurements;
                }
                if ("cell" in data && data.cell != undefined) {
                    this.cell = data.cell;
                }
            }
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 1, ElectrochemistryConditions.ElectrochemistryType.UNSPECIFIED) as ElectrochemistryConditions.ElectrochemistryType;
        }
        set type(value: ElectrochemistryConditions.ElectrochemistryType) {
            pb_1.Message.setField(this, 1, value);
        }
        get details() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set details(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get current() {
            return pb_1.Message.getWrapperField(this, Current, 3) as Current;
        }
        set current(value: Current) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_current() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get voltage() {
            return pb_1.Message.getWrapperField(this, Voltage, 4) as Voltage;
        }
        set voltage(value: Voltage) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get has_voltage() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get anode_material() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        set anode_material(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get cathode_material() {
            return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
        }
        set cathode_material(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        get electrode_separation() {
            return pb_1.Message.getWrapperField(this, Length, 7) as Length;
        }
        set electrode_separation(value: Length) {
            pb_1.Message.setWrapperField(this, 7, value);
        }
        get has_electrode_separation() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get measurements() {
            return pb_1.Message.getRepeatedWrapperField(this, ElectrochemistryConditions.ElectrochemistryMeasurement, 8) as ElectrochemistryConditions.ElectrochemistryMeasurement[];
        }
        set measurements(value: ElectrochemistryConditions.ElectrochemistryMeasurement[]) {
            pb_1.Message.setRepeatedWrapperField(this, 8, value);
        }
        get cell() {
            return pb_1.Message.getWrapperField(this, ElectrochemistryConditions.ElectrochemistryCell, 9) as ElectrochemistryConditions.ElectrochemistryCell;
        }
        set cell(value: ElectrochemistryConditions.ElectrochemistryCell) {
            pb_1.Message.setWrapperField(this, 9, value);
        }
        get has_cell() {
            return pb_1.Message.getField(this, 9) != null;
        }
        static fromObject(data: {
            type?: ElectrochemistryConditions.ElectrochemistryType;
            details?: string;
            current?: ReturnType<typeof Current.prototype.toObject>;
            voltage?: ReturnType<typeof Voltage.prototype.toObject>;
            anode_material?: string;
            cathode_material?: string;
            electrode_separation?: ReturnType<typeof Length.prototype.toObject>;
            measurements?: ReturnType<typeof ElectrochemistryConditions.ElectrochemistryMeasurement.prototype.toObject>[];
            cell?: ReturnType<typeof ElectrochemistryConditions.ElectrochemistryCell.prototype.toObject>;
        }): ElectrochemistryConditions {
            const message = new ElectrochemistryConditions({});
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.details != null) {
                message.details = data.details;
            }
            if (data.current != null) {
                message.current = Current.fromObject(data.current);
            }
            if (data.voltage != null) {
                message.voltage = Voltage.fromObject(data.voltage);
            }
            if (data.anode_material != null) {
                message.anode_material = data.anode_material;
            }
            if (data.cathode_material != null) {
                message.cathode_material = data.cathode_material;
            }
            if (data.electrode_separation != null) {
                message.electrode_separation = Length.fromObject(data.electrode_separation);
            }
            if (data.measurements != null) {
                message.measurements = data.measurements.map(item => ElectrochemistryConditions.ElectrochemistryMeasurement.fromObject(item));
            }
            if (data.cell != null) {
                message.cell = ElectrochemistryConditions.ElectrochemistryCell.fromObject(data.cell);
            }
            return message;
        }
        toObject() {
            const data: {
                type?: ElectrochemistryConditions.ElectrochemistryType;
                details?: string;
                current?: ReturnType<typeof Current.prototype.toObject>;
                voltage?: ReturnType<typeof Voltage.prototype.toObject>;
                anode_material?: string;
                cathode_material?: string;
                electrode_separation?: ReturnType<typeof Length.prototype.toObject>;
                measurements?: ReturnType<typeof ElectrochemistryConditions.ElectrochemistryMeasurement.prototype.toObject>[];
                cell?: ReturnType<typeof ElectrochemistryConditions.ElectrochemistryCell.prototype.toObject>;
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.details != null) {
                data.details = this.details;
            }
            if (this.current != null) {
                data.current = this.current.toObject();
            }
            if (this.voltage != null) {
                data.voltage = this.voltage.toObject();
            }
            if (this.anode_material != null) {
                data.anode_material = this.anode_material;
            }
            if (this.cathode_material != null) {
                data.cathode_material = this.cathode_material;
            }
            if (this.electrode_separation != null) {
                data.electrode_separation = this.electrode_separation.toObject();
            }
            if (this.measurements != null) {
                data.measurements = this.measurements.map((item: ElectrochemistryConditions.ElectrochemistryMeasurement) => item.toObject());
            }
            if (this.cell != null) {
                data.cell = this.cell.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type != ElectrochemistryConditions.ElectrochemistryType.UNSPECIFIED)
                writer.writeEnum(1, this.type);
            if (this.details.length)
                writer.writeString(2, this.details);
            if (this.has_current)
                writer.writeMessage(3, this.current, () => this.current.serialize(writer));
            if (this.has_voltage)
                writer.writeMessage(4, this.voltage, () => this.voltage.serialize(writer));
            if (this.anode_material.length)
                writer.writeString(5, this.anode_material);
            if (this.cathode_material.length)
                writer.writeString(6, this.cathode_material);
            if (this.has_electrode_separation)
                writer.writeMessage(7, this.electrode_separation, () => this.electrode_separation.serialize(writer));
            if (this.measurements.length)
                writer.writeRepeatedMessage(8, this.measurements, (item: ElectrochemistryConditions.ElectrochemistryMeasurement) => item.serialize(writer));
            if (this.has_cell)
                writer.writeMessage(9, this.cell, () => this.cell.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ElectrochemistryConditions {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ElectrochemistryConditions();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readEnum();
                        break;
                    case 2:
                        message.details = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.current, () => message.current = Current.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.voltage, () => message.voltage = Voltage.deserialize(reader));
                        break;
                    case 5:
                        message.anode_material = reader.readString();
                        break;
                    case 6:
                        message.cathode_material = reader.readString();
                        break;
                    case 7:
                        reader.readMessage(message.electrode_separation, () => message.electrode_separation = Length.deserialize(reader));
                        break;
                    case 8:
                        reader.readMessage(message.measurements, () => pb_1.Message.addToRepeatedWrapperField(message, 8, ElectrochemistryConditions.ElectrochemistryMeasurement.deserialize(reader), ElectrochemistryConditions.ElectrochemistryMeasurement));
                        break;
                    case 9:
                        reader.readMessage(message.cell, () => message.cell = ElectrochemistryConditions.ElectrochemistryCell.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ElectrochemistryConditions {
            return ElectrochemistryConditions.deserialize(bytes);
        }
    }
    export namespace ElectrochemistryConditions {
        export enum ElectrochemistryType {
            UNSPECIFIED = 0,
            CUSTOM = 1,
            CONSTANT_CURRENT = 2,
            CONSTANT_VOLTAGE = 3
        }
        export class ElectrochemistryMeasurement extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                time?: Time;
                current?: Current;
                voltage?: Voltage;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("time" in data && data.time != undefined) {
                        this.time = data.time;
                    }
                    if ("current" in data && data.current != undefined) {
                        this.current = data.current;
                    }
                    if ("voltage" in data && data.voltage != undefined) {
                        this.voltage = data.voltage;
                    }
                }
            }
            get time() {
                return pb_1.Message.getWrapperField(this, Time, 1) as Time;
            }
            set time(value: Time) {
                pb_1.Message.setWrapperField(this, 1, value);
            }
            get has_time() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get current() {
                return pb_1.Message.getWrapperField(this, Current, 2) as Current;
            }
            set current(value: Current) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get has_current() {
                return pb_1.Message.getField(this, 2) != null;
            }
            get voltage() {
                return pb_1.Message.getWrapperField(this, Voltage, 3) as Voltage;
            }
            set voltage(value: Voltage) {
                pb_1.Message.setWrapperField(this, 3, value);
            }
            get has_voltage() {
                return pb_1.Message.getField(this, 3) != null;
            }
            static fromObject(data: {
                time?: ReturnType<typeof Time.prototype.toObject>;
                current?: ReturnType<typeof Current.prototype.toObject>;
                voltage?: ReturnType<typeof Voltage.prototype.toObject>;
            }): ElectrochemistryMeasurement {
                const message = new ElectrochemistryMeasurement({});
                if (data.time != null) {
                    message.time = Time.fromObject(data.time);
                }
                if (data.current != null) {
                    message.current = Current.fromObject(data.current);
                }
                if (data.voltage != null) {
                    message.voltage = Voltage.fromObject(data.voltage);
                }
                return message;
            }
            toObject() {
                const data: {
                    time?: ReturnType<typeof Time.prototype.toObject>;
                    current?: ReturnType<typeof Current.prototype.toObject>;
                    voltage?: ReturnType<typeof Voltage.prototype.toObject>;
                } = {};
                if (this.time != null) {
                    data.time = this.time.toObject();
                }
                if (this.current != null) {
                    data.current = this.current.toObject();
                }
                if (this.voltage != null) {
                    data.voltage = this.voltage.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_time)
                    writer.writeMessage(1, this.time, () => this.time.serialize(writer));
                if (this.has_current)
                    writer.writeMessage(2, this.current, () => this.current.serialize(writer));
                if (this.has_voltage)
                    writer.writeMessage(3, this.voltage, () => this.voltage.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ElectrochemistryMeasurement {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ElectrochemistryMeasurement();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.time, () => message.time = Time.deserialize(reader));
                            break;
                        case 2:
                            reader.readMessage(message.current, () => message.current = Current.deserialize(reader));
                            break;
                        case 3:
                            reader.readMessage(message.voltage, () => message.voltage = Voltage.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): ElectrochemistryMeasurement {
                return ElectrochemistryMeasurement.deserialize(bytes);
            }
        }
        export class ElectrochemistryCell extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                type?: ElectrochemistryConditions.ElectrochemistryCell.ElectrochemistryCellType;
                details?: string;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("type" in data && data.type != undefined) {
                        this.type = data.type;
                    }
                    if ("details" in data && data.details != undefined) {
                        this.details = data.details;
                    }
                }
            }
            get type() {
                return pb_1.Message.getFieldWithDefault(this, 1, ElectrochemistryConditions.ElectrochemistryCell.ElectrochemistryCellType.UNSPECIFIED) as ElectrochemistryConditions.ElectrochemistryCell.ElectrochemistryCellType;
            }
            set type(value: ElectrochemistryConditions.ElectrochemistryCell.ElectrochemistryCellType) {
                pb_1.Message.setField(this, 1, value);
            }
            get details() {
                return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
            }
            set details(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            static fromObject(data: {
                type?: ElectrochemistryConditions.ElectrochemistryCell.ElectrochemistryCellType;
                details?: string;
            }): ElectrochemistryCell {
                const message = new ElectrochemistryCell({});
                if (data.type != null) {
                    message.type = data.type;
                }
                if (data.details != null) {
                    message.details = data.details;
                }
                return message;
            }
            toObject() {
                const data: {
                    type?: ElectrochemistryConditions.ElectrochemistryCell.ElectrochemistryCellType;
                    details?: string;
                } = {};
                if (this.type != null) {
                    data.type = this.type;
                }
                if (this.details != null) {
                    data.details = this.details;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.type != ElectrochemistryConditions.ElectrochemistryCell.ElectrochemistryCellType.UNSPECIFIED)
                    writer.writeEnum(1, this.type);
                if (this.details.length)
                    writer.writeString(2, this.details);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ElectrochemistryCell {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ElectrochemistryCell();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.type = reader.readEnum();
                            break;
                        case 2:
                            message.details = reader.readString();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): ElectrochemistryCell {
                return ElectrochemistryCell.deserialize(bytes);
            }
        }
        export namespace ElectrochemistryCell {
            export enum ElectrochemistryCellType {
                UNSPECIFIED = 0,
                CUSTOM = 1,
                DIVIDED_CELL = 2,
                UNDIVIDED_CELL = 3
            }
        }
    }
    export class FlowConditions extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            type?: FlowConditions.FlowType;
            details?: string;
            pump_type?: string;
            tubing?: FlowConditions.Tubing;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("details" in data && data.details != undefined) {
                    this.details = data.details;
                }
                if ("pump_type" in data && data.pump_type != undefined) {
                    this.pump_type = data.pump_type;
                }
                if ("tubing" in data && data.tubing != undefined) {
                    this.tubing = data.tubing;
                }
            }
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 1, FlowConditions.FlowType.UNSPECIFIED) as FlowConditions.FlowType;
        }
        set type(value: FlowConditions.FlowType) {
            pb_1.Message.setField(this, 1, value);
        }
        get details() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set details(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get pump_type() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set pump_type(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get tubing() {
            return pb_1.Message.getWrapperField(this, FlowConditions.Tubing, 4) as FlowConditions.Tubing;
        }
        set tubing(value: FlowConditions.Tubing) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get has_tubing() {
            return pb_1.Message.getField(this, 4) != null;
        }
        static fromObject(data: {
            type?: FlowConditions.FlowType;
            details?: string;
            pump_type?: string;
            tubing?: ReturnType<typeof FlowConditions.Tubing.prototype.toObject>;
        }): FlowConditions {
            const message = new FlowConditions({});
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.details != null) {
                message.details = data.details;
            }
            if (data.pump_type != null) {
                message.pump_type = data.pump_type;
            }
            if (data.tubing != null) {
                message.tubing = FlowConditions.Tubing.fromObject(data.tubing);
            }
            return message;
        }
        toObject() {
            const data: {
                type?: FlowConditions.FlowType;
                details?: string;
                pump_type?: string;
                tubing?: ReturnType<typeof FlowConditions.Tubing.prototype.toObject>;
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.details != null) {
                data.details = this.details;
            }
            if (this.pump_type != null) {
                data.pump_type = this.pump_type;
            }
            if (this.tubing != null) {
                data.tubing = this.tubing.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type != FlowConditions.FlowType.UNSPECIFIED)
                writer.writeEnum(1, this.type);
            if (this.details.length)
                writer.writeString(2, this.details);
            if (this.pump_type.length)
                writer.writeString(3, this.pump_type);
            if (this.has_tubing)
                writer.writeMessage(4, this.tubing, () => this.tubing.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FlowConditions {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FlowConditions();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readEnum();
                        break;
                    case 2:
                        message.details = reader.readString();
                        break;
                    case 3:
                        message.pump_type = reader.readString();
                        break;
                    case 4:
                        reader.readMessage(message.tubing, () => message.tubing = FlowConditions.Tubing.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FlowConditions {
            return FlowConditions.deserialize(bytes);
        }
    }
    export namespace FlowConditions {
        export enum FlowType {
            UNSPECIFIED = 0,
            CUSTOM = 1,
            PLUG_FLOW_REACTOR = 2,
            CONTINUOUS_STIRRED_TANK_REACTOR = 3,
            PACKED_BED_REACTOR = 4
        }
        export class Tubing extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                type?: FlowConditions.Tubing.TubingType;
                details?: string;
                diameter?: Length;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("type" in data && data.type != undefined) {
                        this.type = data.type;
                    }
                    if ("details" in data && data.details != undefined) {
                        this.details = data.details;
                    }
                    if ("diameter" in data && data.diameter != undefined) {
                        this.diameter = data.diameter;
                    }
                }
            }
            get type() {
                return pb_1.Message.getFieldWithDefault(this, 1, FlowConditions.Tubing.TubingType.UNSPECIFIED) as FlowConditions.Tubing.TubingType;
            }
            set type(value: FlowConditions.Tubing.TubingType) {
                pb_1.Message.setField(this, 1, value);
            }
            get details() {
                return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
            }
            set details(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            get diameter() {
                return pb_1.Message.getWrapperField(this, Length, 3) as Length;
            }
            set diameter(value: Length) {
                pb_1.Message.setWrapperField(this, 3, value);
            }
            get has_diameter() {
                return pb_1.Message.getField(this, 3) != null;
            }
            static fromObject(data: {
                type?: FlowConditions.Tubing.TubingType;
                details?: string;
                diameter?: ReturnType<typeof Length.prototype.toObject>;
            }): Tubing {
                const message = new Tubing({});
                if (data.type != null) {
                    message.type = data.type;
                }
                if (data.details != null) {
                    message.details = data.details;
                }
                if (data.diameter != null) {
                    message.diameter = Length.fromObject(data.diameter);
                }
                return message;
            }
            toObject() {
                const data: {
                    type?: FlowConditions.Tubing.TubingType;
                    details?: string;
                    diameter?: ReturnType<typeof Length.prototype.toObject>;
                } = {};
                if (this.type != null) {
                    data.type = this.type;
                }
                if (this.details != null) {
                    data.details = this.details;
                }
                if (this.diameter != null) {
                    data.diameter = this.diameter.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.type != FlowConditions.Tubing.TubingType.UNSPECIFIED)
                    writer.writeEnum(1, this.type);
                if (this.details.length)
                    writer.writeString(2, this.details);
                if (this.has_diameter)
                    writer.writeMessage(3, this.diameter, () => this.diameter.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Tubing {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Tubing();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.type = reader.readEnum();
                            break;
                        case 2:
                            message.details = reader.readString();
                            break;
                        case 3:
                            reader.readMessage(message.diameter, () => message.diameter = Length.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Tubing {
                return Tubing.deserialize(bytes);
            }
        }
        export namespace Tubing {
            export enum TubingType {
                UNSPECIFIED = 0,
                CUSTOM = 1,
                STEEL = 2,
                COPPER = 3,
                PFA = 4,
                FEP = 5,
                TEFLONAF = 6,
                PTFE = 7,
                GLASS = 8,
                QUARTZ = 9,
                SILICON = 10,
                PDMS = 11
            }
        }
    }
    export class ReactionNotes extends pb_1.Message {
        #one_of_decls: number[][] = [[1], [2], [3], [4], [5], [6], [7]];
        constructor(data?: any[] | ({
            safety_notes?: string;
            procedure_details?: string;
        } & (({
            is_heterogeneous?: boolean;
        }) | ({
            forms_precipitate?: boolean;
        }) | ({
            is_exothermic?: boolean;
        }) | ({
            offgasses?: boolean;
        }) | ({
            is_sensitive_to_moisture?: boolean;
        }) | ({
            is_sensitive_to_oxygen?: boolean;
        }) | ({
            is_sensitive_to_light?: boolean;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("is_heterogeneous" in data && data.is_heterogeneous != undefined) {
                    this.is_heterogeneous = data.is_heterogeneous;
                }
                if ("forms_precipitate" in data && data.forms_precipitate != undefined) {
                    this.forms_precipitate = data.forms_precipitate;
                }
                if ("is_exothermic" in data && data.is_exothermic != undefined) {
                    this.is_exothermic = data.is_exothermic;
                }
                if ("offgasses" in data && data.offgasses != undefined) {
                    this.offgasses = data.offgasses;
                }
                if ("is_sensitive_to_moisture" in data && data.is_sensitive_to_moisture != undefined) {
                    this.is_sensitive_to_moisture = data.is_sensitive_to_moisture;
                }
                if ("is_sensitive_to_oxygen" in data && data.is_sensitive_to_oxygen != undefined) {
                    this.is_sensitive_to_oxygen = data.is_sensitive_to_oxygen;
                }
                if ("is_sensitive_to_light" in data && data.is_sensitive_to_light != undefined) {
                    this.is_sensitive_to_light = data.is_sensitive_to_light;
                }
                if ("safety_notes" in data && data.safety_notes != undefined) {
                    this.safety_notes = data.safety_notes;
                }
                if ("procedure_details" in data && data.procedure_details != undefined) {
                    this.procedure_details = data.procedure_details;
                }
            }
        }
        get is_heterogeneous() {
            return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
        }
        set is_heterogeneous(value: boolean) {
            pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
        }
        get has_is_heterogeneous() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get forms_precipitate() {
            return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
        }
        set forms_precipitate(value: boolean) {
            pb_1.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
        }
        get has_forms_precipitate() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get is_exothermic() {
            return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
        }
        set is_exothermic(value: boolean) {
            pb_1.Message.setOneofField(this, 3, this.#one_of_decls[2], value);
        }
        get has_is_exothermic() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get offgasses() {
            return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
        }
        set offgasses(value: boolean) {
            pb_1.Message.setOneofField(this, 4, this.#one_of_decls[3], value);
        }
        get has_offgasses() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get is_sensitive_to_moisture() {
            return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
        }
        set is_sensitive_to_moisture(value: boolean) {
            pb_1.Message.setOneofField(this, 5, this.#one_of_decls[4], value);
        }
        get has_is_sensitive_to_moisture() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get is_sensitive_to_oxygen() {
            return pb_1.Message.getFieldWithDefault(this, 6, false) as boolean;
        }
        set is_sensitive_to_oxygen(value: boolean) {
            pb_1.Message.setOneofField(this, 6, this.#one_of_decls[5], value);
        }
        get has_is_sensitive_to_oxygen() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get is_sensitive_to_light() {
            return pb_1.Message.getFieldWithDefault(this, 7, false) as boolean;
        }
        set is_sensitive_to_light(value: boolean) {
            pb_1.Message.setOneofField(this, 7, this.#one_of_decls[6], value);
        }
        get has_is_sensitive_to_light() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get safety_notes() {
            return pb_1.Message.getFieldWithDefault(this, 8, "") as string;
        }
        set safety_notes(value: string) {
            pb_1.Message.setField(this, 8, value);
        }
        get procedure_details() {
            return pb_1.Message.getFieldWithDefault(this, 9, "") as string;
        }
        set procedure_details(value: string) {
            pb_1.Message.setField(this, 9, value);
        }
        get _is_heterogeneous() {
            const cases: {
                [index: number]: "none" | "is_heterogeneous";
            } = {
                0: "none",
                1: "is_heterogeneous"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        get _forms_precipitate() {
            const cases: {
                [index: number]: "none" | "forms_precipitate";
            } = {
                0: "none",
                2: "forms_precipitate"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        get _is_exothermic() {
            const cases: {
                [index: number]: "none" | "is_exothermic";
            } = {
                0: "none",
                3: "is_exothermic"
            };
            return cases[pb_1.Message.computeOneofCase(this, [3])];
        }
        get _offgasses() {
            const cases: {
                [index: number]: "none" | "offgasses";
            } = {
                0: "none",
                4: "offgasses"
            };
            return cases[pb_1.Message.computeOneofCase(this, [4])];
        }
        get _is_sensitive_to_moisture() {
            const cases: {
                [index: number]: "none" | "is_sensitive_to_moisture";
            } = {
                0: "none",
                5: "is_sensitive_to_moisture"
            };
            return cases[pb_1.Message.computeOneofCase(this, [5])];
        }
        get _is_sensitive_to_oxygen() {
            const cases: {
                [index: number]: "none" | "is_sensitive_to_oxygen";
            } = {
                0: "none",
                6: "is_sensitive_to_oxygen"
            };
            return cases[pb_1.Message.computeOneofCase(this, [6])];
        }
        get _is_sensitive_to_light() {
            const cases: {
                [index: number]: "none" | "is_sensitive_to_light";
            } = {
                0: "none",
                7: "is_sensitive_to_light"
            };
            return cases[pb_1.Message.computeOneofCase(this, [7])];
        }
        static fromObject(data: {
            is_heterogeneous?: boolean;
            forms_precipitate?: boolean;
            is_exothermic?: boolean;
            offgasses?: boolean;
            is_sensitive_to_moisture?: boolean;
            is_sensitive_to_oxygen?: boolean;
            is_sensitive_to_light?: boolean;
            safety_notes?: string;
            procedure_details?: string;
        }): ReactionNotes {
            const message = new ReactionNotes({});
            if (data.is_heterogeneous != null) {
                message.is_heterogeneous = data.is_heterogeneous;
            }
            if (data.forms_precipitate != null) {
                message.forms_precipitate = data.forms_precipitate;
            }
            if (data.is_exothermic != null) {
                message.is_exothermic = data.is_exothermic;
            }
            if (data.offgasses != null) {
                message.offgasses = data.offgasses;
            }
            if (data.is_sensitive_to_moisture != null) {
                message.is_sensitive_to_moisture = data.is_sensitive_to_moisture;
            }
            if (data.is_sensitive_to_oxygen != null) {
                message.is_sensitive_to_oxygen = data.is_sensitive_to_oxygen;
            }
            if (data.is_sensitive_to_light != null) {
                message.is_sensitive_to_light = data.is_sensitive_to_light;
            }
            if (data.safety_notes != null) {
                message.safety_notes = data.safety_notes;
            }
            if (data.procedure_details != null) {
                message.procedure_details = data.procedure_details;
            }
            return message;
        }
        toObject() {
            const data: {
                is_heterogeneous?: boolean;
                forms_precipitate?: boolean;
                is_exothermic?: boolean;
                offgasses?: boolean;
                is_sensitive_to_moisture?: boolean;
                is_sensitive_to_oxygen?: boolean;
                is_sensitive_to_light?: boolean;
                safety_notes?: string;
                procedure_details?: string;
            } = {};
            if (this.is_heterogeneous != null) {
                data.is_heterogeneous = this.is_heterogeneous;
            }
            if (this.forms_precipitate != null) {
                data.forms_precipitate = this.forms_precipitate;
            }
            if (this.is_exothermic != null) {
                data.is_exothermic = this.is_exothermic;
            }
            if (this.offgasses != null) {
                data.offgasses = this.offgasses;
            }
            if (this.is_sensitive_to_moisture != null) {
                data.is_sensitive_to_moisture = this.is_sensitive_to_moisture;
            }
            if (this.is_sensitive_to_oxygen != null) {
                data.is_sensitive_to_oxygen = this.is_sensitive_to_oxygen;
            }
            if (this.is_sensitive_to_light != null) {
                data.is_sensitive_to_light = this.is_sensitive_to_light;
            }
            if (this.safety_notes != null) {
                data.safety_notes = this.safety_notes;
            }
            if (this.procedure_details != null) {
                data.procedure_details = this.procedure_details;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_is_heterogeneous)
                writer.writeBool(1, this.is_heterogeneous);
            if (this.has_forms_precipitate)
                writer.writeBool(2, this.forms_precipitate);
            if (this.has_is_exothermic)
                writer.writeBool(3, this.is_exothermic);
            if (this.has_offgasses)
                writer.writeBool(4, this.offgasses);
            if (this.has_is_sensitive_to_moisture)
                writer.writeBool(5, this.is_sensitive_to_moisture);
            if (this.has_is_sensitive_to_oxygen)
                writer.writeBool(6, this.is_sensitive_to_oxygen);
            if (this.has_is_sensitive_to_light)
                writer.writeBool(7, this.is_sensitive_to_light);
            if (this.safety_notes.length)
                writer.writeString(8, this.safety_notes);
            if (this.procedure_details.length)
                writer.writeString(9, this.procedure_details);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ReactionNotes {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ReactionNotes();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.is_heterogeneous = reader.readBool();
                        break;
                    case 2:
                        message.forms_precipitate = reader.readBool();
                        break;
                    case 3:
                        message.is_exothermic = reader.readBool();
                        break;
                    case 4:
                        message.offgasses = reader.readBool();
                        break;
                    case 5:
                        message.is_sensitive_to_moisture = reader.readBool();
                        break;
                    case 6:
                        message.is_sensitive_to_oxygen = reader.readBool();
                        break;
                    case 7:
                        message.is_sensitive_to_light = reader.readBool();
                        break;
                    case 8:
                        message.safety_notes = reader.readString();
                        break;
                    case 9:
                        message.procedure_details = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ReactionNotes {
            return ReactionNotes.deserialize(bytes);
        }
    }
    export class ReactionObservation extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            time?: Time;
            comment?: string;
            image?: Data;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("time" in data && data.time != undefined) {
                    this.time = data.time;
                }
                if ("comment" in data && data.comment != undefined) {
                    this.comment = data.comment;
                }
                if ("image" in data && data.image != undefined) {
                    this.image = data.image;
                }
            }
        }
        get time() {
            return pb_1.Message.getWrapperField(this, Time, 1) as Time;
        }
        set time(value: Time) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_time() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get comment() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set comment(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get image() {
            return pb_1.Message.getWrapperField(this, Data, 3) as Data;
        }
        set image(value: Data) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_image() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            time?: ReturnType<typeof Time.prototype.toObject>;
            comment?: string;
            image?: ReturnType<typeof Data.prototype.toObject>;
        }): ReactionObservation {
            const message = new ReactionObservation({});
            if (data.time != null) {
                message.time = Time.fromObject(data.time);
            }
            if (data.comment != null) {
                message.comment = data.comment;
            }
            if (data.image != null) {
                message.image = Data.fromObject(data.image);
            }
            return message;
        }
        toObject() {
            const data: {
                time?: ReturnType<typeof Time.prototype.toObject>;
                comment?: string;
                image?: ReturnType<typeof Data.prototype.toObject>;
            } = {};
            if (this.time != null) {
                data.time = this.time.toObject();
            }
            if (this.comment != null) {
                data.comment = this.comment;
            }
            if (this.image != null) {
                data.image = this.image.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_time)
                writer.writeMessage(1, this.time, () => this.time.serialize(writer));
            if (this.comment.length)
                writer.writeString(2, this.comment);
            if (this.has_image)
                writer.writeMessage(3, this.image, () => this.image.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ReactionObservation {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ReactionObservation();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.time, () => message.time = Time.deserialize(reader));
                        break;
                    case 2:
                        message.comment = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.image, () => message.image = Data.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ReactionObservation {
            return ReactionObservation.deserialize(bytes);
        }
    }
    export class ReactionWorkup extends pb_1.Message {
        #one_of_decls: number[][] = [[9], [10]];
        constructor(data?: any[] | ({
            type?: ReactionWorkup.ReactionWorkupType;
            details?: string;
            duration?: Time;
            input?: ReactionInput;
            amount?: Amount;
            temperature?: TemperatureConditions;
            keep_phase?: string;
            stirring?: StirringConditions;
        } & (({
            target_ph?: number;
        }) | ({
            is_automated?: boolean;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("details" in data && data.details != undefined) {
                    this.details = data.details;
                }
                if ("duration" in data && data.duration != undefined) {
                    this.duration = data.duration;
                }
                if ("input" in data && data.input != undefined) {
                    this.input = data.input;
                }
                if ("amount" in data && data.amount != undefined) {
                    this.amount = data.amount;
                }
                if ("temperature" in data && data.temperature != undefined) {
                    this.temperature = data.temperature;
                }
                if ("keep_phase" in data && data.keep_phase != undefined) {
                    this.keep_phase = data.keep_phase;
                }
                if ("stirring" in data && data.stirring != undefined) {
                    this.stirring = data.stirring;
                }
                if ("target_ph" in data && data.target_ph != undefined) {
                    this.target_ph = data.target_ph;
                }
                if ("is_automated" in data && data.is_automated != undefined) {
                    this.is_automated = data.is_automated;
                }
            }
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 1, ReactionWorkup.ReactionWorkupType.UNSPECIFIED) as ReactionWorkup.ReactionWorkupType;
        }
        set type(value: ReactionWorkup.ReactionWorkupType) {
            pb_1.Message.setField(this, 1, value);
        }
        get details() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set details(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get duration() {
            return pb_1.Message.getWrapperField(this, Time, 3) as Time;
        }
        set duration(value: Time) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_duration() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get input() {
            return pb_1.Message.getWrapperField(this, ReactionInput, 4) as ReactionInput;
        }
        set input(value: ReactionInput) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get has_input() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get amount() {
            return pb_1.Message.getWrapperField(this, Amount, 5) as Amount;
        }
        set amount(value: Amount) {
            pb_1.Message.setWrapperField(this, 5, value);
        }
        get has_amount() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get temperature() {
            return pb_1.Message.getWrapperField(this, TemperatureConditions, 6) as TemperatureConditions;
        }
        set temperature(value: TemperatureConditions) {
            pb_1.Message.setWrapperField(this, 6, value);
        }
        get has_temperature() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get keep_phase() {
            return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
        }
        set keep_phase(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        get stirring() {
            return pb_1.Message.getWrapperField(this, StirringConditions, 8) as StirringConditions;
        }
        set stirring(value: StirringConditions) {
            pb_1.Message.setWrapperField(this, 8, value);
        }
        get has_stirring() {
            return pb_1.Message.getField(this, 8) != null;
        }
        get target_ph() {
            return pb_1.Message.getFieldWithDefault(this, 9, 0) as number;
        }
        set target_ph(value: number) {
            pb_1.Message.setOneofField(this, 9, this.#one_of_decls[0], value);
        }
        get has_target_ph() {
            return pb_1.Message.getField(this, 9) != null;
        }
        get is_automated() {
            return pb_1.Message.getFieldWithDefault(this, 10, false) as boolean;
        }
        set is_automated(value: boolean) {
            pb_1.Message.setOneofField(this, 10, this.#one_of_decls[1], value);
        }
        get has_is_automated() {
            return pb_1.Message.getField(this, 10) != null;
        }
        get _target_ph() {
            const cases: {
                [index: number]: "none" | "target_ph";
            } = {
                0: "none",
                9: "target_ph"
            };
            return cases[pb_1.Message.computeOneofCase(this, [9])];
        }
        get _is_automated() {
            const cases: {
                [index: number]: "none" | "is_automated";
            } = {
                0: "none",
                10: "is_automated"
            };
            return cases[pb_1.Message.computeOneofCase(this, [10])];
        }
        static fromObject(data: {
            type?: ReactionWorkup.ReactionWorkupType;
            details?: string;
            duration?: ReturnType<typeof Time.prototype.toObject>;
            input?: ReturnType<typeof ReactionInput.prototype.toObject>;
            amount?: ReturnType<typeof Amount.prototype.toObject>;
            temperature?: ReturnType<typeof TemperatureConditions.prototype.toObject>;
            keep_phase?: string;
            stirring?: ReturnType<typeof StirringConditions.prototype.toObject>;
            target_ph?: number;
            is_automated?: boolean;
        }): ReactionWorkup {
            const message = new ReactionWorkup({});
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.details != null) {
                message.details = data.details;
            }
            if (data.duration != null) {
                message.duration = Time.fromObject(data.duration);
            }
            if (data.input != null) {
                message.input = ReactionInput.fromObject(data.input);
            }
            if (data.amount != null) {
                message.amount = Amount.fromObject(data.amount);
            }
            if (data.temperature != null) {
                message.temperature = TemperatureConditions.fromObject(data.temperature);
            }
            if (data.keep_phase != null) {
                message.keep_phase = data.keep_phase;
            }
            if (data.stirring != null) {
                message.stirring = StirringConditions.fromObject(data.stirring);
            }
            if (data.target_ph != null) {
                message.target_ph = data.target_ph;
            }
            if (data.is_automated != null) {
                message.is_automated = data.is_automated;
            }
            return message;
        }
        toObject() {
            const data: {
                type?: ReactionWorkup.ReactionWorkupType;
                details?: string;
                duration?: ReturnType<typeof Time.prototype.toObject>;
                input?: ReturnType<typeof ReactionInput.prototype.toObject>;
                amount?: ReturnType<typeof Amount.prototype.toObject>;
                temperature?: ReturnType<typeof TemperatureConditions.prototype.toObject>;
                keep_phase?: string;
                stirring?: ReturnType<typeof StirringConditions.prototype.toObject>;
                target_ph?: number;
                is_automated?: boolean;
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.details != null) {
                data.details = this.details;
            }
            if (this.duration != null) {
                data.duration = this.duration.toObject();
            }
            if (this.input != null) {
                data.input = this.input.toObject();
            }
            if (this.amount != null) {
                data.amount = this.amount.toObject();
            }
            if (this.temperature != null) {
                data.temperature = this.temperature.toObject();
            }
            if (this.keep_phase != null) {
                data.keep_phase = this.keep_phase;
            }
            if (this.stirring != null) {
                data.stirring = this.stirring.toObject();
            }
            if (this.target_ph != null) {
                data.target_ph = this.target_ph;
            }
            if (this.is_automated != null) {
                data.is_automated = this.is_automated;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type != ReactionWorkup.ReactionWorkupType.UNSPECIFIED)
                writer.writeEnum(1, this.type);
            if (this.details.length)
                writer.writeString(2, this.details);
            if (this.has_duration)
                writer.writeMessage(3, this.duration, () => this.duration.serialize(writer));
            if (this.has_input)
                writer.writeMessage(4, this.input, () => this.input.serialize(writer));
            if (this.has_amount)
                writer.writeMessage(5, this.amount, () => this.amount.serialize(writer));
            if (this.has_temperature)
                writer.writeMessage(6, this.temperature, () => this.temperature.serialize(writer));
            if (this.keep_phase.length)
                writer.writeString(7, this.keep_phase);
            if (this.has_stirring)
                writer.writeMessage(8, this.stirring, () => this.stirring.serialize(writer));
            if (this.has_target_ph)
                writer.writeFloat(9, this.target_ph);
            if (this.has_is_automated)
                writer.writeBool(10, this.is_automated);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ReactionWorkup {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ReactionWorkup();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readEnum();
                        break;
                    case 2:
                        message.details = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.duration, () => message.duration = Time.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.input, () => message.input = ReactionInput.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.amount, () => message.amount = Amount.deserialize(reader));
                        break;
                    case 6:
                        reader.readMessage(message.temperature, () => message.temperature = TemperatureConditions.deserialize(reader));
                        break;
                    case 7:
                        message.keep_phase = reader.readString();
                        break;
                    case 8:
                        reader.readMessage(message.stirring, () => message.stirring = StirringConditions.deserialize(reader));
                        break;
                    case 9:
                        message.target_ph = reader.readFloat();
                        break;
                    case 10:
                        message.is_automated = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ReactionWorkup {
            return ReactionWorkup.deserialize(bytes);
        }
    }
    export namespace ReactionWorkup {
        export enum ReactionWorkupType {
            UNSPECIFIED = 0,
            CUSTOM = 1,
            ADDITION = 2,
            ALIQUOT = 3,
            TEMPERATURE = 4,
            CONCENTRATION = 5,
            EXTRACTION = 6,
            FILTRATION = 7,
            WASH = 8,
            DRY_IN_VACUUM = 9,
            DRY_WITH_MATERIAL = 10,
            FLASH_CHROMATOGRAPHY = 11,
            OTHER_CHROMATOGRAPHY = 12,
            SCAVENGING = 13,
            WAIT = 14,
            STIRRING = 15,
            PH_ADJUST = 16,
            DISSOLUTION = 17,
            DISTILLATION = 18
        }
    }
    export class ReactionOutcome extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            reaction_time?: Time;
            conversion?: Percentage;
            products?: ProductCompound[];
            analyses?: Map<string, Analysis>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("reaction_time" in data && data.reaction_time != undefined) {
                    this.reaction_time = data.reaction_time;
                }
                if ("conversion" in data && data.conversion != undefined) {
                    this.conversion = data.conversion;
                }
                if ("products" in data && data.products != undefined) {
                    this.products = data.products;
                }
                if ("analyses" in data && data.analyses != undefined) {
                    this.analyses = data.analyses;
                }
            }
            if (!this.analyses)
                this.analyses = new Map();
        }
        get reaction_time() {
            return pb_1.Message.getWrapperField(this, Time, 1) as Time;
        }
        set reaction_time(value: Time) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_reaction_time() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get conversion() {
            return pb_1.Message.getWrapperField(this, Percentage, 2) as Percentage;
        }
        set conversion(value: Percentage) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_conversion() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get products() {
            return pb_1.Message.getRepeatedWrapperField(this, ProductCompound, 3) as ProductCompound[];
        }
        set products(value: ProductCompound[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        get analyses() {
            return pb_1.Message.getField(this, 4) as any as Map<string, Analysis>;
        }
        set analyses(value: Map<string, Analysis>) {
            pb_1.Message.setField(this, 4, value as any);
        }
        static fromObject(data: {
            reaction_time?: ReturnType<typeof Time.prototype.toObject>;
            conversion?: ReturnType<typeof Percentage.prototype.toObject>;
            products?: ReturnType<typeof ProductCompound.prototype.toObject>[];
            analyses?: {
                [key: string]: ReturnType<typeof Analysis.prototype.toObject>;
            };
        }): ReactionOutcome {
            const message = new ReactionOutcome({});
            if (data.reaction_time != null) {
                message.reaction_time = Time.fromObject(data.reaction_time);
            }
            if (data.conversion != null) {
                message.conversion = Percentage.fromObject(data.conversion);
            }
            if (data.products != null) {
                message.products = data.products.map(item => ProductCompound.fromObject(item));
            }
            if (typeof data.analyses == "object") {
                message.analyses = new Map(Object.entries(data.analyses).map(([key, value]) => [key, Analysis.fromObject(value)]));
            }
            return message;
        }
        toObject() {
            const data: {
                reaction_time?: ReturnType<typeof Time.prototype.toObject>;
                conversion?: ReturnType<typeof Percentage.prototype.toObject>;
                products?: ReturnType<typeof ProductCompound.prototype.toObject>[];
                analyses?: {
                    [key: string]: ReturnType<typeof Analysis.prototype.toObject>;
                };
            } = {};
            if (this.reaction_time != null) {
                data.reaction_time = this.reaction_time.toObject();
            }
            if (this.conversion != null) {
                data.conversion = this.conversion.toObject();
            }
            if (this.products != null) {
                data.products = this.products.map((item: ProductCompound) => item.toObject());
            }
            if (this.analyses != null) {
                data.analyses = (Object.fromEntries)((Array.from)(this.analyses).map(([key, value]) => [key, value.toObject()]));
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_reaction_time)
                writer.writeMessage(1, this.reaction_time, () => this.reaction_time.serialize(writer));
            if (this.has_conversion)
                writer.writeMessage(2, this.conversion, () => this.conversion.serialize(writer));
            if (this.products.length)
                writer.writeRepeatedMessage(3, this.products, (item: ProductCompound) => item.serialize(writer));
            for (const [key, value] of this.analyses) {
                writer.writeMessage(4, this.analyses, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ReactionOutcome {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ReactionOutcome();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.reaction_time, () => message.reaction_time = Time.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.conversion, () => message.conversion = Percentage.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.products, () => pb_1.Message.addToRepeatedWrapperField(message, 3, ProductCompound.deserialize(reader), ProductCompound));
                        break;
                    case 4:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.analyses as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = Analysis.deserialize(reader));
                            return value;
                        }));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ReactionOutcome {
            return ReactionOutcome.deserialize(bytes);
        }
    }
    export class ProductCompound extends pb_1.Message {
        #one_of_decls: number[][] = [[2]];
        constructor(data?: any[] | ({
            identifiers?: CompoundIdentifier[];
            measurements?: ProductMeasurement[];
            isolated_color?: string;
            texture?: Texture;
            features?: Map<string, Data>;
            reaction_role?: ReactionRole.ReactionRoleType;
        } & (({
            is_desired_product?: boolean;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 3], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("identifiers" in data && data.identifiers != undefined) {
                    this.identifiers = data.identifiers;
                }
                if ("is_desired_product" in data && data.is_desired_product != undefined) {
                    this.is_desired_product = data.is_desired_product;
                }
                if ("measurements" in data && data.measurements != undefined) {
                    this.measurements = data.measurements;
                }
                if ("isolated_color" in data && data.isolated_color != undefined) {
                    this.isolated_color = data.isolated_color;
                }
                if ("texture" in data && data.texture != undefined) {
                    this.texture = data.texture;
                }
                if ("features" in data && data.features != undefined) {
                    this.features = data.features;
                }
                if ("reaction_role" in data && data.reaction_role != undefined) {
                    this.reaction_role = data.reaction_role;
                }
            }
            if (!this.features)
                this.features = new Map();
        }
        get identifiers() {
            return pb_1.Message.getRepeatedWrapperField(this, CompoundIdentifier, 1) as CompoundIdentifier[];
        }
        set identifiers(value: CompoundIdentifier[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get is_desired_product() {
            return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
        }
        set is_desired_product(value: boolean) {
            pb_1.Message.setOneofField(this, 2, this.#one_of_decls[0], value);
        }
        get has_is_desired_product() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get measurements() {
            return pb_1.Message.getRepeatedWrapperField(this, ProductMeasurement, 3) as ProductMeasurement[];
        }
        set measurements(value: ProductMeasurement[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        get isolated_color() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set isolated_color(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get texture() {
            return pb_1.Message.getWrapperField(this, Texture, 5) as Texture;
        }
        set texture(value: Texture) {
            pb_1.Message.setWrapperField(this, 5, value);
        }
        get has_texture() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get features() {
            return pb_1.Message.getField(this, 6) as any as Map<string, Data>;
        }
        set features(value: Map<string, Data>) {
            pb_1.Message.setField(this, 6, value as any);
        }
        get reaction_role() {
            return pb_1.Message.getFieldWithDefault(this, 7, ReactionRole.ReactionRoleType.UNSPECIFIED) as ReactionRole.ReactionRoleType;
        }
        set reaction_role(value: ReactionRole.ReactionRoleType) {
            pb_1.Message.setField(this, 7, value);
        }
        get _is_desired_product() {
            const cases: {
                [index: number]: "none" | "is_desired_product";
            } = {
                0: "none",
                2: "is_desired_product"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        static fromObject(data: {
            identifiers?: ReturnType<typeof CompoundIdentifier.prototype.toObject>[];
            is_desired_product?: boolean;
            measurements?: ReturnType<typeof ProductMeasurement.prototype.toObject>[];
            isolated_color?: string;
            texture?: ReturnType<typeof Texture.prototype.toObject>;
            features?: {
                [key: string]: ReturnType<typeof Data.prototype.toObject>;
            };
            reaction_role?: ReactionRole.ReactionRoleType;
        }): ProductCompound {
            const message = new ProductCompound({});
            if (data.identifiers != null) {
                message.identifiers = data.identifiers.map(item => CompoundIdentifier.fromObject(item));
            }
            if (data.is_desired_product != null) {
                message.is_desired_product = data.is_desired_product;
            }
            if (data.measurements != null) {
                message.measurements = data.measurements.map(item => ProductMeasurement.fromObject(item));
            }
            if (data.isolated_color != null) {
                message.isolated_color = data.isolated_color;
            }
            if (data.texture != null) {
                message.texture = Texture.fromObject(data.texture);
            }
            if (typeof data.features == "object") {
                message.features = new Map(Object.entries(data.features).map(([key, value]) => [key, Data.fromObject(value)]));
            }
            if (data.reaction_role != null) {
                message.reaction_role = data.reaction_role;
            }
            return message;
        }
        toObject() {
            const data: {
                identifiers?: ReturnType<typeof CompoundIdentifier.prototype.toObject>[];
                is_desired_product?: boolean;
                measurements?: ReturnType<typeof ProductMeasurement.prototype.toObject>[];
                isolated_color?: string;
                texture?: ReturnType<typeof Texture.prototype.toObject>;
                features?: {
                    [key: string]: ReturnType<typeof Data.prototype.toObject>;
                };
                reaction_role?: ReactionRole.ReactionRoleType;
            } = {};
            if (this.identifiers != null) {
                data.identifiers = this.identifiers.map((item: CompoundIdentifier) => item.toObject());
            }
            if (this.is_desired_product != null) {
                data.is_desired_product = this.is_desired_product;
            }
            if (this.measurements != null) {
                data.measurements = this.measurements.map((item: ProductMeasurement) => item.toObject());
            }
            if (this.isolated_color != null) {
                data.isolated_color = this.isolated_color;
            }
            if (this.texture != null) {
                data.texture = this.texture.toObject();
            }
            if (this.features != null) {
                data.features = (Object.fromEntries)((Array.from)(this.features).map(([key, value]) => [key, value.toObject()]));
            }
            if (this.reaction_role != null) {
                data.reaction_role = this.reaction_role;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.identifiers.length)
                writer.writeRepeatedMessage(1, this.identifiers, (item: CompoundIdentifier) => item.serialize(writer));
            if (this.has_is_desired_product)
                writer.writeBool(2, this.is_desired_product);
            if (this.measurements.length)
                writer.writeRepeatedMessage(3, this.measurements, (item: ProductMeasurement) => item.serialize(writer));
            if (this.isolated_color.length)
                writer.writeString(4, this.isolated_color);
            if (this.has_texture)
                writer.writeMessage(5, this.texture, () => this.texture.serialize(writer));
            for (const [key, value] of this.features) {
                writer.writeMessage(6, this.features, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (this.reaction_role != ReactionRole.ReactionRoleType.UNSPECIFIED)
                writer.writeEnum(7, this.reaction_role);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ProductCompound {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ProductCompound();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.identifiers, () => pb_1.Message.addToRepeatedWrapperField(message, 1, CompoundIdentifier.deserialize(reader), CompoundIdentifier));
                        break;
                    case 2:
                        message.is_desired_product = reader.readBool();
                        break;
                    case 3:
                        reader.readMessage(message.measurements, () => pb_1.Message.addToRepeatedWrapperField(message, 3, ProductMeasurement.deserialize(reader), ProductMeasurement));
                        break;
                    case 4:
                        message.isolated_color = reader.readString();
                        break;
                    case 5:
                        reader.readMessage(message.texture, () => message.texture = Texture.deserialize(reader));
                        break;
                    case 6:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.features as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = Data.deserialize(reader));
                            return value;
                        }));
                        break;
                    case 7:
                        message.reaction_role = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ProductCompound {
            return ProductCompound.deserialize(bytes);
        }
    }
    export class ProductMeasurement extends pb_1.Message {
        #one_of_decls: number[][] = [[8, 9, 10, 11], [4], [5], [6]];
        constructor(data?: any[] | ({
            analysis_key?: string;
            type?: ProductMeasurement.ProductMeasurementType;
            details?: string;
            authentic_standard?: Compound;
            retention_time?: Time;
            mass_spec_details?: ProductMeasurement.MassSpecMeasurementDetails;
            selectivity?: ProductMeasurement.Selectivity;
            wavelength?: Wavelength;
        } & (({
            percentage?: Percentage;
            float_value?: never;
            string_value?: never;
            amount?: never;
        } | {
            percentage?: never;
            float_value?: FloatValue;
            string_value?: never;
            amount?: never;
        } | {
            percentage?: never;
            float_value?: never;
            string_value?: string;
            amount?: never;
        } | {
            percentage?: never;
            float_value?: never;
            string_value?: never;
            amount?: Amount;
        }) | ({
            uses_internal_standard?: boolean;
        }) | ({
            is_normalized?: boolean;
        }) | ({
            uses_authentic_standard?: boolean;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("analysis_key" in data && data.analysis_key != undefined) {
                    this.analysis_key = data.analysis_key;
                }
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("details" in data && data.details != undefined) {
                    this.details = data.details;
                }
                if ("uses_internal_standard" in data && data.uses_internal_standard != undefined) {
                    this.uses_internal_standard = data.uses_internal_standard;
                }
                if ("is_normalized" in data && data.is_normalized != undefined) {
                    this.is_normalized = data.is_normalized;
                }
                if ("uses_authentic_standard" in data && data.uses_authentic_standard != undefined) {
                    this.uses_authentic_standard = data.uses_authentic_standard;
                }
                if ("authentic_standard" in data && data.authentic_standard != undefined) {
                    this.authentic_standard = data.authentic_standard;
                }
                if ("percentage" in data && data.percentage != undefined) {
                    this.percentage = data.percentage;
                }
                if ("float_value" in data && data.float_value != undefined) {
                    this.float_value = data.float_value;
                }
                if ("string_value" in data && data.string_value != undefined) {
                    this.string_value = data.string_value;
                }
                if ("amount" in data && data.amount != undefined) {
                    this.amount = data.amount;
                }
                if ("retention_time" in data && data.retention_time != undefined) {
                    this.retention_time = data.retention_time;
                }
                if ("mass_spec_details" in data && data.mass_spec_details != undefined) {
                    this.mass_spec_details = data.mass_spec_details;
                }
                if ("selectivity" in data && data.selectivity != undefined) {
                    this.selectivity = data.selectivity;
                }
                if ("wavelength" in data && data.wavelength != undefined) {
                    this.wavelength = data.wavelength;
                }
            }
        }
        get analysis_key() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set analysis_key(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 2, ProductMeasurement.ProductMeasurementType.UNSPECIFIED) as ProductMeasurement.ProductMeasurementType;
        }
        set type(value: ProductMeasurement.ProductMeasurementType) {
            pb_1.Message.setField(this, 2, value);
        }
        get details() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set details(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get uses_internal_standard() {
            return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
        }
        set uses_internal_standard(value: boolean) {
            pb_1.Message.setOneofField(this, 4, this.#one_of_decls[1], value);
        }
        get has_uses_internal_standard() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get is_normalized() {
            return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
        }
        set is_normalized(value: boolean) {
            pb_1.Message.setOneofField(this, 5, this.#one_of_decls[2], value);
        }
        get has_is_normalized() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get uses_authentic_standard() {
            return pb_1.Message.getFieldWithDefault(this, 6, false) as boolean;
        }
        set uses_authentic_standard(value: boolean) {
            pb_1.Message.setOneofField(this, 6, this.#one_of_decls[3], value);
        }
        get has_uses_authentic_standard() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get authentic_standard() {
            return pb_1.Message.getWrapperField(this, Compound, 7) as Compound;
        }
        set authentic_standard(value: Compound) {
            pb_1.Message.setWrapperField(this, 7, value);
        }
        get has_authentic_standard() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get percentage() {
            return pb_1.Message.getWrapperField(this, Percentage, 8) as Percentage;
        }
        set percentage(value: Percentage) {
            pb_1.Message.setOneofWrapperField(this, 8, this.#one_of_decls[0], value);
        }
        get has_percentage() {
            return pb_1.Message.getField(this, 8) != null;
        }
        get float_value() {
            return pb_1.Message.getWrapperField(this, FloatValue, 9) as FloatValue;
        }
        set float_value(value: FloatValue) {
            pb_1.Message.setOneofWrapperField(this, 9, this.#one_of_decls[0], value);
        }
        get has_float_value() {
            return pb_1.Message.getField(this, 9) != null;
        }
        get string_value() {
            return pb_1.Message.getFieldWithDefault(this, 10, "") as string;
        }
        set string_value(value: string) {
            pb_1.Message.setOneofField(this, 10, this.#one_of_decls[0], value);
        }
        get has_string_value() {
            return pb_1.Message.getField(this, 10) != null;
        }
        get amount() {
            return pb_1.Message.getWrapperField(this, Amount, 11) as Amount;
        }
        set amount(value: Amount) {
            pb_1.Message.setOneofWrapperField(this, 11, this.#one_of_decls[0], value);
        }
        get has_amount() {
            return pb_1.Message.getField(this, 11) != null;
        }
        get retention_time() {
            return pb_1.Message.getWrapperField(this, Time, 12) as Time;
        }
        set retention_time(value: Time) {
            pb_1.Message.setWrapperField(this, 12, value);
        }
        get has_retention_time() {
            return pb_1.Message.getField(this, 12) != null;
        }
        get mass_spec_details() {
            return pb_1.Message.getWrapperField(this, ProductMeasurement.MassSpecMeasurementDetails, 13) as ProductMeasurement.MassSpecMeasurementDetails;
        }
        set mass_spec_details(value: ProductMeasurement.MassSpecMeasurementDetails) {
            pb_1.Message.setWrapperField(this, 13, value);
        }
        get has_mass_spec_details() {
            return pb_1.Message.getField(this, 13) != null;
        }
        get selectivity() {
            return pb_1.Message.getWrapperField(this, ProductMeasurement.Selectivity, 14) as ProductMeasurement.Selectivity;
        }
        set selectivity(value: ProductMeasurement.Selectivity) {
            pb_1.Message.setWrapperField(this, 14, value);
        }
        get has_selectivity() {
            return pb_1.Message.getField(this, 14) != null;
        }
        get wavelength() {
            return pb_1.Message.getWrapperField(this, Wavelength, 15) as Wavelength;
        }
        set wavelength(value: Wavelength) {
            pb_1.Message.setWrapperField(this, 15, value);
        }
        get has_wavelength() {
            return pb_1.Message.getField(this, 15) != null;
        }
        get value() {
            const cases: {
                [index: number]: "none" | "percentage" | "float_value" | "string_value" | "amount";
            } = {
                0: "none",
                8: "percentage",
                9: "float_value",
                10: "string_value",
                11: "amount"
            };
            return cases[pb_1.Message.computeOneofCase(this, [8, 9, 10, 11])];
        }
        get _uses_internal_standard() {
            const cases: {
                [index: number]: "none" | "uses_internal_standard";
            } = {
                0: "none",
                4: "uses_internal_standard"
            };
            return cases[pb_1.Message.computeOneofCase(this, [4])];
        }
        get _is_normalized() {
            const cases: {
                [index: number]: "none" | "is_normalized";
            } = {
                0: "none",
                5: "is_normalized"
            };
            return cases[pb_1.Message.computeOneofCase(this, [5])];
        }
        get _uses_authentic_standard() {
            const cases: {
                [index: number]: "none" | "uses_authentic_standard";
            } = {
                0: "none",
                6: "uses_authentic_standard"
            };
            return cases[pb_1.Message.computeOneofCase(this, [6])];
        }
        static fromObject(data: {
            analysis_key?: string;
            type?: ProductMeasurement.ProductMeasurementType;
            details?: string;
            uses_internal_standard?: boolean;
            is_normalized?: boolean;
            uses_authentic_standard?: boolean;
            authentic_standard?: ReturnType<typeof Compound.prototype.toObject>;
            percentage?: ReturnType<typeof Percentage.prototype.toObject>;
            float_value?: ReturnType<typeof FloatValue.prototype.toObject>;
            string_value?: string;
            amount?: ReturnType<typeof Amount.prototype.toObject>;
            retention_time?: ReturnType<typeof Time.prototype.toObject>;
            mass_spec_details?: ReturnType<typeof ProductMeasurement.MassSpecMeasurementDetails.prototype.toObject>;
            selectivity?: ReturnType<typeof ProductMeasurement.Selectivity.prototype.toObject>;
            wavelength?: ReturnType<typeof Wavelength.prototype.toObject>;
        }): ProductMeasurement {
            const message = new ProductMeasurement({});
            if (data.analysis_key != null) {
                message.analysis_key = data.analysis_key;
            }
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.details != null) {
                message.details = data.details;
            }
            if (data.uses_internal_standard != null) {
                message.uses_internal_standard = data.uses_internal_standard;
            }
            if (data.is_normalized != null) {
                message.is_normalized = data.is_normalized;
            }
            if (data.uses_authentic_standard != null) {
                message.uses_authentic_standard = data.uses_authentic_standard;
            }
            if (data.authentic_standard != null) {
                message.authentic_standard = Compound.fromObject(data.authentic_standard);
            }
            if (data.percentage != null) {
                message.percentage = Percentage.fromObject(data.percentage);
            }
            if (data.float_value != null) {
                message.float_value = FloatValue.fromObject(data.float_value);
            }
            if (data.string_value != null) {
                message.string_value = data.string_value;
            }
            if (data.amount != null) {
                message.amount = Amount.fromObject(data.amount);
            }
            if (data.retention_time != null) {
                message.retention_time = Time.fromObject(data.retention_time);
            }
            if (data.mass_spec_details != null) {
                message.mass_spec_details = ProductMeasurement.MassSpecMeasurementDetails.fromObject(data.mass_spec_details);
            }
            if (data.selectivity != null) {
                message.selectivity = ProductMeasurement.Selectivity.fromObject(data.selectivity);
            }
            if (data.wavelength != null) {
                message.wavelength = Wavelength.fromObject(data.wavelength);
            }
            return message;
        }
        toObject() {
            const data: {
                analysis_key?: string;
                type?: ProductMeasurement.ProductMeasurementType;
                details?: string;
                uses_internal_standard?: boolean;
                is_normalized?: boolean;
                uses_authentic_standard?: boolean;
                authentic_standard?: ReturnType<typeof Compound.prototype.toObject>;
                percentage?: ReturnType<typeof Percentage.prototype.toObject>;
                float_value?: ReturnType<typeof FloatValue.prototype.toObject>;
                string_value?: string;
                amount?: ReturnType<typeof Amount.prototype.toObject>;
                retention_time?: ReturnType<typeof Time.prototype.toObject>;
                mass_spec_details?: ReturnType<typeof ProductMeasurement.MassSpecMeasurementDetails.prototype.toObject>;
                selectivity?: ReturnType<typeof ProductMeasurement.Selectivity.prototype.toObject>;
                wavelength?: ReturnType<typeof Wavelength.prototype.toObject>;
            } = {};
            if (this.analysis_key != null) {
                data.analysis_key = this.analysis_key;
            }
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.details != null) {
                data.details = this.details;
            }
            if (this.uses_internal_standard != null) {
                data.uses_internal_standard = this.uses_internal_standard;
            }
            if (this.is_normalized != null) {
                data.is_normalized = this.is_normalized;
            }
            if (this.uses_authentic_standard != null) {
                data.uses_authentic_standard = this.uses_authentic_standard;
            }
            if (this.authentic_standard != null) {
                data.authentic_standard = this.authentic_standard.toObject();
            }
            if (this.percentage != null) {
                data.percentage = this.percentage.toObject();
            }
            if (this.float_value != null) {
                data.float_value = this.float_value.toObject();
            }
            if (this.string_value != null) {
                data.string_value = this.string_value;
            }
            if (this.amount != null) {
                data.amount = this.amount.toObject();
            }
            if (this.retention_time != null) {
                data.retention_time = this.retention_time.toObject();
            }
            if (this.mass_spec_details != null) {
                data.mass_spec_details = this.mass_spec_details.toObject();
            }
            if (this.selectivity != null) {
                data.selectivity = this.selectivity.toObject();
            }
            if (this.wavelength != null) {
                data.wavelength = this.wavelength.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.analysis_key.length)
                writer.writeString(1, this.analysis_key);
            if (this.type != ProductMeasurement.ProductMeasurementType.UNSPECIFIED)
                writer.writeEnum(2, this.type);
            if (this.details.length)
                writer.writeString(3, this.details);
            if (this.has_uses_internal_standard)
                writer.writeBool(4, this.uses_internal_standard);
            if (this.has_is_normalized)
                writer.writeBool(5, this.is_normalized);
            if (this.has_uses_authentic_standard)
                writer.writeBool(6, this.uses_authentic_standard);
            if (this.has_authentic_standard)
                writer.writeMessage(7, this.authentic_standard, () => this.authentic_standard.serialize(writer));
            if (this.has_percentage)
                writer.writeMessage(8, this.percentage, () => this.percentage.serialize(writer));
            if (this.has_float_value)
                writer.writeMessage(9, this.float_value, () => this.float_value.serialize(writer));
            if (this.has_string_value)
                writer.writeString(10, this.string_value);
            if (this.has_amount)
                writer.writeMessage(11, this.amount, () => this.amount.serialize(writer));
            if (this.has_retention_time)
                writer.writeMessage(12, this.retention_time, () => this.retention_time.serialize(writer));
            if (this.has_mass_spec_details)
                writer.writeMessage(13, this.mass_spec_details, () => this.mass_spec_details.serialize(writer));
            if (this.has_selectivity)
                writer.writeMessage(14, this.selectivity, () => this.selectivity.serialize(writer));
            if (this.has_wavelength)
                writer.writeMessage(15, this.wavelength, () => this.wavelength.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ProductMeasurement {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ProductMeasurement();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.analysis_key = reader.readString();
                        break;
                    case 2:
                        message.type = reader.readEnum();
                        break;
                    case 3:
                        message.details = reader.readString();
                        break;
                    case 4:
                        message.uses_internal_standard = reader.readBool();
                        break;
                    case 5:
                        message.is_normalized = reader.readBool();
                        break;
                    case 6:
                        message.uses_authentic_standard = reader.readBool();
                        break;
                    case 7:
                        reader.readMessage(message.authentic_standard, () => message.authentic_standard = Compound.deserialize(reader));
                        break;
                    case 8:
                        reader.readMessage(message.percentage, () => message.percentage = Percentage.deserialize(reader));
                        break;
                    case 9:
                        reader.readMessage(message.float_value, () => message.float_value = FloatValue.deserialize(reader));
                        break;
                    case 10:
                        message.string_value = reader.readString();
                        break;
                    case 11:
                        reader.readMessage(message.amount, () => message.amount = Amount.deserialize(reader));
                        break;
                    case 12:
                        reader.readMessage(message.retention_time, () => message.retention_time = Time.deserialize(reader));
                        break;
                    case 13:
                        reader.readMessage(message.mass_spec_details, () => message.mass_spec_details = ProductMeasurement.MassSpecMeasurementDetails.deserialize(reader));
                        break;
                    case 14:
                        reader.readMessage(message.selectivity, () => message.selectivity = ProductMeasurement.Selectivity.deserialize(reader));
                        break;
                    case 15:
                        reader.readMessage(message.wavelength, () => message.wavelength = Wavelength.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ProductMeasurement {
            return ProductMeasurement.deserialize(bytes);
        }
    }
    export namespace ProductMeasurement {
        export enum ProductMeasurementType {
            UNSPECIFIED = 0,
            CUSTOM = 1,
            IDENTITY = 2,
            YIELD = 3,
            SELECTIVITY = 4,
            PURITY = 5,
            AREA = 6,
            COUNTS = 7,
            INTENSITY = 8,
            AMOUNT = 9
        }
        export class MassSpecMeasurementDetails extends pb_1.Message {
            #one_of_decls: number[][] = [[3], [4]];
            constructor(data?: any[] | ({
                type?: ProductMeasurement.MassSpecMeasurementDetails.MassSpecMeasurementType;
                details?: string;
                eic_masses?: number[];
            } & (({
                tic_minimum_mz?: number;
            }) | ({
                tic_maximum_mz?: number;
            })))) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [5], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("type" in data && data.type != undefined) {
                        this.type = data.type;
                    }
                    if ("details" in data && data.details != undefined) {
                        this.details = data.details;
                    }
                    if ("tic_minimum_mz" in data && data.tic_minimum_mz != undefined) {
                        this.tic_minimum_mz = data.tic_minimum_mz;
                    }
                    if ("tic_maximum_mz" in data && data.tic_maximum_mz != undefined) {
                        this.tic_maximum_mz = data.tic_maximum_mz;
                    }
                    if ("eic_masses" in data && data.eic_masses != undefined) {
                        this.eic_masses = data.eic_masses;
                    }
                }
            }
            get type() {
                return pb_1.Message.getFieldWithDefault(this, 1, ProductMeasurement.MassSpecMeasurementDetails.MassSpecMeasurementType.UNSPECIFIED) as ProductMeasurement.MassSpecMeasurementDetails.MassSpecMeasurementType;
            }
            set type(value: ProductMeasurement.MassSpecMeasurementDetails.MassSpecMeasurementType) {
                pb_1.Message.setField(this, 1, value);
            }
            get details() {
                return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
            }
            set details(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            get tic_minimum_mz() {
                return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
            }
            set tic_minimum_mz(value: number) {
                pb_1.Message.setOneofField(this, 3, this.#one_of_decls[0], value);
            }
            get has_tic_minimum_mz() {
                return pb_1.Message.getField(this, 3) != null;
            }
            get tic_maximum_mz() {
                return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
            }
            set tic_maximum_mz(value: number) {
                pb_1.Message.setOneofField(this, 4, this.#one_of_decls[1], value);
            }
            get has_tic_maximum_mz() {
                return pb_1.Message.getField(this, 4) != null;
            }
            get eic_masses() {
                return pb_1.Message.getFieldWithDefault(this, 5, []) as number[];
            }
            set eic_masses(value: number[]) {
                pb_1.Message.setField(this, 5, value);
            }
            get _tic_minimum_mz() {
                const cases: {
                    [index: number]: "none" | "tic_minimum_mz";
                } = {
                    0: "none",
                    3: "tic_minimum_mz"
                };
                return cases[pb_1.Message.computeOneofCase(this, [3])];
            }
            get _tic_maximum_mz() {
                const cases: {
                    [index: number]: "none" | "tic_maximum_mz";
                } = {
                    0: "none",
                    4: "tic_maximum_mz"
                };
                return cases[pb_1.Message.computeOneofCase(this, [4])];
            }
            static fromObject(data: {
                type?: ProductMeasurement.MassSpecMeasurementDetails.MassSpecMeasurementType;
                details?: string;
                tic_minimum_mz?: number;
                tic_maximum_mz?: number;
                eic_masses?: number[];
            }): MassSpecMeasurementDetails {
                const message = new MassSpecMeasurementDetails({});
                if (data.type != null) {
                    message.type = data.type;
                }
                if (data.details != null) {
                    message.details = data.details;
                }
                if (data.tic_minimum_mz != null) {
                    message.tic_minimum_mz = data.tic_minimum_mz;
                }
                if (data.tic_maximum_mz != null) {
                    message.tic_maximum_mz = data.tic_maximum_mz;
                }
                if (data.eic_masses != null) {
                    message.eic_masses = data.eic_masses;
                }
                return message;
            }
            toObject() {
                const data: {
                    type?: ProductMeasurement.MassSpecMeasurementDetails.MassSpecMeasurementType;
                    details?: string;
                    tic_minimum_mz?: number;
                    tic_maximum_mz?: number;
                    eic_masses?: number[];
                } = {};
                if (this.type != null) {
                    data.type = this.type;
                }
                if (this.details != null) {
                    data.details = this.details;
                }
                if (this.tic_minimum_mz != null) {
                    data.tic_minimum_mz = this.tic_minimum_mz;
                }
                if (this.tic_maximum_mz != null) {
                    data.tic_maximum_mz = this.tic_maximum_mz;
                }
                if (this.eic_masses != null) {
                    data.eic_masses = this.eic_masses;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.type != ProductMeasurement.MassSpecMeasurementDetails.MassSpecMeasurementType.UNSPECIFIED)
                    writer.writeEnum(1, this.type);
                if (this.details.length)
                    writer.writeString(2, this.details);
                if (this.has_tic_minimum_mz)
                    writer.writeFloat(3, this.tic_minimum_mz);
                if (this.has_tic_maximum_mz)
                    writer.writeFloat(4, this.tic_maximum_mz);
                if (this.eic_masses.length)
                    writer.writePackedFloat(5, this.eic_masses);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MassSpecMeasurementDetails {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MassSpecMeasurementDetails();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.type = reader.readEnum();
                            break;
                        case 2:
                            message.details = reader.readString();
                            break;
                        case 3:
                            message.tic_minimum_mz = reader.readFloat();
                            break;
                        case 4:
                            message.tic_maximum_mz = reader.readFloat();
                            break;
                        case 5:
                            message.eic_masses = reader.readPackedFloat();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MassSpecMeasurementDetails {
                return MassSpecMeasurementDetails.deserialize(bytes);
            }
        }
        export namespace MassSpecMeasurementDetails {
            export enum MassSpecMeasurementType {
                UNSPECIFIED = 0,
                CUSTOM = 1,
                TIC = 2,
                TIC_POSITIVE = 3,
                TIC_NEGATIVE = 4,
                EIC = 5
            }
        }
        export class Selectivity extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                type?: ProductMeasurement.Selectivity.SelectivityType;
                details?: string;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("type" in data && data.type != undefined) {
                        this.type = data.type;
                    }
                    if ("details" in data && data.details != undefined) {
                        this.details = data.details;
                    }
                }
            }
            get type() {
                return pb_1.Message.getFieldWithDefault(this, 1, ProductMeasurement.Selectivity.SelectivityType.UNSPECIFIED) as ProductMeasurement.Selectivity.SelectivityType;
            }
            set type(value: ProductMeasurement.Selectivity.SelectivityType) {
                pb_1.Message.setField(this, 1, value);
            }
            get details() {
                return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
            }
            set details(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            static fromObject(data: {
                type?: ProductMeasurement.Selectivity.SelectivityType;
                details?: string;
            }): Selectivity {
                const message = new Selectivity({});
                if (data.type != null) {
                    message.type = data.type;
                }
                if (data.details != null) {
                    message.details = data.details;
                }
                return message;
            }
            toObject() {
                const data: {
                    type?: ProductMeasurement.Selectivity.SelectivityType;
                    details?: string;
                } = {};
                if (this.type != null) {
                    data.type = this.type;
                }
                if (this.details != null) {
                    data.details = this.details;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.type != ProductMeasurement.Selectivity.SelectivityType.UNSPECIFIED)
                    writer.writeEnum(1, this.type);
                if (this.details.length)
                    writer.writeString(2, this.details);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Selectivity {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Selectivity();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.type = reader.readEnum();
                            break;
                        case 2:
                            message.details = reader.readString();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Selectivity {
                return Selectivity.deserialize(bytes);
            }
        }
        export namespace Selectivity {
            export enum SelectivityType {
                UNSPECIFIED = 0,
                CUSTOM = 1,
                EE = 2,
                ER = 3,
                DR = 4,
                EZ = 5,
                ZE = 6
            }
        }
    }
    export class DateTime extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            value?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set value(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            value?: string;
        }): DateTime {
            const message = new DateTime({});
            if (data.value != null) {
                message.value = data.value;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: string;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.value.length)
                writer.writeString(1, this.value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DateTime {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DateTime();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): DateTime {
            return DateTime.deserialize(bytes);
        }
    }
    export class Analysis extends pb_1.Message {
        #one_of_decls: number[][] = [[4]];
        constructor(data?: any[] | ({
            type?: Analysis.AnalysisType;
            details?: string;
            chmo_id?: number;
            data?: Map<string, Data>;
            instrument_manufacturer?: string;
            instrument_last_calibrated?: DateTime;
        } & (({
            is_of_isolated_species?: boolean;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("details" in data && data.details != undefined) {
                    this.details = data.details;
                }
                if ("chmo_id" in data && data.chmo_id != undefined) {
                    this.chmo_id = data.chmo_id;
                }
                if ("is_of_isolated_species" in data && data.is_of_isolated_species != undefined) {
                    this.is_of_isolated_species = data.is_of_isolated_species;
                }
                if ("data" in data && data.data != undefined) {
                    this.data = data.data;
                }
                if ("instrument_manufacturer" in data && data.instrument_manufacturer != undefined) {
                    this.instrument_manufacturer = data.instrument_manufacturer;
                }
                if ("instrument_last_calibrated" in data && data.instrument_last_calibrated != undefined) {
                    this.instrument_last_calibrated = data.instrument_last_calibrated;
                }
            }
            if (!this.data)
                this.data = new Map();
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 1, Analysis.AnalysisType.UNSPECIFIED) as Analysis.AnalysisType;
        }
        set type(value: Analysis.AnalysisType) {
            pb_1.Message.setField(this, 1, value);
        }
        get details() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set details(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get chmo_id() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set chmo_id(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get is_of_isolated_species() {
            return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
        }
        set is_of_isolated_species(value: boolean) {
            pb_1.Message.setOneofField(this, 4, this.#one_of_decls[0], value);
        }
        get has_is_of_isolated_species() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get data() {
            return pb_1.Message.getField(this, 5) as any as Map<string, Data>;
        }
        set data(value: Map<string, Data>) {
            pb_1.Message.setField(this, 5, value as any);
        }
        get instrument_manufacturer() {
            return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
        }
        set instrument_manufacturer(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        get instrument_last_calibrated() {
            return pb_1.Message.getWrapperField(this, DateTime, 7) as DateTime;
        }
        set instrument_last_calibrated(value: DateTime) {
            pb_1.Message.setWrapperField(this, 7, value);
        }
        get has_instrument_last_calibrated() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get _is_of_isolated_species() {
            const cases: {
                [index: number]: "none" | "is_of_isolated_species";
            } = {
                0: "none",
                4: "is_of_isolated_species"
            };
            return cases[pb_1.Message.computeOneofCase(this, [4])];
        }
        static fromObject(data: {
            type?: Analysis.AnalysisType;
            details?: string;
            chmo_id?: number;
            is_of_isolated_species?: boolean;
            data?: {
                [key: string]: ReturnType<typeof Data.prototype.toObject>;
            };
            instrument_manufacturer?: string;
            instrument_last_calibrated?: ReturnType<typeof DateTime.prototype.toObject>;
        }): Analysis {
            const message = new Analysis({});
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.details != null) {
                message.details = data.details;
            }
            if (data.chmo_id != null) {
                message.chmo_id = data.chmo_id;
            }
            if (data.is_of_isolated_species != null) {
                message.is_of_isolated_species = data.is_of_isolated_species;
            }
            if (typeof data.data == "object") {
                message.data = new Map(Object.entries(data.data).map(([key, value]) => [key, Data.fromObject(value)]));
            }
            if (data.instrument_manufacturer != null) {
                message.instrument_manufacturer = data.instrument_manufacturer;
            }
            if (data.instrument_last_calibrated != null) {
                message.instrument_last_calibrated = DateTime.fromObject(data.instrument_last_calibrated);
            }
            return message;
        }
        toObject() {
            const data: {
                type?: Analysis.AnalysisType;
                details?: string;
                chmo_id?: number;
                is_of_isolated_species?: boolean;
                data?: {
                    [key: string]: ReturnType<typeof Data.prototype.toObject>;
                };
                instrument_manufacturer?: string;
                instrument_last_calibrated?: ReturnType<typeof DateTime.prototype.toObject>;
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.details != null) {
                data.details = this.details;
            }
            if (this.chmo_id != null) {
                data.chmo_id = this.chmo_id;
            }
            if (this.is_of_isolated_species != null) {
                data.is_of_isolated_species = this.is_of_isolated_species;
            }
            if (this.data != null) {
                data.data = (Object.fromEntries)((Array.from)(this.data).map(([key, value]) => [key, value.toObject()]));
            }
            if (this.instrument_manufacturer != null) {
                data.instrument_manufacturer = this.instrument_manufacturer;
            }
            if (this.instrument_last_calibrated != null) {
                data.instrument_last_calibrated = this.instrument_last_calibrated.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type != Analysis.AnalysisType.UNSPECIFIED)
                writer.writeEnum(1, this.type);
            if (this.details.length)
                writer.writeString(2, this.details);
            if (this.chmo_id != 0)
                writer.writeInt32(3, this.chmo_id);
            if (this.has_is_of_isolated_species)
                writer.writeBool(4, this.is_of_isolated_species);
            for (const [key, value] of this.data) {
                writer.writeMessage(5, this.data, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (this.instrument_manufacturer.length)
                writer.writeString(6, this.instrument_manufacturer);
            if (this.has_instrument_last_calibrated)
                writer.writeMessage(7, this.instrument_last_calibrated, () => this.instrument_last_calibrated.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Analysis {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Analysis();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readEnum();
                        break;
                    case 2:
                        message.details = reader.readString();
                        break;
                    case 3:
                        message.chmo_id = reader.readInt32();
                        break;
                    case 4:
                        message.is_of_isolated_species = reader.readBool();
                        break;
                    case 5:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.data as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = Data.deserialize(reader));
                            return value;
                        }));
                        break;
                    case 6:
                        message.instrument_manufacturer = reader.readString();
                        break;
                    case 7:
                        reader.readMessage(message.instrument_last_calibrated, () => message.instrument_last_calibrated = DateTime.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Analysis {
            return Analysis.deserialize(bytes);
        }
    }
    export namespace Analysis {
        export enum AnalysisType {
            UNSPECIFIED = 0,
            CUSTOM = 1,
            LC = 2,
            GC = 3,
            IR = 4,
            NMR_1H = 5,
            NMR_13C = 6,
            NMR_OTHER = 7,
            MP = 8,
            UV = 9,
            TLC = 10,
            MS = 11,
            HRMS = 12,
            MSMS = 13,
            WEIGHT = 14,
            LCMS = 15,
            GCMS = 16,
            ELSD = 17,
            CD = 18,
            SFC = 19,
            EPR = 20,
            XRD = 21,
            RAMAN = 22,
            ED = 23,
            OPTICAL_ROTATION = 24,
            CAD = 25
        }
    }
    export class ReactionProvenance extends pb_1.Message {
        #one_of_decls: number[][] = [[10]];
        constructor(data?: any[] | ({
            experimenter?: Person;
            city?: string;
            experiment_start?: DateTime;
            doi?: string;
            patent?: string;
            publication_url?: string;
            record_created?: RecordEvent;
            record_modified?: RecordEvent[];
            reaction_metadata?: Map<string, Data>;
        } & (({
            is_mined?: boolean;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [8], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("experimenter" in data && data.experimenter != undefined) {
                    this.experimenter = data.experimenter;
                }
                if ("city" in data && data.city != undefined) {
                    this.city = data.city;
                }
                if ("experiment_start" in data && data.experiment_start != undefined) {
                    this.experiment_start = data.experiment_start;
                }
                if ("doi" in data && data.doi != undefined) {
                    this.doi = data.doi;
                }
                if ("patent" in data && data.patent != undefined) {
                    this.patent = data.patent;
                }
                if ("publication_url" in data && data.publication_url != undefined) {
                    this.publication_url = data.publication_url;
                }
                if ("record_created" in data && data.record_created != undefined) {
                    this.record_created = data.record_created;
                }
                if ("record_modified" in data && data.record_modified != undefined) {
                    this.record_modified = data.record_modified;
                }
                if ("reaction_metadata" in data && data.reaction_metadata != undefined) {
                    this.reaction_metadata = data.reaction_metadata;
                }
                if ("is_mined" in data && data.is_mined != undefined) {
                    this.is_mined = data.is_mined;
                }
            }
            if (!this.reaction_metadata)
                this.reaction_metadata = new Map();
        }
        get experimenter() {
            return pb_1.Message.getWrapperField(this, Person, 1) as Person;
        }
        set experimenter(value: Person) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_experimenter() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get city() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set city(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get experiment_start() {
            return pb_1.Message.getWrapperField(this, DateTime, 3) as DateTime;
        }
        set experiment_start(value: DateTime) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_experiment_start() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get doi() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set doi(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get patent() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        set patent(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get publication_url() {
            return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
        }
        set publication_url(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        get record_created() {
            return pb_1.Message.getWrapperField(this, RecordEvent, 7) as RecordEvent;
        }
        set record_created(value: RecordEvent) {
            pb_1.Message.setWrapperField(this, 7, value);
        }
        get has_record_created() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get record_modified() {
            return pb_1.Message.getRepeatedWrapperField(this, RecordEvent, 8) as RecordEvent[];
        }
        set record_modified(value: RecordEvent[]) {
            pb_1.Message.setRepeatedWrapperField(this, 8, value);
        }
        get reaction_metadata() {
            return pb_1.Message.getField(this, 9) as any as Map<string, Data>;
        }
        set reaction_metadata(value: Map<string, Data>) {
            pb_1.Message.setField(this, 9, value as any);
        }
        get is_mined() {
            return pb_1.Message.getFieldWithDefault(this, 10, false) as boolean;
        }
        set is_mined(value: boolean) {
            pb_1.Message.setOneofField(this, 10, this.#one_of_decls[0], value);
        }
        get has_is_mined() {
            return pb_1.Message.getField(this, 10) != null;
        }
        get _is_mined() {
            const cases: {
                [index: number]: "none" | "is_mined";
            } = {
                0: "none",
                10: "is_mined"
            };
            return cases[pb_1.Message.computeOneofCase(this, [10])];
        }
        static fromObject(data: {
            experimenter?: ReturnType<typeof Person.prototype.toObject>;
            city?: string;
            experiment_start?: ReturnType<typeof DateTime.prototype.toObject>;
            doi?: string;
            patent?: string;
            publication_url?: string;
            record_created?: ReturnType<typeof RecordEvent.prototype.toObject>;
            record_modified?: ReturnType<typeof RecordEvent.prototype.toObject>[];
            reaction_metadata?: {
                [key: string]: ReturnType<typeof Data.prototype.toObject>;
            };
            is_mined?: boolean;
        }): ReactionProvenance {
            const message = new ReactionProvenance({});
            if (data.experimenter != null) {
                message.experimenter = Person.fromObject(data.experimenter);
            }
            if (data.city != null) {
                message.city = data.city;
            }
            if (data.experiment_start != null) {
                message.experiment_start = DateTime.fromObject(data.experiment_start);
            }
            if (data.doi != null) {
                message.doi = data.doi;
            }
            if (data.patent != null) {
                message.patent = data.patent;
            }
            if (data.publication_url != null) {
                message.publication_url = data.publication_url;
            }
            if (data.record_created != null) {
                message.record_created = RecordEvent.fromObject(data.record_created);
            }
            if (data.record_modified != null) {
                message.record_modified = data.record_modified.map(item => RecordEvent.fromObject(item));
            }
            if (typeof data.reaction_metadata == "object") {
                message.reaction_metadata = new Map(Object.entries(data.reaction_metadata).map(([key, value]) => [key, Data.fromObject(value)]));
            }
            if (data.is_mined != null) {
                message.is_mined = data.is_mined;
            }
            return message;
        }
        toObject() {
            const data: {
                experimenter?: ReturnType<typeof Person.prototype.toObject>;
                city?: string;
                experiment_start?: ReturnType<typeof DateTime.prototype.toObject>;
                doi?: string;
                patent?: string;
                publication_url?: string;
                record_created?: ReturnType<typeof RecordEvent.prototype.toObject>;
                record_modified?: ReturnType<typeof RecordEvent.prototype.toObject>[];
                reaction_metadata?: {
                    [key: string]: ReturnType<typeof Data.prototype.toObject>;
                };
                is_mined?: boolean;
            } = {};
            if (this.experimenter != null) {
                data.experimenter = this.experimenter.toObject();
            }
            if (this.city != null) {
                data.city = this.city;
            }
            if (this.experiment_start != null) {
                data.experiment_start = this.experiment_start.toObject();
            }
            if (this.doi != null) {
                data.doi = this.doi;
            }
            if (this.patent != null) {
                data.patent = this.patent;
            }
            if (this.publication_url != null) {
                data.publication_url = this.publication_url;
            }
            if (this.record_created != null) {
                data.record_created = this.record_created.toObject();
            }
            if (this.record_modified != null) {
                data.record_modified = this.record_modified.map((item: RecordEvent) => item.toObject());
            }
            if (this.reaction_metadata != null) {
                data.reaction_metadata = (Object.fromEntries)((Array.from)(this.reaction_metadata).map(([key, value]) => [key, value.toObject()]));
            }
            if (this.is_mined != null) {
                data.is_mined = this.is_mined;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_experimenter)
                writer.writeMessage(1, this.experimenter, () => this.experimenter.serialize(writer));
            if (this.city.length)
                writer.writeString(2, this.city);
            if (this.has_experiment_start)
                writer.writeMessage(3, this.experiment_start, () => this.experiment_start.serialize(writer));
            if (this.doi.length)
                writer.writeString(4, this.doi);
            if (this.patent.length)
                writer.writeString(5, this.patent);
            if (this.publication_url.length)
                writer.writeString(6, this.publication_url);
            if (this.has_record_created)
                writer.writeMessage(7, this.record_created, () => this.record_created.serialize(writer));
            if (this.record_modified.length)
                writer.writeRepeatedMessage(8, this.record_modified, (item: RecordEvent) => item.serialize(writer));
            for (const [key, value] of this.reaction_metadata) {
                writer.writeMessage(9, this.reaction_metadata, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (this.has_is_mined)
                writer.writeBool(10, this.is_mined);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ReactionProvenance {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ReactionProvenance();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.experimenter, () => message.experimenter = Person.deserialize(reader));
                        break;
                    case 2:
                        message.city = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.experiment_start, () => message.experiment_start = DateTime.deserialize(reader));
                        break;
                    case 4:
                        message.doi = reader.readString();
                        break;
                    case 5:
                        message.patent = reader.readString();
                        break;
                    case 6:
                        message.publication_url = reader.readString();
                        break;
                    case 7:
                        reader.readMessage(message.record_created, () => message.record_created = RecordEvent.deserialize(reader));
                        break;
                    case 8:
                        reader.readMessage(message.record_modified, () => pb_1.Message.addToRepeatedWrapperField(message, 8, RecordEvent.deserialize(reader), RecordEvent));
                        break;
                    case 9:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.reaction_metadata as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = Data.deserialize(reader));
                            return value;
                        }));
                        break;
                    case 10:
                        message.is_mined = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ReactionProvenance {
            return ReactionProvenance.deserialize(bytes);
        }
    }
    export class Person extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            username?: string;
            name?: string;
            orcid?: string;
            organization?: string;
            email?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("username" in data && data.username != undefined) {
                    this.username = data.username;
                }
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("orcid" in data && data.orcid != undefined) {
                    this.orcid = data.orcid;
                }
                if ("organization" in data && data.organization != undefined) {
                    this.organization = data.organization;
                }
                if ("email" in data && data.email != undefined) {
                    this.email = data.email;
                }
            }
        }
        get username() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set username(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get orcid() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set orcid(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get organization() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set organization(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get email() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        set email(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            username?: string;
            name?: string;
            orcid?: string;
            organization?: string;
            email?: string;
        }): Person {
            const message = new Person({});
            if (data.username != null) {
                message.username = data.username;
            }
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.orcid != null) {
                message.orcid = data.orcid;
            }
            if (data.organization != null) {
                message.organization = data.organization;
            }
            if (data.email != null) {
                message.email = data.email;
            }
            return message;
        }
        toObject() {
            const data: {
                username?: string;
                name?: string;
                orcid?: string;
                organization?: string;
                email?: string;
            } = {};
            if (this.username != null) {
                data.username = this.username;
            }
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.orcid != null) {
                data.orcid = this.orcid;
            }
            if (this.organization != null) {
                data.organization = this.organization;
            }
            if (this.email != null) {
                data.email = this.email;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.username.length)
                writer.writeString(1, this.username);
            if (this.name.length)
                writer.writeString(2, this.name);
            if (this.orcid.length)
                writer.writeString(3, this.orcid);
            if (this.organization.length)
                writer.writeString(4, this.organization);
            if (this.email.length)
                writer.writeString(5, this.email);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Person {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Person();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.username = reader.readString();
                        break;
                    case 2:
                        message.name = reader.readString();
                        break;
                    case 3:
                        message.orcid = reader.readString();
                        break;
                    case 4:
                        message.organization = reader.readString();
                        break;
                    case 5:
                        message.email = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Person {
            return Person.deserialize(bytes);
        }
    }
    export class RecordEvent extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            time?: DateTime;
            person?: Person;
            details?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("time" in data && data.time != undefined) {
                    this.time = data.time;
                }
                if ("person" in data && data.person != undefined) {
                    this.person = data.person;
                }
                if ("details" in data && data.details != undefined) {
                    this.details = data.details;
                }
            }
        }
        get time() {
            return pb_1.Message.getWrapperField(this, DateTime, 1) as DateTime;
        }
        set time(value: DateTime) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_time() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get person() {
            return pb_1.Message.getWrapperField(this, Person, 2) as Person;
        }
        set person(value: Person) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_person() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get details() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set details(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            time?: ReturnType<typeof DateTime.prototype.toObject>;
            person?: ReturnType<typeof Person.prototype.toObject>;
            details?: string;
        }): RecordEvent {
            const message = new RecordEvent({});
            if (data.time != null) {
                message.time = DateTime.fromObject(data.time);
            }
            if (data.person != null) {
                message.person = Person.fromObject(data.person);
            }
            if (data.details != null) {
                message.details = data.details;
            }
            return message;
        }
        toObject() {
            const data: {
                time?: ReturnType<typeof DateTime.prototype.toObject>;
                person?: ReturnType<typeof Person.prototype.toObject>;
                details?: string;
            } = {};
            if (this.time != null) {
                data.time = this.time.toObject();
            }
            if (this.person != null) {
                data.person = this.person.toObject();
            }
            if (this.details != null) {
                data.details = this.details;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_time)
                writer.writeMessage(1, this.time, () => this.time.serialize(writer));
            if (this.has_person)
                writer.writeMessage(2, this.person, () => this.person.serialize(writer));
            if (this.details.length)
                writer.writeString(3, this.details);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RecordEvent {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RecordEvent();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.time, () => message.time = DateTime.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.person, () => message.person = Person.deserialize(reader));
                        break;
                    case 3:
                        message.details = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): RecordEvent {
            return RecordEvent.deserialize(bytes);
        }
    }
    export class Time extends pb_1.Message {
        #one_of_decls: number[][] = [[1], [2]];
        constructor(data?: any[] | ({
            units?: Time.TimeUnit;
        } & (({
            value?: number;
        }) | ({
            precision?: number;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
                if ("precision" in data && data.precision != undefined) {
                    this.precision = data.precision;
                }
                if ("units" in data && data.units != undefined) {
                    this.units = data.units;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set value(value: number) {
            pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
        }
        get has_value() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get precision() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set precision(value: number) {
            pb_1.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
        }
        get has_precision() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get units() {
            return pb_1.Message.getFieldWithDefault(this, 3, Time.TimeUnit.UNSPECIFIED) as Time.TimeUnit;
        }
        set units(value: Time.TimeUnit) {
            pb_1.Message.setField(this, 3, value);
        }
        get _value() {
            const cases: {
                [index: number]: "none" | "value";
            } = {
                0: "none",
                1: "value"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        get _precision() {
            const cases: {
                [index: number]: "none" | "precision";
            } = {
                0: "none",
                2: "precision"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        static fromObject(data: {
            value?: number;
            precision?: number;
            units?: Time.TimeUnit;
        }): Time {
            const message = new Time({});
            if (data.value != null) {
                message.value = data.value;
            }
            if (data.precision != null) {
                message.precision = data.precision;
            }
            if (data.units != null) {
                message.units = data.units;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: number;
                precision?: number;
                units?: Time.TimeUnit;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            if (this.precision != null) {
                data.precision = this.precision;
            }
            if (this.units != null) {
                data.units = this.units;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_value)
                writer.writeFloat(1, this.value);
            if (this.has_precision)
                writer.writeFloat(2, this.precision);
            if (this.units != Time.TimeUnit.UNSPECIFIED)
                writer.writeEnum(3, this.units);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Time {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Time();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readFloat();
                        break;
                    case 2:
                        message.precision = reader.readFloat();
                        break;
                    case 3:
                        message.units = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Time {
            return Time.deserialize(bytes);
        }
    }
    export namespace Time {
        export enum TimeUnit {
            UNSPECIFIED = 0,
            DAY = 4,
            HOUR = 1,
            MINUTE = 2,
            SECOND = 3
        }
    }
    export class Mass extends pb_1.Message {
        #one_of_decls: number[][] = [[1], [2]];
        constructor(data?: any[] | ({
            units?: Mass.MassUnit;
        } & (({
            value?: number;
        }) | ({
            precision?: number;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
                if ("precision" in data && data.precision != undefined) {
                    this.precision = data.precision;
                }
                if ("units" in data && data.units != undefined) {
                    this.units = data.units;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set value(value: number) {
            pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
        }
        get has_value() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get precision() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set precision(value: number) {
            pb_1.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
        }
        get has_precision() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get units() {
            return pb_1.Message.getFieldWithDefault(this, 3, Mass.MassUnit.UNSPECIFIED) as Mass.MassUnit;
        }
        set units(value: Mass.MassUnit) {
            pb_1.Message.setField(this, 3, value);
        }
        get _value() {
            const cases: {
                [index: number]: "none" | "value";
            } = {
                0: "none",
                1: "value"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        get _precision() {
            const cases: {
                [index: number]: "none" | "precision";
            } = {
                0: "none",
                2: "precision"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        static fromObject(data: {
            value?: number;
            precision?: number;
            units?: Mass.MassUnit;
        }): Mass {
            const message = new Mass({});
            if (data.value != null) {
                message.value = data.value;
            }
            if (data.precision != null) {
                message.precision = data.precision;
            }
            if (data.units != null) {
                message.units = data.units;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: number;
                precision?: number;
                units?: Mass.MassUnit;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            if (this.precision != null) {
                data.precision = this.precision;
            }
            if (this.units != null) {
                data.units = this.units;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_value)
                writer.writeFloat(1, this.value);
            if (this.has_precision)
                writer.writeFloat(2, this.precision);
            if (this.units != Mass.MassUnit.UNSPECIFIED)
                writer.writeEnum(3, this.units);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Mass {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Mass();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readFloat();
                        break;
                    case 2:
                        message.precision = reader.readFloat();
                        break;
                    case 3:
                        message.units = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Mass {
            return Mass.deserialize(bytes);
        }
    }
    export namespace Mass {
        export enum MassUnit {
            UNSPECIFIED = 0,
            KILOGRAM = 1,
            GRAM = 2,
            MILLIGRAM = 3,
            MICROGRAM = 4
        }
    }
    export class Moles extends pb_1.Message {
        #one_of_decls: number[][] = [[1], [2]];
        constructor(data?: any[] | ({
            units?: Moles.MolesUnit;
        } & (({
            value?: number;
        }) | ({
            precision?: number;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
                if ("precision" in data && data.precision != undefined) {
                    this.precision = data.precision;
                }
                if ("units" in data && data.units != undefined) {
                    this.units = data.units;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set value(value: number) {
            pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
        }
        get has_value() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get precision() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set precision(value: number) {
            pb_1.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
        }
        get has_precision() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get units() {
            return pb_1.Message.getFieldWithDefault(this, 3, Moles.MolesUnit.UNSPECIFIED) as Moles.MolesUnit;
        }
        set units(value: Moles.MolesUnit) {
            pb_1.Message.setField(this, 3, value);
        }
        get _value() {
            const cases: {
                [index: number]: "none" | "value";
            } = {
                0: "none",
                1: "value"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        get _precision() {
            const cases: {
                [index: number]: "none" | "precision";
            } = {
                0: "none",
                2: "precision"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        static fromObject(data: {
            value?: number;
            precision?: number;
            units?: Moles.MolesUnit;
        }): Moles {
            const message = new Moles({});
            if (data.value != null) {
                message.value = data.value;
            }
            if (data.precision != null) {
                message.precision = data.precision;
            }
            if (data.units != null) {
                message.units = data.units;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: number;
                precision?: number;
                units?: Moles.MolesUnit;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            if (this.precision != null) {
                data.precision = this.precision;
            }
            if (this.units != null) {
                data.units = this.units;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_value)
                writer.writeFloat(1, this.value);
            if (this.has_precision)
                writer.writeFloat(2, this.precision);
            if (this.units != Moles.MolesUnit.UNSPECIFIED)
                writer.writeEnum(3, this.units);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Moles {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Moles();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readFloat();
                        break;
                    case 2:
                        message.precision = reader.readFloat();
                        break;
                    case 3:
                        message.units = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Moles {
            return Moles.deserialize(bytes);
        }
    }
    export namespace Moles {
        export enum MolesUnit {
            UNSPECIFIED = 0,
            MOLE = 1,
            MILLIMOLE = 2,
            MICROMOLE = 3,
            NANOMOLE = 4
        }
    }
    export class Volume extends pb_1.Message {
        #one_of_decls: number[][] = [[1], [2]];
        constructor(data?: any[] | ({
            units?: Volume.VolumeUnit;
        } & (({
            value?: number;
        }) | ({
            precision?: number;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
                if ("precision" in data && data.precision != undefined) {
                    this.precision = data.precision;
                }
                if ("units" in data && data.units != undefined) {
                    this.units = data.units;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set value(value: number) {
            pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
        }
        get has_value() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get precision() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set precision(value: number) {
            pb_1.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
        }
        get has_precision() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get units() {
            return pb_1.Message.getFieldWithDefault(this, 3, Volume.VolumeUnit.UNSPECIFIED) as Volume.VolumeUnit;
        }
        set units(value: Volume.VolumeUnit) {
            pb_1.Message.setField(this, 3, value);
        }
        get _value() {
            const cases: {
                [index: number]: "none" | "value";
            } = {
                0: "none",
                1: "value"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        get _precision() {
            const cases: {
                [index: number]: "none" | "precision";
            } = {
                0: "none",
                2: "precision"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        static fromObject(data: {
            value?: number;
            precision?: number;
            units?: Volume.VolumeUnit;
        }): Volume {
            const message = new Volume({});
            if (data.value != null) {
                message.value = data.value;
            }
            if (data.precision != null) {
                message.precision = data.precision;
            }
            if (data.units != null) {
                message.units = data.units;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: number;
                precision?: number;
                units?: Volume.VolumeUnit;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            if (this.precision != null) {
                data.precision = this.precision;
            }
            if (this.units != null) {
                data.units = this.units;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_value)
                writer.writeFloat(1, this.value);
            if (this.has_precision)
                writer.writeFloat(2, this.precision);
            if (this.units != Volume.VolumeUnit.UNSPECIFIED)
                writer.writeEnum(3, this.units);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Volume {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Volume();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readFloat();
                        break;
                    case 2:
                        message.precision = reader.readFloat();
                        break;
                    case 3:
                        message.units = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Volume {
            return Volume.deserialize(bytes);
        }
    }
    export namespace Volume {
        export enum VolumeUnit {
            UNSPECIFIED = 0,
            LITER = 1,
            MILLILITER = 2,
            MICROLITER = 3,
            NANOLITER = 4
        }
    }
    export class Concentration extends pb_1.Message {
        #one_of_decls: number[][] = [[1], [2]];
        constructor(data?: any[] | ({
            units?: Concentration.ConcentrationUnit;
        } & (({
            value?: number;
        }) | ({
            precision?: number;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
                if ("precision" in data && data.precision != undefined) {
                    this.precision = data.precision;
                }
                if ("units" in data && data.units != undefined) {
                    this.units = data.units;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set value(value: number) {
            pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
        }
        get has_value() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get precision() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set precision(value: number) {
            pb_1.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
        }
        get has_precision() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get units() {
            return pb_1.Message.getFieldWithDefault(this, 3, Concentration.ConcentrationUnit.UNSPECIFIED) as Concentration.ConcentrationUnit;
        }
        set units(value: Concentration.ConcentrationUnit) {
            pb_1.Message.setField(this, 3, value);
        }
        get _value() {
            const cases: {
                [index: number]: "none" | "value";
            } = {
                0: "none",
                1: "value"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        get _precision() {
            const cases: {
                [index: number]: "none" | "precision";
            } = {
                0: "none",
                2: "precision"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        static fromObject(data: {
            value?: number;
            precision?: number;
            units?: Concentration.ConcentrationUnit;
        }): Concentration {
            const message = new Concentration({});
            if (data.value != null) {
                message.value = data.value;
            }
            if (data.precision != null) {
                message.precision = data.precision;
            }
            if (data.units != null) {
                message.units = data.units;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: number;
                precision?: number;
                units?: Concentration.ConcentrationUnit;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            if (this.precision != null) {
                data.precision = this.precision;
            }
            if (this.units != null) {
                data.units = this.units;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_value)
                writer.writeFloat(1, this.value);
            if (this.has_precision)
                writer.writeFloat(2, this.precision);
            if (this.units != Concentration.ConcentrationUnit.UNSPECIFIED)
                writer.writeEnum(3, this.units);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Concentration {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Concentration();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readFloat();
                        break;
                    case 2:
                        message.precision = reader.readFloat();
                        break;
                    case 3:
                        message.units = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Concentration {
            return Concentration.deserialize(bytes);
        }
    }
    export namespace Concentration {
        export enum ConcentrationUnit {
            UNSPECIFIED = 0,
            MOLAR = 1,
            MILLIMOLAR = 2,
            MICROMOLAR = 3
        }
    }
    export class Pressure extends pb_1.Message {
        #one_of_decls: number[][] = [[1], [2]];
        constructor(data?: any[] | ({
            units?: Pressure.PressureUnit;
        } & (({
            value?: number;
        }) | ({
            precision?: number;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
                if ("precision" in data && data.precision != undefined) {
                    this.precision = data.precision;
                }
                if ("units" in data && data.units != undefined) {
                    this.units = data.units;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set value(value: number) {
            pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
        }
        get has_value() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get precision() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set precision(value: number) {
            pb_1.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
        }
        get has_precision() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get units() {
            return pb_1.Message.getFieldWithDefault(this, 3, Pressure.PressureUnit.UNSPECIFIED) as Pressure.PressureUnit;
        }
        set units(value: Pressure.PressureUnit) {
            pb_1.Message.setField(this, 3, value);
        }
        get _value() {
            const cases: {
                [index: number]: "none" | "value";
            } = {
                0: "none",
                1: "value"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        get _precision() {
            const cases: {
                [index: number]: "none" | "precision";
            } = {
                0: "none",
                2: "precision"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        static fromObject(data: {
            value?: number;
            precision?: number;
            units?: Pressure.PressureUnit;
        }): Pressure {
            const message = new Pressure({});
            if (data.value != null) {
                message.value = data.value;
            }
            if (data.precision != null) {
                message.precision = data.precision;
            }
            if (data.units != null) {
                message.units = data.units;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: number;
                precision?: number;
                units?: Pressure.PressureUnit;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            if (this.precision != null) {
                data.precision = this.precision;
            }
            if (this.units != null) {
                data.units = this.units;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_value)
                writer.writeFloat(1, this.value);
            if (this.has_precision)
                writer.writeFloat(2, this.precision);
            if (this.units != Pressure.PressureUnit.UNSPECIFIED)
                writer.writeEnum(3, this.units);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Pressure {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Pressure();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readFloat();
                        break;
                    case 2:
                        message.precision = reader.readFloat();
                        break;
                    case 3:
                        message.units = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Pressure {
            return Pressure.deserialize(bytes);
        }
    }
    export namespace Pressure {
        export enum PressureUnit {
            UNSPECIFIED = 0,
            BAR = 1,
            ATMOSPHERE = 2,
            PSI = 3,
            KPSI = 4,
            PASCAL = 5,
            KILOPASCAL = 6,
            TORR = 7,
            MM_HG = 8
        }
    }
    export class Temperature extends pb_1.Message {
        #one_of_decls: number[][] = [[1], [2]];
        constructor(data?: any[] | ({
            units?: Temperature.TemperatureUnit;
        } & (({
            value?: number;
        }) | ({
            precision?: number;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
                if ("precision" in data && data.precision != undefined) {
                    this.precision = data.precision;
                }
                if ("units" in data && data.units != undefined) {
                    this.units = data.units;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set value(value: number) {
            pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
        }
        get has_value() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get precision() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set precision(value: number) {
            pb_1.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
        }
        get has_precision() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get units() {
            return pb_1.Message.getFieldWithDefault(this, 3, Temperature.TemperatureUnit.UNSPECIFIED) as Temperature.TemperatureUnit;
        }
        set units(value: Temperature.TemperatureUnit) {
            pb_1.Message.setField(this, 3, value);
        }
        get _value() {
            const cases: {
                [index: number]: "none" | "value";
            } = {
                0: "none",
                1: "value"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        get _precision() {
            const cases: {
                [index: number]: "none" | "precision";
            } = {
                0: "none",
                2: "precision"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        static fromObject(data: {
            value?: number;
            precision?: number;
            units?: Temperature.TemperatureUnit;
        }): Temperature {
            const message = new Temperature({});
            if (data.value != null) {
                message.value = data.value;
            }
            if (data.precision != null) {
                message.precision = data.precision;
            }
            if (data.units != null) {
                message.units = data.units;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: number;
                precision?: number;
                units?: Temperature.TemperatureUnit;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            if (this.precision != null) {
                data.precision = this.precision;
            }
            if (this.units != null) {
                data.units = this.units;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_value)
                writer.writeFloat(1, this.value);
            if (this.has_precision)
                writer.writeFloat(2, this.precision);
            if (this.units != Temperature.TemperatureUnit.UNSPECIFIED)
                writer.writeEnum(3, this.units);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Temperature {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Temperature();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readFloat();
                        break;
                    case 2:
                        message.precision = reader.readFloat();
                        break;
                    case 3:
                        message.units = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Temperature {
            return Temperature.deserialize(bytes);
        }
    }
    export namespace Temperature {
        export enum TemperatureUnit {
            UNSPECIFIED = 0,
            CELSIUS = 1,
            FAHRENHEIT = 2,
            KELVIN = 3
        }
    }
    export class Current extends pb_1.Message {
        #one_of_decls: number[][] = [[1], [2]];
        constructor(data?: any[] | ({
            units?: Current.CurrentUnit;
        } & (({
            value?: number;
        }) | ({
            precision?: number;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
                if ("precision" in data && data.precision != undefined) {
                    this.precision = data.precision;
                }
                if ("units" in data && data.units != undefined) {
                    this.units = data.units;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set value(value: number) {
            pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
        }
        get has_value() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get precision() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set precision(value: number) {
            pb_1.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
        }
        get has_precision() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get units() {
            return pb_1.Message.getFieldWithDefault(this, 3, Current.CurrentUnit.UNSPECIFIED) as Current.CurrentUnit;
        }
        set units(value: Current.CurrentUnit) {
            pb_1.Message.setField(this, 3, value);
        }
        get _value() {
            const cases: {
                [index: number]: "none" | "value";
            } = {
                0: "none",
                1: "value"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        get _precision() {
            const cases: {
                [index: number]: "none" | "precision";
            } = {
                0: "none",
                2: "precision"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        static fromObject(data: {
            value?: number;
            precision?: number;
            units?: Current.CurrentUnit;
        }): Current {
            const message = new Current({});
            if (data.value != null) {
                message.value = data.value;
            }
            if (data.precision != null) {
                message.precision = data.precision;
            }
            if (data.units != null) {
                message.units = data.units;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: number;
                precision?: number;
                units?: Current.CurrentUnit;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            if (this.precision != null) {
                data.precision = this.precision;
            }
            if (this.units != null) {
                data.units = this.units;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_value)
                writer.writeFloat(1, this.value);
            if (this.has_precision)
                writer.writeFloat(2, this.precision);
            if (this.units != Current.CurrentUnit.UNSPECIFIED)
                writer.writeEnum(3, this.units);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Current {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Current();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readFloat();
                        break;
                    case 2:
                        message.precision = reader.readFloat();
                        break;
                    case 3:
                        message.units = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Current {
            return Current.deserialize(bytes);
        }
    }
    export namespace Current {
        export enum CurrentUnit {
            UNSPECIFIED = 0,
            AMPERE = 1,
            MILLIAMPERE = 2
        }
    }
    export class Voltage extends pb_1.Message {
        #one_of_decls: number[][] = [[1], [2]];
        constructor(data?: any[] | ({
            units?: Voltage.VoltageUnit;
        } & (({
            value?: number;
        }) | ({
            precision?: number;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
                if ("precision" in data && data.precision != undefined) {
                    this.precision = data.precision;
                }
                if ("units" in data && data.units != undefined) {
                    this.units = data.units;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set value(value: number) {
            pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
        }
        get has_value() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get precision() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set precision(value: number) {
            pb_1.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
        }
        get has_precision() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get units() {
            return pb_1.Message.getFieldWithDefault(this, 3, Voltage.VoltageUnit.UNSPECIFIED) as Voltage.VoltageUnit;
        }
        set units(value: Voltage.VoltageUnit) {
            pb_1.Message.setField(this, 3, value);
        }
        get _value() {
            const cases: {
                [index: number]: "none" | "value";
            } = {
                0: "none",
                1: "value"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        get _precision() {
            const cases: {
                [index: number]: "none" | "precision";
            } = {
                0: "none",
                2: "precision"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        static fromObject(data: {
            value?: number;
            precision?: number;
            units?: Voltage.VoltageUnit;
        }): Voltage {
            const message = new Voltage({});
            if (data.value != null) {
                message.value = data.value;
            }
            if (data.precision != null) {
                message.precision = data.precision;
            }
            if (data.units != null) {
                message.units = data.units;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: number;
                precision?: number;
                units?: Voltage.VoltageUnit;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            if (this.precision != null) {
                data.precision = this.precision;
            }
            if (this.units != null) {
                data.units = this.units;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_value)
                writer.writeFloat(1, this.value);
            if (this.has_precision)
                writer.writeFloat(2, this.precision);
            if (this.units != Voltage.VoltageUnit.UNSPECIFIED)
                writer.writeEnum(3, this.units);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Voltage {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Voltage();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readFloat();
                        break;
                    case 2:
                        message.precision = reader.readFloat();
                        break;
                    case 3:
                        message.units = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Voltage {
            return Voltage.deserialize(bytes);
        }
    }
    export namespace Voltage {
        export enum VoltageUnit {
            UNSPECIFIED = 0,
            VOLT = 1,
            MILLIVOLT = 2
        }
    }
    export class Length extends pb_1.Message {
        #one_of_decls: number[][] = [[1], [2]];
        constructor(data?: any[] | ({
            units?: Length.LengthUnit;
        } & (({
            value?: number;
        }) | ({
            precision?: number;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
                if ("precision" in data && data.precision != undefined) {
                    this.precision = data.precision;
                }
                if ("units" in data && data.units != undefined) {
                    this.units = data.units;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set value(value: number) {
            pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
        }
        get has_value() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get precision() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set precision(value: number) {
            pb_1.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
        }
        get has_precision() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get units() {
            return pb_1.Message.getFieldWithDefault(this, 3, Length.LengthUnit.UNSPECIFIED) as Length.LengthUnit;
        }
        set units(value: Length.LengthUnit) {
            pb_1.Message.setField(this, 3, value);
        }
        get _value() {
            const cases: {
                [index: number]: "none" | "value";
            } = {
                0: "none",
                1: "value"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        get _precision() {
            const cases: {
                [index: number]: "none" | "precision";
            } = {
                0: "none",
                2: "precision"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        static fromObject(data: {
            value?: number;
            precision?: number;
            units?: Length.LengthUnit;
        }): Length {
            const message = new Length({});
            if (data.value != null) {
                message.value = data.value;
            }
            if (data.precision != null) {
                message.precision = data.precision;
            }
            if (data.units != null) {
                message.units = data.units;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: number;
                precision?: number;
                units?: Length.LengthUnit;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            if (this.precision != null) {
                data.precision = this.precision;
            }
            if (this.units != null) {
                data.units = this.units;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_value)
                writer.writeFloat(1, this.value);
            if (this.has_precision)
                writer.writeFloat(2, this.precision);
            if (this.units != Length.LengthUnit.UNSPECIFIED)
                writer.writeEnum(3, this.units);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Length {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Length();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readFloat();
                        break;
                    case 2:
                        message.precision = reader.readFloat();
                        break;
                    case 3:
                        message.units = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Length {
            return Length.deserialize(bytes);
        }
    }
    export namespace Length {
        export enum LengthUnit {
            UNSPECIFIED = 0,
            CENTIMETER = 1,
            MILLIMETER = 2,
            METER = 3,
            INCH = 4,
            FOOT = 5
        }
    }
    export class Wavelength extends pb_1.Message {
        #one_of_decls: number[][] = [[1], [2]];
        constructor(data?: any[] | ({
            units?: Wavelength.WavelengthUnit;
        } & (({
            value?: number;
        }) | ({
            precision?: number;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
                if ("precision" in data && data.precision != undefined) {
                    this.precision = data.precision;
                }
                if ("units" in data && data.units != undefined) {
                    this.units = data.units;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set value(value: number) {
            pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
        }
        get has_value() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get precision() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set precision(value: number) {
            pb_1.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
        }
        get has_precision() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get units() {
            return pb_1.Message.getFieldWithDefault(this, 3, Wavelength.WavelengthUnit.UNSPECIFIED) as Wavelength.WavelengthUnit;
        }
        set units(value: Wavelength.WavelengthUnit) {
            pb_1.Message.setField(this, 3, value);
        }
        get _value() {
            const cases: {
                [index: number]: "none" | "value";
            } = {
                0: "none",
                1: "value"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        get _precision() {
            const cases: {
                [index: number]: "none" | "precision";
            } = {
                0: "none",
                2: "precision"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        static fromObject(data: {
            value?: number;
            precision?: number;
            units?: Wavelength.WavelengthUnit;
        }): Wavelength {
            const message = new Wavelength({});
            if (data.value != null) {
                message.value = data.value;
            }
            if (data.precision != null) {
                message.precision = data.precision;
            }
            if (data.units != null) {
                message.units = data.units;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: number;
                precision?: number;
                units?: Wavelength.WavelengthUnit;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            if (this.precision != null) {
                data.precision = this.precision;
            }
            if (this.units != null) {
                data.units = this.units;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_value)
                writer.writeFloat(1, this.value);
            if (this.has_precision)
                writer.writeFloat(2, this.precision);
            if (this.units != Wavelength.WavelengthUnit.UNSPECIFIED)
                writer.writeEnum(3, this.units);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Wavelength {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Wavelength();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readFloat();
                        break;
                    case 2:
                        message.precision = reader.readFloat();
                        break;
                    case 3:
                        message.units = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Wavelength {
            return Wavelength.deserialize(bytes);
        }
    }
    export namespace Wavelength {
        export enum WavelengthUnit {
            UNSPECIFIED = 0,
            NANOMETER = 1,
            WAVENUMBER = 2
        }
    }
    export class FlowRate extends pb_1.Message {
        #one_of_decls: number[][] = [[1], [2]];
        constructor(data?: any[] | ({
            units?: FlowRate.FlowRateUnit;
        } & (({
            value?: number;
        }) | ({
            precision?: number;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
                if ("precision" in data && data.precision != undefined) {
                    this.precision = data.precision;
                }
                if ("units" in data && data.units != undefined) {
                    this.units = data.units;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set value(value: number) {
            pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
        }
        get has_value() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get precision() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set precision(value: number) {
            pb_1.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
        }
        get has_precision() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get units() {
            return pb_1.Message.getFieldWithDefault(this, 3, FlowRate.FlowRateUnit.UNSPECIFIED) as FlowRate.FlowRateUnit;
        }
        set units(value: FlowRate.FlowRateUnit) {
            pb_1.Message.setField(this, 3, value);
        }
        get _value() {
            const cases: {
                [index: number]: "none" | "value";
            } = {
                0: "none",
                1: "value"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        get _precision() {
            const cases: {
                [index: number]: "none" | "precision";
            } = {
                0: "none",
                2: "precision"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        static fromObject(data: {
            value?: number;
            precision?: number;
            units?: FlowRate.FlowRateUnit;
        }): FlowRate {
            const message = new FlowRate({});
            if (data.value != null) {
                message.value = data.value;
            }
            if (data.precision != null) {
                message.precision = data.precision;
            }
            if (data.units != null) {
                message.units = data.units;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: number;
                precision?: number;
                units?: FlowRate.FlowRateUnit;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            if (this.precision != null) {
                data.precision = this.precision;
            }
            if (this.units != null) {
                data.units = this.units;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_value)
                writer.writeFloat(1, this.value);
            if (this.has_precision)
                writer.writeFloat(2, this.precision);
            if (this.units != FlowRate.FlowRateUnit.UNSPECIFIED)
                writer.writeEnum(3, this.units);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FlowRate {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FlowRate();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readFloat();
                        break;
                    case 2:
                        message.precision = reader.readFloat();
                        break;
                    case 3:
                        message.units = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FlowRate {
            return FlowRate.deserialize(bytes);
        }
    }
    export namespace FlowRate {
        export enum FlowRateUnit {
            UNSPECIFIED = 0,
            MICROLITER_PER_MINUTE = 1,
            MICROLITER_PER_SECOND = 2,
            MILLILITER_PER_MINUTE = 3,
            MILLILITER_PER_SECOND = 4,
            MICROLITER_PER_HOUR = 5
        }
    }
    export class Percentage extends pb_1.Message {
        #one_of_decls: number[][] = [[1], [2]];
        constructor(data?: any[] | ({} & (({
            value?: number;
        }) | ({
            precision?: number;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
                if ("precision" in data && data.precision != undefined) {
                    this.precision = data.precision;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set value(value: number) {
            pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
        }
        get has_value() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get precision() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set precision(value: number) {
            pb_1.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
        }
        get has_precision() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get _value() {
            const cases: {
                [index: number]: "none" | "value";
            } = {
                0: "none",
                1: "value"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        get _precision() {
            const cases: {
                [index: number]: "none" | "precision";
            } = {
                0: "none",
                2: "precision"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        static fromObject(data: {
            value?: number;
            precision?: number;
        }): Percentage {
            const message = new Percentage({});
            if (data.value != null) {
                message.value = data.value;
            }
            if (data.precision != null) {
                message.precision = data.precision;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: number;
                precision?: number;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            if (this.precision != null) {
                data.precision = this.precision;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_value)
                writer.writeFloat(1, this.value);
            if (this.has_precision)
                writer.writeFloat(2, this.precision);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Percentage {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Percentage();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readFloat();
                        break;
                    case 2:
                        message.precision = reader.readFloat();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Percentage {
            return Percentage.deserialize(bytes);
        }
    }
    export class FloatValue extends pb_1.Message {
        #one_of_decls: number[][] = [[1], [2]];
        constructor(data?: any[] | ({} & (({
            value?: number;
        }) | ({
            precision?: number;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
                if ("precision" in data && data.precision != undefined) {
                    this.precision = data.precision;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set value(value: number) {
            pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
        }
        get has_value() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get precision() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set precision(value: number) {
            pb_1.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
        }
        get has_precision() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get _value() {
            const cases: {
                [index: number]: "none" | "value";
            } = {
                0: "none",
                1: "value"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        get _precision() {
            const cases: {
                [index: number]: "none" | "precision";
            } = {
                0: "none",
                2: "precision"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        static fromObject(data: {
            value?: number;
            precision?: number;
        }): FloatValue {
            const message = new FloatValue({});
            if (data.value != null) {
                message.value = data.value;
            }
            if (data.precision != null) {
                message.precision = data.precision;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: number;
                precision?: number;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            if (this.precision != null) {
                data.precision = this.precision;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_value)
                writer.writeFloat(1, this.value);
            if (this.has_precision)
                writer.writeFloat(2, this.precision);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FloatValue {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FloatValue();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readFloat();
                        break;
                    case 2:
                        message.precision = reader.readFloat();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FloatValue {
            return FloatValue.deserialize(bytes);
        }
    }
    export class Data extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2, 3, 4, 5]];
        constructor(data?: any[] | ({
            description?: string;
            format?: string;
        } & (({
            float_value?: number;
            integer_value?: never;
            bytes_value?: never;
            string_value?: never;
            url?: never;
        } | {
            float_value?: never;
            integer_value?: number;
            bytes_value?: never;
            string_value?: never;
            url?: never;
        } | {
            float_value?: never;
            integer_value?: never;
            bytes_value?: Uint8Array;
            string_value?: never;
            url?: never;
        } | {
            float_value?: never;
            integer_value?: never;
            bytes_value?: never;
            string_value?: string;
            url?: never;
        } | {
            float_value?: never;
            integer_value?: never;
            bytes_value?: never;
            string_value?: never;
            url?: string;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("float_value" in data && data.float_value != undefined) {
                    this.float_value = data.float_value;
                }
                if ("integer_value" in data && data.integer_value != undefined) {
                    this.integer_value = data.integer_value;
                }
                if ("bytes_value" in data && data.bytes_value != undefined) {
                    this.bytes_value = data.bytes_value;
                }
                if ("string_value" in data && data.string_value != undefined) {
                    this.string_value = data.string_value;
                }
                if ("url" in data && data.url != undefined) {
                    this.url = data.url;
                }
                if ("description" in data && data.description != undefined) {
                    this.description = data.description;
                }
                if ("format" in data && data.format != undefined) {
                    this.format = data.format;
                }
            }
        }
        get float_value() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set float_value(value: number) {
            pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
        }
        get has_float_value() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get integer_value() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set integer_value(value: number) {
            pb_1.Message.setOneofField(this, 2, this.#one_of_decls[0], value);
        }
        get has_integer_value() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get bytes_value() {
            return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array(0)) as Uint8Array;
        }
        set bytes_value(value: Uint8Array) {
            pb_1.Message.setOneofField(this, 3, this.#one_of_decls[0], value);
        }
        get has_bytes_value() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get string_value() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set string_value(value: string) {
            pb_1.Message.setOneofField(this, 4, this.#one_of_decls[0], value);
        }
        get has_string_value() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get url() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        set url(value: string) {
            pb_1.Message.setOneofField(this, 5, this.#one_of_decls[0], value);
        }
        get has_url() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get description() {
            return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
        }
        set description(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        get format() {
            return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
        }
        set format(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        get kind() {
            const cases: {
                [index: number]: "none" | "float_value" | "integer_value" | "bytes_value" | "string_value" | "url";
            } = {
                0: "none",
                1: "float_value",
                2: "integer_value",
                3: "bytes_value",
                4: "string_value",
                5: "url"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3, 4, 5])];
        }
        static fromObject(data: {
            float_value?: number;
            integer_value?: number;
            bytes_value?: Uint8Array;
            string_value?: string;
            url?: string;
            description?: string;
            format?: string;
        }): Data {
            const message = new Data({});
            if (data.float_value != null) {
                message.float_value = data.float_value;
            }
            if (data.integer_value != null) {
                message.integer_value = data.integer_value;
            }
            if (data.bytes_value != null) {
                message.bytes_value = data.bytes_value;
            }
            if (data.string_value != null) {
                message.string_value = data.string_value;
            }
            if (data.url != null) {
                message.url = data.url;
            }
            if (data.description != null) {
                message.description = data.description;
            }
            if (data.format != null) {
                message.format = data.format;
            }
            return message;
        }
        toObject() {
            const data: {
                float_value?: number;
                integer_value?: number;
                bytes_value?: Uint8Array;
                string_value?: string;
                url?: string;
                description?: string;
                format?: string;
            } = {};
            if (this.float_value != null) {
                data.float_value = this.float_value;
            }
            if (this.integer_value != null) {
                data.integer_value = this.integer_value;
            }
            if (this.bytes_value != null) {
                data.bytes_value = this.bytes_value;
            }
            if (this.string_value != null) {
                data.string_value = this.string_value;
            }
            if (this.url != null) {
                data.url = this.url;
            }
            if (this.description != null) {
                data.description = this.description;
            }
            if (this.format != null) {
                data.format = this.format;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_float_value)
                writer.writeFloat(1, this.float_value);
            if (this.has_integer_value)
                writer.writeInt32(2, this.integer_value);
            if (this.has_bytes_value)
                writer.writeBytes(3, this.bytes_value);
            if (this.has_string_value)
                writer.writeString(4, this.string_value);
            if (this.has_url)
                writer.writeString(5, this.url);
            if (this.description.length)
                writer.writeString(6, this.description);
            if (this.format.length)
                writer.writeString(7, this.format);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Data {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Data();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.float_value = reader.readFloat();
                        break;
                    case 2:
                        message.integer_value = reader.readInt32();
                        break;
                    case 3:
                        message.bytes_value = reader.readBytes();
                        break;
                    case 4:
                        message.string_value = reader.readString();
                        break;
                    case 5:
                        message.url = reader.readString();
                        break;
                    case 6:
                        message.description = reader.readString();
                        break;
                    case 7:
                        message.format = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Data {
            return Data.deserialize(bytes);
        }
    }
}
