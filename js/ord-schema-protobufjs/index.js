/**
 * Copyright 2025 Open Reaction Database Project Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const ord = $root.ord = (() => {

    /**
     * Namespace ord.
     * @exports ord
     * @namespace
     */
    const ord = {};

    ord.Reaction = (function() {

        /**
         * Properties of a Reaction.
         * @memberof ord
         * @interface IReaction
         * @property {Array.<ord.IReactionIdentifier>|null} [identifiers] Reaction identifiers
         * @property {Object.<string,ord.IReactionInput>|null} [inputs] Reaction inputs
         * @property {ord.IReactionSetup|null} [setup] Reaction setup
         * @property {ord.IReactionConditions|null} [conditions] Reaction conditions
         * @property {ord.IReactionNotes|null} [notes] Reaction notes
         * @property {Array.<ord.IReactionObservation>|null} [observations] Reaction observations
         * @property {Array.<ord.IReactionWorkup>|null} [workups] Reaction workups
         * @property {Array.<ord.IReactionOutcome>|null} [outcomes] Reaction outcomes
         * @property {ord.IReactionProvenance|null} [provenance] Reaction provenance
         * @property {string|null} [reactionId] Reaction reactionId
         */

        /**
         * Constructs a new Reaction.
         * @memberof ord
         * @classdesc Throughout this schema, we introduce enums to encourage consistency in
         * nomenclature and to avoid unnecessary downstream data processing that would
         * otherwise be required to consolidate equivalent entries. However, we do
         * not wish to restrict what users are able to specify if their synthesis
         * does not fit cleanly into a pre-existing enum field. For that reason, many
         * enums contain a CUSTOM field, which must be accompanied by setting the
         * 'details' field, where appropriate).
         * 
         * NOTE(kearnes): In many places, we deliberately violate the style guide for
         * enums by nesting instead of prefixing; this is not done lightly. The primary
         * consideration is API consistency and the ability to use unqualified strings
         * as enum values. For instance, we want 'CUSTOM' to be a valid value for all
         * enums that support custom types.
         * @implements IReaction
         * @constructor
         * @param {ord.IReaction=} [properties] Properties to set
         */
        function Reaction(properties) {
            this.identifiers = [];
            this.inputs = {};
            this.observations = [];
            this.workups = [];
            this.outcomes = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Reaction identifiers.
         * @member {Array.<ord.IReactionIdentifier>} identifiers
         * @memberof ord.Reaction
         * @instance
         */
        Reaction.prototype.identifiers = $util.emptyArray;

        /**
         * Reaction inputs.
         * @member {Object.<string,ord.IReactionInput>} inputs
         * @memberof ord.Reaction
         * @instance
         */
        Reaction.prototype.inputs = $util.emptyObject;

        /**
         * Reaction setup.
         * @member {ord.IReactionSetup|null|undefined} setup
         * @memberof ord.Reaction
         * @instance
         */
        Reaction.prototype.setup = null;

        /**
         * Reaction conditions.
         * @member {ord.IReactionConditions|null|undefined} conditions
         * @memberof ord.Reaction
         * @instance
         */
        Reaction.prototype.conditions = null;

        /**
         * Reaction notes.
         * @member {ord.IReactionNotes|null|undefined} notes
         * @memberof ord.Reaction
         * @instance
         */
        Reaction.prototype.notes = null;

        /**
         * Reaction observations.
         * @member {Array.<ord.IReactionObservation>} observations
         * @memberof ord.Reaction
         * @instance
         */
        Reaction.prototype.observations = $util.emptyArray;

        /**
         * Reaction workups.
         * @member {Array.<ord.IReactionWorkup>} workups
         * @memberof ord.Reaction
         * @instance
         */
        Reaction.prototype.workups = $util.emptyArray;

        /**
         * Reaction outcomes.
         * @member {Array.<ord.IReactionOutcome>} outcomes
         * @memberof ord.Reaction
         * @instance
         */
        Reaction.prototype.outcomes = $util.emptyArray;

        /**
         * Reaction provenance.
         * @member {ord.IReactionProvenance|null|undefined} provenance
         * @memberof ord.Reaction
         * @instance
         */
        Reaction.prototype.provenance = null;

        /**
         * Reaction reactionId.
         * @member {string} reactionId
         * @memberof ord.Reaction
         * @instance
         */
        Reaction.prototype.reactionId = "";

        /**
         * Creates a new Reaction instance using the specified properties.
         * @function create
         * @memberof ord.Reaction
         * @static
         * @param {ord.IReaction=} [properties] Properties to set
         * @returns {ord.Reaction} Reaction instance
         */
        Reaction.create = function create(properties) {
            return new Reaction(properties);
        };

        /**
         * Encodes the specified Reaction message. Does not implicitly {@link ord.Reaction.verify|verify} messages.
         * @function encode
         * @memberof ord.Reaction
         * @static
         * @param {ord.IReaction} message Reaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Reaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.identifiers != null && message.identifiers.length)
                for (let i = 0; i < message.identifiers.length; ++i)
                    $root.ord.ReactionIdentifier.encode(message.identifiers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.inputs != null && Object.hasOwnProperty.call(message, "inputs"))
                for (let keys = Object.keys(message.inputs), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.ord.ReactionInput.encode(message.inputs[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.setup != null && Object.hasOwnProperty.call(message, "setup"))
                $root.ord.ReactionSetup.encode(message.setup, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.conditions != null && Object.hasOwnProperty.call(message, "conditions"))
                $root.ord.ReactionConditions.encode(message.conditions, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.notes != null && Object.hasOwnProperty.call(message, "notes"))
                $root.ord.ReactionNotes.encode(message.notes, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.observations != null && message.observations.length)
                for (let i = 0; i < message.observations.length; ++i)
                    $root.ord.ReactionObservation.encode(message.observations[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.workups != null && message.workups.length)
                for (let i = 0; i < message.workups.length; ++i)
                    $root.ord.ReactionWorkup.encode(message.workups[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.outcomes != null && message.outcomes.length)
                for (let i = 0; i < message.outcomes.length; ++i)
                    $root.ord.ReactionOutcome.encode(message.outcomes[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.provenance != null && Object.hasOwnProperty.call(message, "provenance"))
                $root.ord.ReactionProvenance.encode(message.provenance, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.reactionId != null && Object.hasOwnProperty.call(message, "reactionId"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.reactionId);
            return writer;
        };

        /**
         * Encodes the specified Reaction message, length delimited. Does not implicitly {@link ord.Reaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.Reaction
         * @static
         * @param {ord.IReaction} message Reaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Reaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Reaction message from the specified reader or buffer.
         * @function decode
         * @memberof ord.Reaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.Reaction} Reaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Reaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.Reaction(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.identifiers && message.identifiers.length))
                            message.identifiers = [];
                        message.identifiers.push($root.ord.ReactionIdentifier.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        if (message.inputs === $util.emptyObject)
                            message.inputs = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.ord.ReactionInput.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.inputs[key] = value;
                        break;
                    }
                case 3: {
                        message.setup = $root.ord.ReactionSetup.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.conditions = $root.ord.ReactionConditions.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.notes = $root.ord.ReactionNotes.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        if (!(message.observations && message.observations.length))
                            message.observations = [];
                        message.observations.push($root.ord.ReactionObservation.decode(reader, reader.uint32()));
                        break;
                    }
                case 7: {
                        if (!(message.workups && message.workups.length))
                            message.workups = [];
                        message.workups.push($root.ord.ReactionWorkup.decode(reader, reader.uint32()));
                        break;
                    }
                case 8: {
                        if (!(message.outcomes && message.outcomes.length))
                            message.outcomes = [];
                        message.outcomes.push($root.ord.ReactionOutcome.decode(reader, reader.uint32()));
                        break;
                    }
                case 9: {
                        message.provenance = $root.ord.ReactionProvenance.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.reactionId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Reaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.Reaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.Reaction} Reaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Reaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Reaction message.
         * @function verify
         * @memberof ord.Reaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Reaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.identifiers != null && message.hasOwnProperty("identifiers")) {
                if (!Array.isArray(message.identifiers))
                    return "identifiers: array expected";
                for (let i = 0; i < message.identifiers.length; ++i) {
                    let error = $root.ord.ReactionIdentifier.verify(message.identifiers[i]);
                    if (error)
                        return "identifiers." + error;
                }
            }
            if (message.inputs != null && message.hasOwnProperty("inputs")) {
                if (!$util.isObject(message.inputs))
                    return "inputs: object expected";
                let key = Object.keys(message.inputs);
                for (let i = 0; i < key.length; ++i) {
                    let error = $root.ord.ReactionInput.verify(message.inputs[key[i]]);
                    if (error)
                        return "inputs." + error;
                }
            }
            if (message.setup != null && message.hasOwnProperty("setup")) {
                let error = $root.ord.ReactionSetup.verify(message.setup);
                if (error)
                    return "setup." + error;
            }
            if (message.conditions != null && message.hasOwnProperty("conditions")) {
                let error = $root.ord.ReactionConditions.verify(message.conditions);
                if (error)
                    return "conditions." + error;
            }
            if (message.notes != null && message.hasOwnProperty("notes")) {
                let error = $root.ord.ReactionNotes.verify(message.notes);
                if (error)
                    return "notes." + error;
            }
            if (message.observations != null && message.hasOwnProperty("observations")) {
                if (!Array.isArray(message.observations))
                    return "observations: array expected";
                for (let i = 0; i < message.observations.length; ++i) {
                    let error = $root.ord.ReactionObservation.verify(message.observations[i]);
                    if (error)
                        return "observations." + error;
                }
            }
            if (message.workups != null && message.hasOwnProperty("workups")) {
                if (!Array.isArray(message.workups))
                    return "workups: array expected";
                for (let i = 0; i < message.workups.length; ++i) {
                    let error = $root.ord.ReactionWorkup.verify(message.workups[i]);
                    if (error)
                        return "workups." + error;
                }
            }
            if (message.outcomes != null && message.hasOwnProperty("outcomes")) {
                if (!Array.isArray(message.outcomes))
                    return "outcomes: array expected";
                for (let i = 0; i < message.outcomes.length; ++i) {
                    let error = $root.ord.ReactionOutcome.verify(message.outcomes[i]);
                    if (error)
                        return "outcomes." + error;
                }
            }
            if (message.provenance != null && message.hasOwnProperty("provenance")) {
                let error = $root.ord.ReactionProvenance.verify(message.provenance);
                if (error)
                    return "provenance." + error;
            }
            if (message.reactionId != null && message.hasOwnProperty("reactionId"))
                if (!$util.isString(message.reactionId))
                    return "reactionId: string expected";
            return null;
        };

        /**
         * Creates a Reaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.Reaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.Reaction} Reaction
         */
        Reaction.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.Reaction)
                return object;
            let message = new $root.ord.Reaction();
            if (object.identifiers) {
                if (!Array.isArray(object.identifiers))
                    throw TypeError(".ord.Reaction.identifiers: array expected");
                message.identifiers = [];
                for (let i = 0; i < object.identifiers.length; ++i) {
                    if (typeof object.identifiers[i] !== "object")
                        throw TypeError(".ord.Reaction.identifiers: object expected");
                    message.identifiers[i] = $root.ord.ReactionIdentifier.fromObject(object.identifiers[i]);
                }
            }
            if (object.inputs) {
                if (typeof object.inputs !== "object")
                    throw TypeError(".ord.Reaction.inputs: object expected");
                message.inputs = {};
                for (let keys = Object.keys(object.inputs), i = 0; i < keys.length; ++i) {
                    if (typeof object.inputs[keys[i]] !== "object")
                        throw TypeError(".ord.Reaction.inputs: object expected");
                    message.inputs[keys[i]] = $root.ord.ReactionInput.fromObject(object.inputs[keys[i]]);
                }
            }
            if (object.setup != null) {
                if (typeof object.setup !== "object")
                    throw TypeError(".ord.Reaction.setup: object expected");
                message.setup = $root.ord.ReactionSetup.fromObject(object.setup);
            }
            if (object.conditions != null) {
                if (typeof object.conditions !== "object")
                    throw TypeError(".ord.Reaction.conditions: object expected");
                message.conditions = $root.ord.ReactionConditions.fromObject(object.conditions);
            }
            if (object.notes != null) {
                if (typeof object.notes !== "object")
                    throw TypeError(".ord.Reaction.notes: object expected");
                message.notes = $root.ord.ReactionNotes.fromObject(object.notes);
            }
            if (object.observations) {
                if (!Array.isArray(object.observations))
                    throw TypeError(".ord.Reaction.observations: array expected");
                message.observations = [];
                for (let i = 0; i < object.observations.length; ++i) {
                    if (typeof object.observations[i] !== "object")
                        throw TypeError(".ord.Reaction.observations: object expected");
                    message.observations[i] = $root.ord.ReactionObservation.fromObject(object.observations[i]);
                }
            }
            if (object.workups) {
                if (!Array.isArray(object.workups))
                    throw TypeError(".ord.Reaction.workups: array expected");
                message.workups = [];
                for (let i = 0; i < object.workups.length; ++i) {
                    if (typeof object.workups[i] !== "object")
                        throw TypeError(".ord.Reaction.workups: object expected");
                    message.workups[i] = $root.ord.ReactionWorkup.fromObject(object.workups[i]);
                }
            }
            if (object.outcomes) {
                if (!Array.isArray(object.outcomes))
                    throw TypeError(".ord.Reaction.outcomes: array expected");
                message.outcomes = [];
                for (let i = 0; i < object.outcomes.length; ++i) {
                    if (typeof object.outcomes[i] !== "object")
                        throw TypeError(".ord.Reaction.outcomes: object expected");
                    message.outcomes[i] = $root.ord.ReactionOutcome.fromObject(object.outcomes[i]);
                }
            }
            if (object.provenance != null) {
                if (typeof object.provenance !== "object")
                    throw TypeError(".ord.Reaction.provenance: object expected");
                message.provenance = $root.ord.ReactionProvenance.fromObject(object.provenance);
            }
            if (object.reactionId != null)
                message.reactionId = String(object.reactionId);
            return message;
        };

        /**
         * Creates a plain object from a Reaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.Reaction
         * @static
         * @param {ord.Reaction} message Reaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Reaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.identifiers = [];
                object.observations = [];
                object.workups = [];
                object.outcomes = [];
            }
            if (options.objects || options.defaults)
                object.inputs = {};
            if (options.defaults) {
                object.setup = null;
                object.conditions = null;
                object.notes = null;
                object.provenance = null;
                object.reactionId = "";
            }
            if (message.identifiers && message.identifiers.length) {
                object.identifiers = [];
                for (let j = 0; j < message.identifiers.length; ++j)
                    object.identifiers[j] = $root.ord.ReactionIdentifier.toObject(message.identifiers[j], options);
            }
            let keys2;
            if (message.inputs && (keys2 = Object.keys(message.inputs)).length) {
                object.inputs = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.inputs[keys2[j]] = $root.ord.ReactionInput.toObject(message.inputs[keys2[j]], options);
            }
            if (message.setup != null && message.hasOwnProperty("setup"))
                object.setup = $root.ord.ReactionSetup.toObject(message.setup, options);
            if (message.conditions != null && message.hasOwnProperty("conditions"))
                object.conditions = $root.ord.ReactionConditions.toObject(message.conditions, options);
            if (message.notes != null && message.hasOwnProperty("notes"))
                object.notes = $root.ord.ReactionNotes.toObject(message.notes, options);
            if (message.observations && message.observations.length) {
                object.observations = [];
                for (let j = 0; j < message.observations.length; ++j)
                    object.observations[j] = $root.ord.ReactionObservation.toObject(message.observations[j], options);
            }
            if (message.workups && message.workups.length) {
                object.workups = [];
                for (let j = 0; j < message.workups.length; ++j)
                    object.workups[j] = $root.ord.ReactionWorkup.toObject(message.workups[j], options);
            }
            if (message.outcomes && message.outcomes.length) {
                object.outcomes = [];
                for (let j = 0; j < message.outcomes.length; ++j)
                    object.outcomes[j] = $root.ord.ReactionOutcome.toObject(message.outcomes[j], options);
            }
            if (message.provenance != null && message.hasOwnProperty("provenance"))
                object.provenance = $root.ord.ReactionProvenance.toObject(message.provenance, options);
            if (message.reactionId != null && message.hasOwnProperty("reactionId"))
                object.reactionId = message.reactionId;
            return object;
        };

        /**
         * Converts this Reaction to JSON.
         * @function toJSON
         * @memberof ord.Reaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Reaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Reaction
         * @function getTypeUrl
         * @memberof ord.Reaction
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Reaction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.Reaction";
        };

        return Reaction;
    })();

    ord.ReactionIdentifier = (function() {

        /**
         * Properties of a ReactionIdentifier.
         * @memberof ord
         * @interface IReactionIdentifier
         * @property {ord.ReactionIdentifier.ReactionIdentifierType|null} [type] ReactionIdentifier type
         * @property {string|null} [details] ReactionIdentifier details
         * @property {string|null} [value] ReactionIdentifier value
         * @property {boolean|null} [isMapped] ReactionIdentifier isMapped
         */

        /**
         * Constructs a new ReactionIdentifier.
         * @memberof ord
         * @classdesc Reaction identifiers define descriptions of the overall reaction.
         * While we encourage the use of SMILES strings, these do not work well in
         * all cases. The <reaction_smiles> field should be able to be derived
         * from the information present in the ReactionInput and ReactionOutcome
         * fields of any Reaction message.
         * @implements IReactionIdentifier
         * @constructor
         * @param {ord.IReactionIdentifier=} [properties] Properties to set
         */
        function ReactionIdentifier(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReactionIdentifier type.
         * @member {ord.ReactionIdentifier.ReactionIdentifierType} type
         * @memberof ord.ReactionIdentifier
         * @instance
         */
        ReactionIdentifier.prototype.type = 0;

        /**
         * ReactionIdentifier details.
         * @member {string} details
         * @memberof ord.ReactionIdentifier
         * @instance
         */
        ReactionIdentifier.prototype.details = "";

        /**
         * ReactionIdentifier value.
         * @member {string} value
         * @memberof ord.ReactionIdentifier
         * @instance
         */
        ReactionIdentifier.prototype.value = "";

        /**
         * ReactionIdentifier isMapped.
         * @member {boolean|null|undefined} isMapped
         * @memberof ord.ReactionIdentifier
         * @instance
         */
        ReactionIdentifier.prototype.isMapped = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(ReactionIdentifier.prototype, "_isMapped", {
            get: $util.oneOfGetter($oneOfFields = ["isMapped"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ReactionIdentifier instance using the specified properties.
         * @function create
         * @memberof ord.ReactionIdentifier
         * @static
         * @param {ord.IReactionIdentifier=} [properties] Properties to set
         * @returns {ord.ReactionIdentifier} ReactionIdentifier instance
         */
        ReactionIdentifier.create = function create(properties) {
            return new ReactionIdentifier(properties);
        };

        /**
         * Encodes the specified ReactionIdentifier message. Does not implicitly {@link ord.ReactionIdentifier.verify|verify} messages.
         * @function encode
         * @memberof ord.ReactionIdentifier
         * @static
         * @param {ord.IReactionIdentifier} message ReactionIdentifier message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReactionIdentifier.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.value);
            if (message.isMapped != null && Object.hasOwnProperty.call(message, "isMapped"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isMapped);
            return writer;
        };

        /**
         * Encodes the specified ReactionIdentifier message, length delimited. Does not implicitly {@link ord.ReactionIdentifier.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.ReactionIdentifier
         * @static
         * @param {ord.IReactionIdentifier} message ReactionIdentifier message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReactionIdentifier.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReactionIdentifier message from the specified reader or buffer.
         * @function decode
         * @memberof ord.ReactionIdentifier
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.ReactionIdentifier} ReactionIdentifier
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReactionIdentifier.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.ReactionIdentifier();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.details = reader.string();
                        break;
                    }
                case 3: {
                        message.value = reader.string();
                        break;
                    }
                case 4: {
                        message.isMapped = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReactionIdentifier message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.ReactionIdentifier
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.ReactionIdentifier} ReactionIdentifier
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReactionIdentifier.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReactionIdentifier message.
         * @function verify
         * @memberof ord.ReactionIdentifier
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReactionIdentifier.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 6:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.details != null && message.hasOwnProperty("details"))
                if (!$util.isString(message.details))
                    return "details: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            if (message.isMapped != null && message.hasOwnProperty("isMapped")) {
                properties._isMapped = 1;
                if (typeof message.isMapped !== "boolean")
                    return "isMapped: boolean expected";
            }
            return null;
        };

        /**
         * Creates a ReactionIdentifier message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.ReactionIdentifier
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.ReactionIdentifier} ReactionIdentifier
         */
        ReactionIdentifier.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.ReactionIdentifier)
                return object;
            let message = new $root.ord.ReactionIdentifier();
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.type = 0;
                break;
            case "CUSTOM":
            case 1:
                message.type = 1;
                break;
            case "REACTION_SMILES":
            case 2:
                message.type = 2;
                break;
            case "REACTION_CXSMILES":
            case 6:
                message.type = 6;
                break;
            case "RDFILE":
            case 3:
                message.type = 3;
                break;
            case "RINCHI":
            case 4:
                message.type = 4;
                break;
            case "REACTION_TYPE":
            case 5:
                message.type = 5;
                break;
            }
            if (object.details != null)
                message.details = String(object.details);
            if (object.value != null)
                message.value = String(object.value);
            if (object.isMapped != null)
                message.isMapped = Boolean(object.isMapped);
            return message;
        };

        /**
         * Creates a plain object from a ReactionIdentifier message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.ReactionIdentifier
         * @static
         * @param {ord.ReactionIdentifier} message ReactionIdentifier
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReactionIdentifier.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "UNSPECIFIED" : 0;
                object.details = "";
                object.value = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.ord.ReactionIdentifier.ReactionIdentifierType[message.type] === undefined ? message.type : $root.ord.ReactionIdentifier.ReactionIdentifierType[message.type] : message.type;
            if (message.details != null && message.hasOwnProperty("details"))
                object.details = message.details;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            if (message.isMapped != null && message.hasOwnProperty("isMapped")) {
                object.isMapped = message.isMapped;
                if (options.oneofs)
                    object._isMapped = "isMapped";
            }
            return object;
        };

        /**
         * Converts this ReactionIdentifier to JSON.
         * @function toJSON
         * @memberof ord.ReactionIdentifier
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReactionIdentifier.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ReactionIdentifier
         * @function getTypeUrl
         * @memberof ord.ReactionIdentifier
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ReactionIdentifier.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.ReactionIdentifier";
        };

        /**
         * ReactionIdentifierType enum.
         * @name ord.ReactionIdentifier.ReactionIdentifierType
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} CUSTOM=1 CUSTOM value
         * @property {number} REACTION_SMILES=2 REACTION_SMILES value
         * @property {number} REACTION_CXSMILES=6 REACTION_CXSMILES value
         * @property {number} RDFILE=3 RDFILE value
         * @property {number} RINCHI=4 RINCHI value
         * @property {number} REACTION_TYPE=5 REACTION_TYPE value
         */
        ReactionIdentifier.ReactionIdentifierType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "CUSTOM"] = 1;
            values[valuesById[2] = "REACTION_SMILES"] = 2;
            values[valuesById[6] = "REACTION_CXSMILES"] = 6;
            values[valuesById[3] = "RDFILE"] = 3;
            values[valuesById[4] = "RINCHI"] = 4;
            values[valuesById[5] = "REACTION_TYPE"] = 5;
            return values;
        })();

        return ReactionIdentifier;
    })();

    ord.ReactionInput = (function() {

        /**
         * Properties of a ReactionInput.
         * @memberof ord
         * @interface IReactionInput
         * @property {Array.<ord.ICompound>|null} [components] ReactionInput components
         * @property {Array.<ord.ICrudeComponent>|null} [crudeComponents] ReactionInput crudeComponents
         * @property {number|null} [additionOrder] ReactionInput additionOrder
         * @property {ord.ITime|null} [additionTime] ReactionInput additionTime
         * @property {ord.ReactionInput.IAdditionSpeed|null} [additionSpeed] ReactionInput additionSpeed
         * @property {ord.ITime|null} [additionDuration] ReactionInput additionDuration
         * @property {ord.IFlowRate|null} [flowRate] ReactionInput flowRate
         * @property {ord.ReactionInput.IAdditionDevice|null} [additionDevice] ReactionInput additionDevice
         * @property {ord.ITemperature|null} [additionTemperature] ReactionInput additionTemperature
         * @property {ord.ITexture|null} [texture] ReactionInput texture
         */

        /**
         * Constructs a new ReactionInput.
         * @memberof ord
         * @classdesc A reaction input is any pure substance, mixture, or solution that is
         * added to the reaction vessel.
         * 
         * For example, suppose we are adding 3 mL of a 4 M solution of NaOH in water.
         * We would define one component for the solvent and one component for the
         * solute with the correct respective amounts.
         * 
         * input {
         * components: {
         * identifiers: {type: IDENTIFIER_SMILES, value: "O"}
         * identifiers: {type: IDENTIFIER_NAME, value: "water"}
         * volume: {value: 3, units: MILLILITER}
         * volume_includes_solutes: true
         * }
         * components: {
         * identifiers: {type: IDENTIFIER_SMILES, value: "[Na+].[OH-]"}
         * identifiers: {type: IDENTIFIER_NAME, value: "sodium hydroxide"}
         * moles: {value: 12, units: MILLIMOLES}
         * }
         * }
         * @implements IReactionInput
         * @constructor
         * @param {ord.IReactionInput=} [properties] Properties to set
         */
        function ReactionInput(properties) {
            this.components = [];
            this.crudeComponents = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReactionInput components.
         * @member {Array.<ord.ICompound>} components
         * @memberof ord.ReactionInput
         * @instance
         */
        ReactionInput.prototype.components = $util.emptyArray;

        /**
         * ReactionInput crudeComponents.
         * @member {Array.<ord.ICrudeComponent>} crudeComponents
         * @memberof ord.ReactionInput
         * @instance
         */
        ReactionInput.prototype.crudeComponents = $util.emptyArray;

        /**
         * ReactionInput additionOrder.
         * @member {number} additionOrder
         * @memberof ord.ReactionInput
         * @instance
         */
        ReactionInput.prototype.additionOrder = 0;

        /**
         * ReactionInput additionTime.
         * @member {ord.ITime|null|undefined} additionTime
         * @memberof ord.ReactionInput
         * @instance
         */
        ReactionInput.prototype.additionTime = null;

        /**
         * ReactionInput additionSpeed.
         * @member {ord.ReactionInput.IAdditionSpeed|null|undefined} additionSpeed
         * @memberof ord.ReactionInput
         * @instance
         */
        ReactionInput.prototype.additionSpeed = null;

        /**
         * ReactionInput additionDuration.
         * @member {ord.ITime|null|undefined} additionDuration
         * @memberof ord.ReactionInput
         * @instance
         */
        ReactionInput.prototype.additionDuration = null;

        /**
         * ReactionInput flowRate.
         * @member {ord.IFlowRate|null|undefined} flowRate
         * @memberof ord.ReactionInput
         * @instance
         */
        ReactionInput.prototype.flowRate = null;

        /**
         * ReactionInput additionDevice.
         * @member {ord.ReactionInput.IAdditionDevice|null|undefined} additionDevice
         * @memberof ord.ReactionInput
         * @instance
         */
        ReactionInput.prototype.additionDevice = null;

        /**
         * ReactionInput additionTemperature.
         * @member {ord.ITemperature|null|undefined} additionTemperature
         * @memberof ord.ReactionInput
         * @instance
         */
        ReactionInput.prototype.additionTemperature = null;

        /**
         * ReactionInput texture.
         * @member {ord.ITexture|null|undefined} texture
         * @memberof ord.ReactionInput
         * @instance
         */
        ReactionInput.prototype.texture = null;

        /**
         * Creates a new ReactionInput instance using the specified properties.
         * @function create
         * @memberof ord.ReactionInput
         * @static
         * @param {ord.IReactionInput=} [properties] Properties to set
         * @returns {ord.ReactionInput} ReactionInput instance
         */
        ReactionInput.create = function create(properties) {
            return new ReactionInput(properties);
        };

        /**
         * Encodes the specified ReactionInput message. Does not implicitly {@link ord.ReactionInput.verify|verify} messages.
         * @function encode
         * @memberof ord.ReactionInput
         * @static
         * @param {ord.IReactionInput} message ReactionInput message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReactionInput.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.components != null && message.components.length)
                for (let i = 0; i < message.components.length; ++i)
                    $root.ord.Compound.encode(message.components[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.crudeComponents != null && message.crudeComponents.length)
                for (let i = 0; i < message.crudeComponents.length; ++i)
                    $root.ord.CrudeComponent.encode(message.crudeComponents[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.additionOrder != null && Object.hasOwnProperty.call(message, "additionOrder"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.additionOrder);
            if (message.additionTime != null && Object.hasOwnProperty.call(message, "additionTime"))
                $root.ord.Time.encode(message.additionTime, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.additionSpeed != null && Object.hasOwnProperty.call(message, "additionSpeed"))
                $root.ord.ReactionInput.AdditionSpeed.encode(message.additionSpeed, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.additionDuration != null && Object.hasOwnProperty.call(message, "additionDuration"))
                $root.ord.Time.encode(message.additionDuration, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.flowRate != null && Object.hasOwnProperty.call(message, "flowRate"))
                $root.ord.FlowRate.encode(message.flowRate, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.additionDevice != null && Object.hasOwnProperty.call(message, "additionDevice"))
                $root.ord.ReactionInput.AdditionDevice.encode(message.additionDevice, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.additionTemperature != null && Object.hasOwnProperty.call(message, "additionTemperature"))
                $root.ord.Temperature.encode(message.additionTemperature, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.texture != null && Object.hasOwnProperty.call(message, "texture"))
                $root.ord.Texture.encode(message.texture, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ReactionInput message, length delimited. Does not implicitly {@link ord.ReactionInput.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.ReactionInput
         * @static
         * @param {ord.IReactionInput} message ReactionInput message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReactionInput.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReactionInput message from the specified reader or buffer.
         * @function decode
         * @memberof ord.ReactionInput
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.ReactionInput} ReactionInput
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReactionInput.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.ReactionInput();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.components && message.components.length))
                            message.components = [];
                        message.components.push($root.ord.Compound.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        if (!(message.crudeComponents && message.crudeComponents.length))
                            message.crudeComponents = [];
                        message.crudeComponents.push($root.ord.CrudeComponent.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        message.additionOrder = reader.int32();
                        break;
                    }
                case 4: {
                        message.additionTime = $root.ord.Time.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.additionSpeed = $root.ord.ReactionInput.AdditionSpeed.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.additionDuration = $root.ord.Time.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.flowRate = $root.ord.FlowRate.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.additionDevice = $root.ord.ReactionInput.AdditionDevice.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.additionTemperature = $root.ord.Temperature.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.texture = $root.ord.Texture.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReactionInput message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.ReactionInput
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.ReactionInput} ReactionInput
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReactionInput.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReactionInput message.
         * @function verify
         * @memberof ord.ReactionInput
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReactionInput.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.components != null && message.hasOwnProperty("components")) {
                if (!Array.isArray(message.components))
                    return "components: array expected";
                for (let i = 0; i < message.components.length; ++i) {
                    let error = $root.ord.Compound.verify(message.components[i]);
                    if (error)
                        return "components." + error;
                }
            }
            if (message.crudeComponents != null && message.hasOwnProperty("crudeComponents")) {
                if (!Array.isArray(message.crudeComponents))
                    return "crudeComponents: array expected";
                for (let i = 0; i < message.crudeComponents.length; ++i) {
                    let error = $root.ord.CrudeComponent.verify(message.crudeComponents[i]);
                    if (error)
                        return "crudeComponents." + error;
                }
            }
            if (message.additionOrder != null && message.hasOwnProperty("additionOrder"))
                if (!$util.isInteger(message.additionOrder))
                    return "additionOrder: integer expected";
            if (message.additionTime != null && message.hasOwnProperty("additionTime")) {
                let error = $root.ord.Time.verify(message.additionTime);
                if (error)
                    return "additionTime." + error;
            }
            if (message.additionSpeed != null && message.hasOwnProperty("additionSpeed")) {
                let error = $root.ord.ReactionInput.AdditionSpeed.verify(message.additionSpeed);
                if (error)
                    return "additionSpeed." + error;
            }
            if (message.additionDuration != null && message.hasOwnProperty("additionDuration")) {
                let error = $root.ord.Time.verify(message.additionDuration);
                if (error)
                    return "additionDuration." + error;
            }
            if (message.flowRate != null && message.hasOwnProperty("flowRate")) {
                let error = $root.ord.FlowRate.verify(message.flowRate);
                if (error)
                    return "flowRate." + error;
            }
            if (message.additionDevice != null && message.hasOwnProperty("additionDevice")) {
                let error = $root.ord.ReactionInput.AdditionDevice.verify(message.additionDevice);
                if (error)
                    return "additionDevice." + error;
            }
            if (message.additionTemperature != null && message.hasOwnProperty("additionTemperature")) {
                let error = $root.ord.Temperature.verify(message.additionTemperature);
                if (error)
                    return "additionTemperature." + error;
            }
            if (message.texture != null && message.hasOwnProperty("texture")) {
                let error = $root.ord.Texture.verify(message.texture);
                if (error)
                    return "texture." + error;
            }
            return null;
        };

        /**
         * Creates a ReactionInput message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.ReactionInput
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.ReactionInput} ReactionInput
         */
        ReactionInput.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.ReactionInput)
                return object;
            let message = new $root.ord.ReactionInput();
            if (object.components) {
                if (!Array.isArray(object.components))
                    throw TypeError(".ord.ReactionInput.components: array expected");
                message.components = [];
                for (let i = 0; i < object.components.length; ++i) {
                    if (typeof object.components[i] !== "object")
                        throw TypeError(".ord.ReactionInput.components: object expected");
                    message.components[i] = $root.ord.Compound.fromObject(object.components[i]);
                }
            }
            if (object.crudeComponents) {
                if (!Array.isArray(object.crudeComponents))
                    throw TypeError(".ord.ReactionInput.crudeComponents: array expected");
                message.crudeComponents = [];
                for (let i = 0; i < object.crudeComponents.length; ++i) {
                    if (typeof object.crudeComponents[i] !== "object")
                        throw TypeError(".ord.ReactionInput.crudeComponents: object expected");
                    message.crudeComponents[i] = $root.ord.CrudeComponent.fromObject(object.crudeComponents[i]);
                }
            }
            if (object.additionOrder != null)
                message.additionOrder = object.additionOrder | 0;
            if (object.additionTime != null) {
                if (typeof object.additionTime !== "object")
                    throw TypeError(".ord.ReactionInput.additionTime: object expected");
                message.additionTime = $root.ord.Time.fromObject(object.additionTime);
            }
            if (object.additionSpeed != null) {
                if (typeof object.additionSpeed !== "object")
                    throw TypeError(".ord.ReactionInput.additionSpeed: object expected");
                message.additionSpeed = $root.ord.ReactionInput.AdditionSpeed.fromObject(object.additionSpeed);
            }
            if (object.additionDuration != null) {
                if (typeof object.additionDuration !== "object")
                    throw TypeError(".ord.ReactionInput.additionDuration: object expected");
                message.additionDuration = $root.ord.Time.fromObject(object.additionDuration);
            }
            if (object.flowRate != null) {
                if (typeof object.flowRate !== "object")
                    throw TypeError(".ord.ReactionInput.flowRate: object expected");
                message.flowRate = $root.ord.FlowRate.fromObject(object.flowRate);
            }
            if (object.additionDevice != null) {
                if (typeof object.additionDevice !== "object")
                    throw TypeError(".ord.ReactionInput.additionDevice: object expected");
                message.additionDevice = $root.ord.ReactionInput.AdditionDevice.fromObject(object.additionDevice);
            }
            if (object.additionTemperature != null) {
                if (typeof object.additionTemperature !== "object")
                    throw TypeError(".ord.ReactionInput.additionTemperature: object expected");
                message.additionTemperature = $root.ord.Temperature.fromObject(object.additionTemperature);
            }
            if (object.texture != null) {
                if (typeof object.texture !== "object")
                    throw TypeError(".ord.ReactionInput.texture: object expected");
                message.texture = $root.ord.Texture.fromObject(object.texture);
            }
            return message;
        };

        /**
         * Creates a plain object from a ReactionInput message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.ReactionInput
         * @static
         * @param {ord.ReactionInput} message ReactionInput
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReactionInput.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.components = [];
                object.crudeComponents = [];
            }
            if (options.defaults) {
                object.additionOrder = 0;
                object.additionTime = null;
                object.additionSpeed = null;
                object.additionDuration = null;
                object.flowRate = null;
                object.additionDevice = null;
                object.additionTemperature = null;
                object.texture = null;
            }
            if (message.components && message.components.length) {
                object.components = [];
                for (let j = 0; j < message.components.length; ++j)
                    object.components[j] = $root.ord.Compound.toObject(message.components[j], options);
            }
            if (message.crudeComponents && message.crudeComponents.length) {
                object.crudeComponents = [];
                for (let j = 0; j < message.crudeComponents.length; ++j)
                    object.crudeComponents[j] = $root.ord.CrudeComponent.toObject(message.crudeComponents[j], options);
            }
            if (message.additionOrder != null && message.hasOwnProperty("additionOrder"))
                object.additionOrder = message.additionOrder;
            if (message.additionTime != null && message.hasOwnProperty("additionTime"))
                object.additionTime = $root.ord.Time.toObject(message.additionTime, options);
            if (message.additionSpeed != null && message.hasOwnProperty("additionSpeed"))
                object.additionSpeed = $root.ord.ReactionInput.AdditionSpeed.toObject(message.additionSpeed, options);
            if (message.additionDuration != null && message.hasOwnProperty("additionDuration"))
                object.additionDuration = $root.ord.Time.toObject(message.additionDuration, options);
            if (message.flowRate != null && message.hasOwnProperty("flowRate"))
                object.flowRate = $root.ord.FlowRate.toObject(message.flowRate, options);
            if (message.additionDevice != null && message.hasOwnProperty("additionDevice"))
                object.additionDevice = $root.ord.ReactionInput.AdditionDevice.toObject(message.additionDevice, options);
            if (message.additionTemperature != null && message.hasOwnProperty("additionTemperature"))
                object.additionTemperature = $root.ord.Temperature.toObject(message.additionTemperature, options);
            if (message.texture != null && message.hasOwnProperty("texture"))
                object.texture = $root.ord.Texture.toObject(message.texture, options);
            return object;
        };

        /**
         * Converts this ReactionInput to JSON.
         * @function toJSON
         * @memberof ord.ReactionInput
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReactionInput.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ReactionInput
         * @function getTypeUrl
         * @memberof ord.ReactionInput
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ReactionInput.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.ReactionInput";
        };

        ReactionInput.AdditionSpeed = (function() {

            /**
             * Properties of an AdditionSpeed.
             * @memberof ord.ReactionInput
             * @interface IAdditionSpeed
             * @property {ord.ReactionInput.AdditionSpeed.AdditionSpeedType|null} [type] AdditionSpeed type
             * @property {string|null} [details] AdditionSpeed details
             */

            /**
             * Constructs a new AdditionSpeed.
             * @memberof ord.ReactionInput
             * @classdesc Represents an AdditionSpeed.
             * @implements IAdditionSpeed
             * @constructor
             * @param {ord.ReactionInput.IAdditionSpeed=} [properties] Properties to set
             */
            function AdditionSpeed(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AdditionSpeed type.
             * @member {ord.ReactionInput.AdditionSpeed.AdditionSpeedType} type
             * @memberof ord.ReactionInput.AdditionSpeed
             * @instance
             */
            AdditionSpeed.prototype.type = 0;

            /**
             * AdditionSpeed details.
             * @member {string} details
             * @memberof ord.ReactionInput.AdditionSpeed
             * @instance
             */
            AdditionSpeed.prototype.details = "";

            /**
             * Creates a new AdditionSpeed instance using the specified properties.
             * @function create
             * @memberof ord.ReactionInput.AdditionSpeed
             * @static
             * @param {ord.ReactionInput.IAdditionSpeed=} [properties] Properties to set
             * @returns {ord.ReactionInput.AdditionSpeed} AdditionSpeed instance
             */
            AdditionSpeed.create = function create(properties) {
                return new AdditionSpeed(properties);
            };

            /**
             * Encodes the specified AdditionSpeed message. Does not implicitly {@link ord.ReactionInput.AdditionSpeed.verify|verify} messages.
             * @function encode
             * @memberof ord.ReactionInput.AdditionSpeed
             * @static
             * @param {ord.ReactionInput.IAdditionSpeed} message AdditionSpeed message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AdditionSpeed.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
                return writer;
            };

            /**
             * Encodes the specified AdditionSpeed message, length delimited. Does not implicitly {@link ord.ReactionInput.AdditionSpeed.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ord.ReactionInput.AdditionSpeed
             * @static
             * @param {ord.ReactionInput.IAdditionSpeed} message AdditionSpeed message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AdditionSpeed.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AdditionSpeed message from the specified reader or buffer.
             * @function decode
             * @memberof ord.ReactionInput.AdditionSpeed
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ord.ReactionInput.AdditionSpeed} AdditionSpeed
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AdditionSpeed.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.ReactionInput.AdditionSpeed();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.details = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AdditionSpeed message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ord.ReactionInput.AdditionSpeed
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ord.ReactionInput.AdditionSpeed} AdditionSpeed
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AdditionSpeed.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AdditionSpeed message.
             * @function verify
             * @memberof ord.ReactionInput.AdditionSpeed
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AdditionSpeed.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.details != null && message.hasOwnProperty("details"))
                    if (!$util.isString(message.details))
                        return "details: string expected";
                return null;
            };

            /**
             * Creates an AdditionSpeed message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ord.ReactionInput.AdditionSpeed
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ord.ReactionInput.AdditionSpeed} AdditionSpeed
             */
            AdditionSpeed.fromObject = function fromObject(object) {
                if (object instanceof $root.ord.ReactionInput.AdditionSpeed)
                    return object;
                let message = new $root.ord.ReactionInput.AdditionSpeed();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "UNSPECIFIED":
                case 0:
                    message.type = 0;
                    break;
                case "ALL_AT_ONCE":
                case 1:
                    message.type = 1;
                    break;
                case "FAST":
                case 2:
                    message.type = 2;
                    break;
                case "SLOW":
                case 3:
                    message.type = 3;
                    break;
                case "DROPWISE":
                case 4:
                    message.type = 4;
                    break;
                case "CONTINUOUS":
                case 5:
                    message.type = 5;
                    break;
                case "PORTIONWISE":
                case 6:
                    message.type = 6;
                    break;
                }
                if (object.details != null)
                    message.details = String(object.details);
                return message;
            };

            /**
             * Creates a plain object from an AdditionSpeed message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ord.ReactionInput.AdditionSpeed
             * @static
             * @param {ord.ReactionInput.AdditionSpeed} message AdditionSpeed
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AdditionSpeed.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "UNSPECIFIED" : 0;
                    object.details = "";
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.ord.ReactionInput.AdditionSpeed.AdditionSpeedType[message.type] === undefined ? message.type : $root.ord.ReactionInput.AdditionSpeed.AdditionSpeedType[message.type] : message.type;
                if (message.details != null && message.hasOwnProperty("details"))
                    object.details = message.details;
                return object;
            };

            /**
             * Converts this AdditionSpeed to JSON.
             * @function toJSON
             * @memberof ord.ReactionInput.AdditionSpeed
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AdditionSpeed.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AdditionSpeed
             * @function getTypeUrl
             * @memberof ord.ReactionInput.AdditionSpeed
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AdditionSpeed.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/ord.ReactionInput.AdditionSpeed";
            };

            /**
             * AdditionSpeedType enum.
             * @name ord.ReactionInput.AdditionSpeed.AdditionSpeedType
             * @enum {number}
             * @property {number} UNSPECIFIED=0 UNSPECIFIED value
             * @property {number} ALL_AT_ONCE=1 ALL_AT_ONCE value
             * @property {number} FAST=2 FAST value
             * @property {number} SLOW=3 SLOW value
             * @property {number} DROPWISE=4 DROPWISE value
             * @property {number} CONTINUOUS=5 CONTINUOUS value
             * @property {number} PORTIONWISE=6 PORTIONWISE value
             */
            AdditionSpeed.AdditionSpeedType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSPECIFIED"] = 0;
                values[valuesById[1] = "ALL_AT_ONCE"] = 1;
                values[valuesById[2] = "FAST"] = 2;
                values[valuesById[3] = "SLOW"] = 3;
                values[valuesById[4] = "DROPWISE"] = 4;
                values[valuesById[5] = "CONTINUOUS"] = 5;
                values[valuesById[6] = "PORTIONWISE"] = 6;
                return values;
            })();

            return AdditionSpeed;
        })();

        ReactionInput.AdditionDevice = (function() {

            /**
             * Properties of an AdditionDevice.
             * @memberof ord.ReactionInput
             * @interface IAdditionDevice
             * @property {ord.ReactionInput.AdditionDevice.AdditionDeviceType|null} [type] AdditionDevice type
             * @property {string|null} [details] AdditionDevice details
             */

            /**
             * Constructs a new AdditionDevice.
             * @memberof ord.ReactionInput
             * @classdesc Represents an AdditionDevice.
             * @implements IAdditionDevice
             * @constructor
             * @param {ord.ReactionInput.IAdditionDevice=} [properties] Properties to set
             */
            function AdditionDevice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AdditionDevice type.
             * @member {ord.ReactionInput.AdditionDevice.AdditionDeviceType} type
             * @memberof ord.ReactionInput.AdditionDevice
             * @instance
             */
            AdditionDevice.prototype.type = 0;

            /**
             * AdditionDevice details.
             * @member {string} details
             * @memberof ord.ReactionInput.AdditionDevice
             * @instance
             */
            AdditionDevice.prototype.details = "";

            /**
             * Creates a new AdditionDevice instance using the specified properties.
             * @function create
             * @memberof ord.ReactionInput.AdditionDevice
             * @static
             * @param {ord.ReactionInput.IAdditionDevice=} [properties] Properties to set
             * @returns {ord.ReactionInput.AdditionDevice} AdditionDevice instance
             */
            AdditionDevice.create = function create(properties) {
                return new AdditionDevice(properties);
            };

            /**
             * Encodes the specified AdditionDevice message. Does not implicitly {@link ord.ReactionInput.AdditionDevice.verify|verify} messages.
             * @function encode
             * @memberof ord.ReactionInput.AdditionDevice
             * @static
             * @param {ord.ReactionInput.IAdditionDevice} message AdditionDevice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AdditionDevice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
                return writer;
            };

            /**
             * Encodes the specified AdditionDevice message, length delimited. Does not implicitly {@link ord.ReactionInput.AdditionDevice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ord.ReactionInput.AdditionDevice
             * @static
             * @param {ord.ReactionInput.IAdditionDevice} message AdditionDevice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AdditionDevice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AdditionDevice message from the specified reader or buffer.
             * @function decode
             * @memberof ord.ReactionInput.AdditionDevice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ord.ReactionInput.AdditionDevice} AdditionDevice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AdditionDevice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.ReactionInput.AdditionDevice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.details = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AdditionDevice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ord.ReactionInput.AdditionDevice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ord.ReactionInput.AdditionDevice} AdditionDevice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AdditionDevice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AdditionDevice message.
             * @function verify
             * @memberof ord.ReactionInput.AdditionDevice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AdditionDevice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                        break;
                    }
                if (message.details != null && message.hasOwnProperty("details"))
                    if (!$util.isString(message.details))
                        return "details: string expected";
                return null;
            };

            /**
             * Creates an AdditionDevice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ord.ReactionInput.AdditionDevice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ord.ReactionInput.AdditionDevice} AdditionDevice
             */
            AdditionDevice.fromObject = function fromObject(object) {
                if (object instanceof $root.ord.ReactionInput.AdditionDevice)
                    return object;
                let message = new $root.ord.ReactionInput.AdditionDevice();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "UNSPECIFIED":
                case 0:
                    message.type = 0;
                    break;
                case "CUSTOM":
                case 1:
                    message.type = 1;
                    break;
                case "NONE":
                case 2:
                    message.type = 2;
                    break;
                case "SYRINGE":
                case 3:
                    message.type = 3;
                    break;
                case "CANNULA":
                case 4:
                    message.type = 4;
                    break;
                case "ADDITION_FUNNEL":
                case 5:
                    message.type = 5;
                    break;
                case "PIPETTE":
                case 6:
                    message.type = 6;
                    break;
                case "POSITIVE_DISPLACEMENT_PIPETTE":
                case 7:
                    message.type = 7;
                    break;
                case "PISTON_PUMP":
                case 8:
                    message.type = 8;
                    break;
                case "SYRINGE_PUMP":
                case 9:
                    message.type = 9;
                    break;
                case "PERISTALTIC_PUMP":
                case 10:
                    message.type = 10;
                    break;
                }
                if (object.details != null)
                    message.details = String(object.details);
                return message;
            };

            /**
             * Creates a plain object from an AdditionDevice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ord.ReactionInput.AdditionDevice
             * @static
             * @param {ord.ReactionInput.AdditionDevice} message AdditionDevice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AdditionDevice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "UNSPECIFIED" : 0;
                    object.details = "";
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.ord.ReactionInput.AdditionDevice.AdditionDeviceType[message.type] === undefined ? message.type : $root.ord.ReactionInput.AdditionDevice.AdditionDeviceType[message.type] : message.type;
                if (message.details != null && message.hasOwnProperty("details"))
                    object.details = message.details;
                return object;
            };

            /**
             * Converts this AdditionDevice to JSON.
             * @function toJSON
             * @memberof ord.ReactionInput.AdditionDevice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AdditionDevice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AdditionDevice
             * @function getTypeUrl
             * @memberof ord.ReactionInput.AdditionDevice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AdditionDevice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/ord.ReactionInput.AdditionDevice";
            };

            /**
             * AdditionDeviceType enum.
             * @name ord.ReactionInput.AdditionDevice.AdditionDeviceType
             * @enum {number}
             * @property {number} UNSPECIFIED=0 UNSPECIFIED value
             * @property {number} CUSTOM=1 CUSTOM value
             * @property {number} NONE=2 NONE value
             * @property {number} SYRINGE=3 SYRINGE value
             * @property {number} CANNULA=4 CANNULA value
             * @property {number} ADDITION_FUNNEL=5 ADDITION_FUNNEL value
             * @property {number} PIPETTE=6 PIPETTE value
             * @property {number} POSITIVE_DISPLACEMENT_PIPETTE=7 POSITIVE_DISPLACEMENT_PIPETTE value
             * @property {number} PISTON_PUMP=8 PISTON_PUMP value
             * @property {number} SYRINGE_PUMP=9 SYRINGE_PUMP value
             * @property {number} PERISTALTIC_PUMP=10 PERISTALTIC_PUMP value
             */
            AdditionDevice.AdditionDeviceType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSPECIFIED"] = 0;
                values[valuesById[1] = "CUSTOM"] = 1;
                values[valuesById[2] = "NONE"] = 2;
                values[valuesById[3] = "SYRINGE"] = 3;
                values[valuesById[4] = "CANNULA"] = 4;
                values[valuesById[5] = "ADDITION_FUNNEL"] = 5;
                values[valuesById[6] = "PIPETTE"] = 6;
                values[valuesById[7] = "POSITIVE_DISPLACEMENT_PIPETTE"] = 7;
                values[valuesById[8] = "PISTON_PUMP"] = 8;
                values[valuesById[9] = "SYRINGE_PUMP"] = 9;
                values[valuesById[10] = "PERISTALTIC_PUMP"] = 10;
                return values;
            })();

            return AdditionDevice;
        })();

        return ReactionInput;
    })();

    ord.Amount = (function() {

        /**
         * Properties of an Amount.
         * @memberof ord
         * @interface IAmount
         * @property {ord.IMass|null} [mass] Amount mass
         * @property {ord.IMoles|null} [moles] Amount moles
         * @property {ord.IVolume|null} [volume] Amount volume
         * @property {ord.IUnmeasuredAmount|null} [unmeasured] Amount unmeasured
         * @property {boolean|null} [volumeIncludesSolutes] Amount volumeIncludesSolutes
         */

        /**
         * Constructs a new Amount.
         * @memberof ord
         * @classdesc The quantitative amount of a Compound used in a particular reaction.
         * Compounds added in their pure form should have their value defined by
         * mass, moles, or volume. Compounds prepared as solutions should be defined
         * in terms of their volume. Compounds prepared on solid supports should
         * define the total mass/volume including the support.
         * @implements IAmount
         * @constructor
         * @param {ord.IAmount=} [properties] Properties to set
         */
        function Amount(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Amount mass.
         * @member {ord.IMass|null|undefined} mass
         * @memberof ord.Amount
         * @instance
         */
        Amount.prototype.mass = null;

        /**
         * Amount moles.
         * @member {ord.IMoles|null|undefined} moles
         * @memberof ord.Amount
         * @instance
         */
        Amount.prototype.moles = null;

        /**
         * Amount volume.
         * @member {ord.IVolume|null|undefined} volume
         * @memberof ord.Amount
         * @instance
         */
        Amount.prototype.volume = null;

        /**
         * Amount unmeasured.
         * @member {ord.IUnmeasuredAmount|null|undefined} unmeasured
         * @memberof ord.Amount
         * @instance
         */
        Amount.prototype.unmeasured = null;

        /**
         * Amount volumeIncludesSolutes.
         * @member {boolean|null|undefined} volumeIncludesSolutes
         * @memberof ord.Amount
         * @instance
         */
        Amount.prototype.volumeIncludesSolutes = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Amount kind.
         * @member {"mass"|"moles"|"volume"|"unmeasured"|undefined} kind
         * @memberof ord.Amount
         * @instance
         */
        Object.defineProperty(Amount.prototype, "kind", {
            get: $util.oneOfGetter($oneOfFields = ["mass", "moles", "volume", "unmeasured"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Amount.prototype, "_volumeIncludesSolutes", {
            get: $util.oneOfGetter($oneOfFields = ["volumeIncludesSolutes"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Amount instance using the specified properties.
         * @function create
         * @memberof ord.Amount
         * @static
         * @param {ord.IAmount=} [properties] Properties to set
         * @returns {ord.Amount} Amount instance
         */
        Amount.create = function create(properties) {
            return new Amount(properties);
        };

        /**
         * Encodes the specified Amount message. Does not implicitly {@link ord.Amount.verify|verify} messages.
         * @function encode
         * @memberof ord.Amount
         * @static
         * @param {ord.IAmount} message Amount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Amount.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mass != null && Object.hasOwnProperty.call(message, "mass"))
                $root.ord.Mass.encode(message.mass, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.moles != null && Object.hasOwnProperty.call(message, "moles"))
                $root.ord.Moles.encode(message.moles, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.volume != null && Object.hasOwnProperty.call(message, "volume"))
                $root.ord.Volume.encode(message.volume, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.volumeIncludesSolutes != null && Object.hasOwnProperty.call(message, "volumeIncludesSolutes"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.volumeIncludesSolutes);
            if (message.unmeasured != null && Object.hasOwnProperty.call(message, "unmeasured"))
                $root.ord.UnmeasuredAmount.encode(message.unmeasured, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Amount message, length delimited. Does not implicitly {@link ord.Amount.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.Amount
         * @static
         * @param {ord.IAmount} message Amount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Amount.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Amount message from the specified reader or buffer.
         * @function decode
         * @memberof ord.Amount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.Amount} Amount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Amount.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.Amount();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.mass = $root.ord.Mass.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.moles = $root.ord.Moles.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.volume = $root.ord.Volume.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.unmeasured = $root.ord.UnmeasuredAmount.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.volumeIncludesSolutes = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Amount message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.Amount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.Amount} Amount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Amount.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Amount message.
         * @function verify
         * @memberof ord.Amount
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Amount.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.mass != null && message.hasOwnProperty("mass")) {
                properties.kind = 1;
                {
                    let error = $root.ord.Mass.verify(message.mass);
                    if (error)
                        return "mass." + error;
                }
            }
            if (message.moles != null && message.hasOwnProperty("moles")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                {
                    let error = $root.ord.Moles.verify(message.moles);
                    if (error)
                        return "moles." + error;
                }
            }
            if (message.volume != null && message.hasOwnProperty("volume")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                {
                    let error = $root.ord.Volume.verify(message.volume);
                    if (error)
                        return "volume." + error;
                }
            }
            if (message.unmeasured != null && message.hasOwnProperty("unmeasured")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                {
                    let error = $root.ord.UnmeasuredAmount.verify(message.unmeasured);
                    if (error)
                        return "unmeasured." + error;
                }
            }
            if (message.volumeIncludesSolutes != null && message.hasOwnProperty("volumeIncludesSolutes")) {
                properties._volumeIncludesSolutes = 1;
                if (typeof message.volumeIncludesSolutes !== "boolean")
                    return "volumeIncludesSolutes: boolean expected";
            }
            return null;
        };

        /**
         * Creates an Amount message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.Amount
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.Amount} Amount
         */
        Amount.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.Amount)
                return object;
            let message = new $root.ord.Amount();
            if (object.mass != null) {
                if (typeof object.mass !== "object")
                    throw TypeError(".ord.Amount.mass: object expected");
                message.mass = $root.ord.Mass.fromObject(object.mass);
            }
            if (object.moles != null) {
                if (typeof object.moles !== "object")
                    throw TypeError(".ord.Amount.moles: object expected");
                message.moles = $root.ord.Moles.fromObject(object.moles);
            }
            if (object.volume != null) {
                if (typeof object.volume !== "object")
                    throw TypeError(".ord.Amount.volume: object expected");
                message.volume = $root.ord.Volume.fromObject(object.volume);
            }
            if (object.unmeasured != null) {
                if (typeof object.unmeasured !== "object")
                    throw TypeError(".ord.Amount.unmeasured: object expected");
                message.unmeasured = $root.ord.UnmeasuredAmount.fromObject(object.unmeasured);
            }
            if (object.volumeIncludesSolutes != null)
                message.volumeIncludesSolutes = Boolean(object.volumeIncludesSolutes);
            return message;
        };

        /**
         * Creates a plain object from an Amount message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.Amount
         * @static
         * @param {ord.Amount} message Amount
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Amount.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.mass != null && message.hasOwnProperty("mass")) {
                object.mass = $root.ord.Mass.toObject(message.mass, options);
                if (options.oneofs)
                    object.kind = "mass";
            }
            if (message.moles != null && message.hasOwnProperty("moles")) {
                object.moles = $root.ord.Moles.toObject(message.moles, options);
                if (options.oneofs)
                    object.kind = "moles";
            }
            if (message.volume != null && message.hasOwnProperty("volume")) {
                object.volume = $root.ord.Volume.toObject(message.volume, options);
                if (options.oneofs)
                    object.kind = "volume";
            }
            if (message.volumeIncludesSolutes != null && message.hasOwnProperty("volumeIncludesSolutes")) {
                object.volumeIncludesSolutes = message.volumeIncludesSolutes;
                if (options.oneofs)
                    object._volumeIncludesSolutes = "volumeIncludesSolutes";
            }
            if (message.unmeasured != null && message.hasOwnProperty("unmeasured")) {
                object.unmeasured = $root.ord.UnmeasuredAmount.toObject(message.unmeasured, options);
                if (options.oneofs)
                    object.kind = "unmeasured";
            }
            return object;
        };

        /**
         * Converts this Amount to JSON.
         * @function toJSON
         * @memberof ord.Amount
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Amount.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Amount
         * @function getTypeUrl
         * @memberof ord.Amount
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Amount.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.Amount";
        };

        return Amount;
    })();

    ord.UnmeasuredAmount = (function() {

        /**
         * Properties of an UnmeasuredAmount.
         * @memberof ord
         * @interface IUnmeasuredAmount
         * @property {ord.UnmeasuredAmount.UnmeasuredAmountType|null} [type] UnmeasuredAmount type
         * @property {string|null} [details] UnmeasuredAmount details
         */

        /**
         * Constructs a new UnmeasuredAmount.
         * @memberof ord
         * @classdesc Compounds may be defined with qualitative amounts in situations where a
         * precise quantity is not measured or reported.
         * @implements IUnmeasuredAmount
         * @constructor
         * @param {ord.IUnmeasuredAmount=} [properties] Properties to set
         */
        function UnmeasuredAmount(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UnmeasuredAmount type.
         * @member {ord.UnmeasuredAmount.UnmeasuredAmountType} type
         * @memberof ord.UnmeasuredAmount
         * @instance
         */
        UnmeasuredAmount.prototype.type = 0;

        /**
         * UnmeasuredAmount details.
         * @member {string} details
         * @memberof ord.UnmeasuredAmount
         * @instance
         */
        UnmeasuredAmount.prototype.details = "";

        /**
         * Creates a new UnmeasuredAmount instance using the specified properties.
         * @function create
         * @memberof ord.UnmeasuredAmount
         * @static
         * @param {ord.IUnmeasuredAmount=} [properties] Properties to set
         * @returns {ord.UnmeasuredAmount} UnmeasuredAmount instance
         */
        UnmeasuredAmount.create = function create(properties) {
            return new UnmeasuredAmount(properties);
        };

        /**
         * Encodes the specified UnmeasuredAmount message. Does not implicitly {@link ord.UnmeasuredAmount.verify|verify} messages.
         * @function encode
         * @memberof ord.UnmeasuredAmount
         * @static
         * @param {ord.IUnmeasuredAmount} message UnmeasuredAmount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnmeasuredAmount.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
            return writer;
        };

        /**
         * Encodes the specified UnmeasuredAmount message, length delimited. Does not implicitly {@link ord.UnmeasuredAmount.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.UnmeasuredAmount
         * @static
         * @param {ord.IUnmeasuredAmount} message UnmeasuredAmount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnmeasuredAmount.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnmeasuredAmount message from the specified reader or buffer.
         * @function decode
         * @memberof ord.UnmeasuredAmount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.UnmeasuredAmount} UnmeasuredAmount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnmeasuredAmount.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.UnmeasuredAmount();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.details = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UnmeasuredAmount message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.UnmeasuredAmount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.UnmeasuredAmount} UnmeasuredAmount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnmeasuredAmount.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnmeasuredAmount message.
         * @function verify
         * @memberof ord.UnmeasuredAmount
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnmeasuredAmount.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.details != null && message.hasOwnProperty("details"))
                if (!$util.isString(message.details))
                    return "details: string expected";
            return null;
        };

        /**
         * Creates an UnmeasuredAmount message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.UnmeasuredAmount
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.UnmeasuredAmount} UnmeasuredAmount
         */
        UnmeasuredAmount.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.UnmeasuredAmount)
                return object;
            let message = new $root.ord.UnmeasuredAmount();
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.type = 0;
                break;
            case "CUSTOM":
            case 1:
                message.type = 1;
                break;
            case "SATURATED":
            case 2:
                message.type = 2;
                break;
            case "CATALYTIC":
            case 3:
                message.type = 3;
                break;
            case "TITRATED":
            case 4:
                message.type = 4;
                break;
            }
            if (object.details != null)
                message.details = String(object.details);
            return message;
        };

        /**
         * Creates a plain object from an UnmeasuredAmount message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.UnmeasuredAmount
         * @static
         * @param {ord.UnmeasuredAmount} message UnmeasuredAmount
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnmeasuredAmount.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "UNSPECIFIED" : 0;
                object.details = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.ord.UnmeasuredAmount.UnmeasuredAmountType[message.type] === undefined ? message.type : $root.ord.UnmeasuredAmount.UnmeasuredAmountType[message.type] : message.type;
            if (message.details != null && message.hasOwnProperty("details"))
                object.details = message.details;
            return object;
        };

        /**
         * Converts this UnmeasuredAmount to JSON.
         * @function toJSON
         * @memberof ord.UnmeasuredAmount
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnmeasuredAmount.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UnmeasuredAmount
         * @function getTypeUrl
         * @memberof ord.UnmeasuredAmount
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UnmeasuredAmount.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.UnmeasuredAmount";
        };

        /**
         * UnmeasuredAmountType enum.
         * @name ord.UnmeasuredAmount.UnmeasuredAmountType
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} CUSTOM=1 CUSTOM value
         * @property {number} SATURATED=2 SATURATED value
         * @property {number} CATALYTIC=3 CATALYTIC value
         * @property {number} TITRATED=4 TITRATED value
         */
        UnmeasuredAmount.UnmeasuredAmountType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "CUSTOM"] = 1;
            values[valuesById[2] = "SATURATED"] = 2;
            values[valuesById[3] = "CATALYTIC"] = 3;
            values[valuesById[4] = "TITRATED"] = 4;
            return values;
        })();

        return UnmeasuredAmount;
    })();

    ord.Texture = (function() {

        /**
         * Properties of a Texture.
         * @memberof ord
         * @interface ITexture
         * @property {ord.Texture.TextureType|null} [type] Texture type
         * @property {string|null} [details] Texture details
         */

        /**
         * Constructs a new Texture.
         * @memberof ord
         * @classdesc This qualitatively describes the apparent size and morphology of a Compound,
         * a ProductCompound, or a ReactionInput.
         * @implements ITexture
         * @constructor
         * @param {ord.ITexture=} [properties] Properties to set
         */
        function Texture(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Texture type.
         * @member {ord.Texture.TextureType} type
         * @memberof ord.Texture
         * @instance
         */
        Texture.prototype.type = 0;

        /**
         * Texture details.
         * @member {string} details
         * @memberof ord.Texture
         * @instance
         */
        Texture.prototype.details = "";

        /**
         * Creates a new Texture instance using the specified properties.
         * @function create
         * @memberof ord.Texture
         * @static
         * @param {ord.ITexture=} [properties] Properties to set
         * @returns {ord.Texture} Texture instance
         */
        Texture.create = function create(properties) {
            return new Texture(properties);
        };

        /**
         * Encodes the specified Texture message. Does not implicitly {@link ord.Texture.verify|verify} messages.
         * @function encode
         * @memberof ord.Texture
         * @static
         * @param {ord.ITexture} message Texture message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Texture.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
            return writer;
        };

        /**
         * Encodes the specified Texture message, length delimited. Does not implicitly {@link ord.Texture.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.Texture
         * @static
         * @param {ord.ITexture} message Texture message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Texture.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Texture message from the specified reader or buffer.
         * @function decode
         * @memberof ord.Texture
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.Texture} Texture
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Texture.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.Texture();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.details = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Texture message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.Texture
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.Texture} Texture
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Texture.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Texture message.
         * @function verify
         * @memberof ord.Texture
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Texture.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                    break;
                }
            if (message.details != null && message.hasOwnProperty("details"))
                if (!$util.isString(message.details))
                    return "details: string expected";
            return null;
        };

        /**
         * Creates a Texture message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.Texture
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.Texture} Texture
         */
        Texture.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.Texture)
                return object;
            let message = new $root.ord.Texture();
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.type = 0;
                break;
            case "CUSTOM":
            case 1:
                message.type = 1;
                break;
            case "POWDER":
            case 2:
                message.type = 2;
                break;
            case "CRYSTAL":
            case 3:
                message.type = 3;
                break;
            case "OIL":
            case 4:
                message.type = 4;
                break;
            case "AMORPHOUS_SOLID":
            case 5:
                message.type = 5;
                break;
            case "FOAM":
            case 6:
                message.type = 6;
                break;
            case "WAX":
            case 7:
                message.type = 7;
                break;
            case "SEMI_SOLID":
            case 8:
                message.type = 8;
                break;
            case "SOLID":
            case 9:
                message.type = 9;
                break;
            case "LIQUID":
            case 10:
                message.type = 10;
                break;
            case "GAS":
            case 11:
                message.type = 11;
                break;
            }
            if (object.details != null)
                message.details = String(object.details);
            return message;
        };

        /**
         * Creates a plain object from a Texture message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.Texture
         * @static
         * @param {ord.Texture} message Texture
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Texture.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "UNSPECIFIED" : 0;
                object.details = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.ord.Texture.TextureType[message.type] === undefined ? message.type : $root.ord.Texture.TextureType[message.type] : message.type;
            if (message.details != null && message.hasOwnProperty("details"))
                object.details = message.details;
            return object;
        };

        /**
         * Converts this Texture to JSON.
         * @function toJSON
         * @memberof ord.Texture
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Texture.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Texture
         * @function getTypeUrl
         * @memberof ord.Texture
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Texture.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.Texture";
        };

        /**
         * TextureType enum.
         * @name ord.Texture.TextureType
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} CUSTOM=1 CUSTOM value
         * @property {number} POWDER=2 POWDER value
         * @property {number} CRYSTAL=3 CRYSTAL value
         * @property {number} OIL=4 OIL value
         * @property {number} AMORPHOUS_SOLID=5 AMORPHOUS_SOLID value
         * @property {number} FOAM=6 FOAM value
         * @property {number} WAX=7 WAX value
         * @property {number} SEMI_SOLID=8 SEMI_SOLID value
         * @property {number} SOLID=9 SOLID value
         * @property {number} LIQUID=10 LIQUID value
         * @property {number} GAS=11 GAS value
         */
        Texture.TextureType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "CUSTOM"] = 1;
            values[valuesById[2] = "POWDER"] = 2;
            values[valuesById[3] = "CRYSTAL"] = 3;
            values[valuesById[4] = "OIL"] = 4;
            values[valuesById[5] = "AMORPHOUS_SOLID"] = 5;
            values[valuesById[6] = "FOAM"] = 6;
            values[valuesById[7] = "WAX"] = 7;
            values[valuesById[8] = "SEMI_SOLID"] = 8;
            values[valuesById[9] = "SOLID"] = 9;
            values[valuesById[10] = "LIQUID"] = 10;
            values[valuesById[11] = "GAS"] = 11;
            return values;
        })();

        return Texture;
    })();

    ord.CrudeComponent = (function() {

        /**
         * Properties of a CrudeComponent.
         * @memberof ord
         * @interface ICrudeComponent
         * @property {string|null} [reactionId] CrudeComponent reactionId
         * @property {boolean|null} [includesWorkup] CrudeComponent includesWorkup
         * @property {boolean|null} [hasDerivedAmount] CrudeComponent hasDerivedAmount
         * @property {ord.IAmount|null} [amount] CrudeComponent amount
         * @property {ord.ITexture|null} [texture] CrudeComponent texture
         */

        /**
         * Constructs a new CrudeComponent.
         * @memberof ord
         * @classdesc Crude components are used in multi-step or multi-stage reactions (no strong
         * distinction is made here) where one synthetic process must be described by
         * multiple "Reaction" messages. In these cases, we often carry the crude
         * product from one step/stage into the next. This message is only to be used
         * when there is not complete isolation of an intermediate molecule; if there
         * is complete isolation, then a regular Compound should be used with the
         * SYNTHESIED preparation type.
         * @implements ICrudeComponent
         * @constructor
         * @param {ord.ICrudeComponent=} [properties] Properties to set
         */
        function CrudeComponent(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CrudeComponent reactionId.
         * @member {string} reactionId
         * @memberof ord.CrudeComponent
         * @instance
         */
        CrudeComponent.prototype.reactionId = "";

        /**
         * CrudeComponent includesWorkup.
         * @member {boolean|null|undefined} includesWorkup
         * @memberof ord.CrudeComponent
         * @instance
         */
        CrudeComponent.prototype.includesWorkup = null;

        /**
         * CrudeComponent hasDerivedAmount.
         * @member {boolean|null|undefined} hasDerivedAmount
         * @memberof ord.CrudeComponent
         * @instance
         */
        CrudeComponent.prototype.hasDerivedAmount = null;

        /**
         * CrudeComponent amount.
         * @member {ord.IAmount|null|undefined} amount
         * @memberof ord.CrudeComponent
         * @instance
         */
        CrudeComponent.prototype.amount = null;

        /**
         * CrudeComponent texture.
         * @member {ord.ITexture|null|undefined} texture
         * @memberof ord.CrudeComponent
         * @instance
         */
        CrudeComponent.prototype.texture = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(CrudeComponent.prototype, "_includesWorkup", {
            get: $util.oneOfGetter($oneOfFields = ["includesWorkup"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(CrudeComponent.prototype, "_hasDerivedAmount", {
            get: $util.oneOfGetter($oneOfFields = ["hasDerivedAmount"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new CrudeComponent instance using the specified properties.
         * @function create
         * @memberof ord.CrudeComponent
         * @static
         * @param {ord.ICrudeComponent=} [properties] Properties to set
         * @returns {ord.CrudeComponent} CrudeComponent instance
         */
        CrudeComponent.create = function create(properties) {
            return new CrudeComponent(properties);
        };

        /**
         * Encodes the specified CrudeComponent message. Does not implicitly {@link ord.CrudeComponent.verify|verify} messages.
         * @function encode
         * @memberof ord.CrudeComponent
         * @static
         * @param {ord.ICrudeComponent} message CrudeComponent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CrudeComponent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reactionId != null && Object.hasOwnProperty.call(message, "reactionId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.reactionId);
            if (message.includesWorkup != null && Object.hasOwnProperty.call(message, "includesWorkup"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.includesWorkup);
            if (message.hasDerivedAmount != null && Object.hasOwnProperty.call(message, "hasDerivedAmount"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.hasDerivedAmount);
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                $root.ord.Amount.encode(message.amount, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.texture != null && Object.hasOwnProperty.call(message, "texture"))
                $root.ord.Texture.encode(message.texture, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CrudeComponent message, length delimited. Does not implicitly {@link ord.CrudeComponent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.CrudeComponent
         * @static
         * @param {ord.ICrudeComponent} message CrudeComponent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CrudeComponent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CrudeComponent message from the specified reader or buffer.
         * @function decode
         * @memberof ord.CrudeComponent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.CrudeComponent} CrudeComponent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrudeComponent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.CrudeComponent();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.reactionId = reader.string();
                        break;
                    }
                case 2: {
                        message.includesWorkup = reader.bool();
                        break;
                    }
                case 3: {
                        message.hasDerivedAmount = reader.bool();
                        break;
                    }
                case 4: {
                        message.amount = $root.ord.Amount.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.texture = $root.ord.Texture.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CrudeComponent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.CrudeComponent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.CrudeComponent} CrudeComponent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrudeComponent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CrudeComponent message.
         * @function verify
         * @memberof ord.CrudeComponent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CrudeComponent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.reactionId != null && message.hasOwnProperty("reactionId"))
                if (!$util.isString(message.reactionId))
                    return "reactionId: string expected";
            if (message.includesWorkup != null && message.hasOwnProperty("includesWorkup")) {
                properties._includesWorkup = 1;
                if (typeof message.includesWorkup !== "boolean")
                    return "includesWorkup: boolean expected";
            }
            if (message.hasDerivedAmount != null && message.hasOwnProperty("hasDerivedAmount")) {
                properties._hasDerivedAmount = 1;
                if (typeof message.hasDerivedAmount !== "boolean")
                    return "hasDerivedAmount: boolean expected";
            }
            if (message.amount != null && message.hasOwnProperty("amount")) {
                let error = $root.ord.Amount.verify(message.amount);
                if (error)
                    return "amount." + error;
            }
            if (message.texture != null && message.hasOwnProperty("texture")) {
                let error = $root.ord.Texture.verify(message.texture);
                if (error)
                    return "texture." + error;
            }
            return null;
        };

        /**
         * Creates a CrudeComponent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.CrudeComponent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.CrudeComponent} CrudeComponent
         */
        CrudeComponent.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.CrudeComponent)
                return object;
            let message = new $root.ord.CrudeComponent();
            if (object.reactionId != null)
                message.reactionId = String(object.reactionId);
            if (object.includesWorkup != null)
                message.includesWorkup = Boolean(object.includesWorkup);
            if (object.hasDerivedAmount != null)
                message.hasDerivedAmount = Boolean(object.hasDerivedAmount);
            if (object.amount != null) {
                if (typeof object.amount !== "object")
                    throw TypeError(".ord.CrudeComponent.amount: object expected");
                message.amount = $root.ord.Amount.fromObject(object.amount);
            }
            if (object.texture != null) {
                if (typeof object.texture !== "object")
                    throw TypeError(".ord.CrudeComponent.texture: object expected");
                message.texture = $root.ord.Texture.fromObject(object.texture);
            }
            return message;
        };

        /**
         * Creates a plain object from a CrudeComponent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.CrudeComponent
         * @static
         * @param {ord.CrudeComponent} message CrudeComponent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CrudeComponent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.reactionId = "";
                object.amount = null;
                object.texture = null;
            }
            if (message.reactionId != null && message.hasOwnProperty("reactionId"))
                object.reactionId = message.reactionId;
            if (message.includesWorkup != null && message.hasOwnProperty("includesWorkup")) {
                object.includesWorkup = message.includesWorkup;
                if (options.oneofs)
                    object._includesWorkup = "includesWorkup";
            }
            if (message.hasDerivedAmount != null && message.hasOwnProperty("hasDerivedAmount")) {
                object.hasDerivedAmount = message.hasDerivedAmount;
                if (options.oneofs)
                    object._hasDerivedAmount = "hasDerivedAmount";
            }
            if (message.amount != null && message.hasOwnProperty("amount"))
                object.amount = $root.ord.Amount.toObject(message.amount, options);
            if (message.texture != null && message.hasOwnProperty("texture"))
                object.texture = $root.ord.Texture.toObject(message.texture, options);
            return object;
        };

        /**
         * Converts this CrudeComponent to JSON.
         * @function toJSON
         * @memberof ord.CrudeComponent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CrudeComponent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CrudeComponent
         * @function getTypeUrl
         * @memberof ord.CrudeComponent
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CrudeComponent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.CrudeComponent";
        };

        return CrudeComponent;
    })();

    ord.Compound = (function() {

        /**
         * Properties of a Compound.
         * @memberof ord
         * @interface ICompound
         * @property {Array.<ord.ICompoundIdentifier>|null} [identifiers] Compound identifiers
         * @property {ord.IAmount|null} [amount] Compound amount
         * @property {ord.ReactionRole.ReactionRoleType|null} [reactionRole] Compound reactionRole
         * @property {boolean|null} [isLimiting] Compound isLimiting
         * @property {Array.<ord.ICompoundPreparation>|null} [preparations] Compound preparations
         * @property {ord.Compound.ISource|null} [source] Compound source
         * @property {Object.<string,ord.IData>|null} [features] Compound features
         * @property {Object.<string,ord.IAnalysis>|null} [analyses] Compound analyses
         * @property {ord.ITexture|null} [texture] Compound texture
         */

        /**
         * Constructs a new Compound.
         * @memberof ord
         * @classdesc A Compound defines both the identity of a pure species and a quantitative
         * amount (mass, moles, volume). For compounds used in inputs, details can
         * be provided about how it was prepared and from where it was purchased.
         * @implements ICompound
         * @constructor
         * @param {ord.ICompound=} [properties] Properties to set
         */
        function Compound(properties) {
            this.identifiers = [];
            this.preparations = [];
            this.features = {};
            this.analyses = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Compound identifiers.
         * @member {Array.<ord.ICompoundIdentifier>} identifiers
         * @memberof ord.Compound
         * @instance
         */
        Compound.prototype.identifiers = $util.emptyArray;

        /**
         * Compound amount.
         * @member {ord.IAmount|null|undefined} amount
         * @memberof ord.Compound
         * @instance
         */
        Compound.prototype.amount = null;

        /**
         * Compound reactionRole.
         * @member {ord.ReactionRole.ReactionRoleType} reactionRole
         * @memberof ord.Compound
         * @instance
         */
        Compound.prototype.reactionRole = 0;

        /**
         * Compound isLimiting.
         * @member {boolean|null|undefined} isLimiting
         * @memberof ord.Compound
         * @instance
         */
        Compound.prototype.isLimiting = null;

        /**
         * Compound preparations.
         * @member {Array.<ord.ICompoundPreparation>} preparations
         * @memberof ord.Compound
         * @instance
         */
        Compound.prototype.preparations = $util.emptyArray;

        /**
         * Compound source.
         * @member {ord.Compound.ISource|null|undefined} source
         * @memberof ord.Compound
         * @instance
         */
        Compound.prototype.source = null;

        /**
         * Compound features.
         * @member {Object.<string,ord.IData>} features
         * @memberof ord.Compound
         * @instance
         */
        Compound.prototype.features = $util.emptyObject;

        /**
         * Compound analyses.
         * @member {Object.<string,ord.IAnalysis>} analyses
         * @memberof ord.Compound
         * @instance
         */
        Compound.prototype.analyses = $util.emptyObject;

        /**
         * Compound texture.
         * @member {ord.ITexture|null|undefined} texture
         * @memberof ord.Compound
         * @instance
         */
        Compound.prototype.texture = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Compound.prototype, "_isLimiting", {
            get: $util.oneOfGetter($oneOfFields = ["isLimiting"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Compound instance using the specified properties.
         * @function create
         * @memberof ord.Compound
         * @static
         * @param {ord.ICompound=} [properties] Properties to set
         * @returns {ord.Compound} Compound instance
         */
        Compound.create = function create(properties) {
            return new Compound(properties);
        };

        /**
         * Encodes the specified Compound message. Does not implicitly {@link ord.Compound.verify|verify} messages.
         * @function encode
         * @memberof ord.Compound
         * @static
         * @param {ord.ICompound} message Compound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Compound.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.identifiers != null && message.identifiers.length)
                for (let i = 0; i < message.identifiers.length; ++i)
                    $root.ord.CompoundIdentifier.encode(message.identifiers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                $root.ord.Amount.encode(message.amount, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.reactionRole != null && Object.hasOwnProperty.call(message, "reactionRole"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.reactionRole);
            if (message.isLimiting != null && Object.hasOwnProperty.call(message, "isLimiting"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isLimiting);
            if (message.preparations != null && message.preparations.length)
                for (let i = 0; i < message.preparations.length; ++i)
                    $root.ord.CompoundPreparation.encode(message.preparations[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                $root.ord.Compound.Source.encode(message.source, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.features != null && Object.hasOwnProperty.call(message, "features"))
                for (let keys = Object.keys(message.features), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 7, wireType 2 =*/58).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.ord.Data.encode(message.features[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.analyses != null && Object.hasOwnProperty.call(message, "analyses"))
                for (let keys = Object.keys(message.analyses), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 8, wireType 2 =*/66).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.ord.Analysis.encode(message.analyses[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.texture != null && Object.hasOwnProperty.call(message, "texture"))
                $root.ord.Texture.encode(message.texture, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Compound message, length delimited. Does not implicitly {@link ord.Compound.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.Compound
         * @static
         * @param {ord.ICompound} message Compound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Compound.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Compound message from the specified reader or buffer.
         * @function decode
         * @memberof ord.Compound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.Compound} Compound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Compound.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.Compound(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.identifiers && message.identifiers.length))
                            message.identifiers = [];
                        message.identifiers.push($root.ord.CompoundIdentifier.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.amount = $root.ord.Amount.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.reactionRole = reader.int32();
                        break;
                    }
                case 4: {
                        message.isLimiting = reader.bool();
                        break;
                    }
                case 5: {
                        if (!(message.preparations && message.preparations.length))
                            message.preparations = [];
                        message.preparations.push($root.ord.CompoundPreparation.decode(reader, reader.uint32()));
                        break;
                    }
                case 6: {
                        message.source = $root.ord.Compound.Source.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        if (message.features === $util.emptyObject)
                            message.features = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.ord.Data.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.features[key] = value;
                        break;
                    }
                case 8: {
                        if (message.analyses === $util.emptyObject)
                            message.analyses = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.ord.Analysis.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.analyses[key] = value;
                        break;
                    }
                case 9: {
                        message.texture = $root.ord.Texture.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Compound message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.Compound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.Compound} Compound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Compound.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Compound message.
         * @function verify
         * @memberof ord.Compound
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Compound.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.identifiers != null && message.hasOwnProperty("identifiers")) {
                if (!Array.isArray(message.identifiers))
                    return "identifiers: array expected";
                for (let i = 0; i < message.identifiers.length; ++i) {
                    let error = $root.ord.CompoundIdentifier.verify(message.identifiers[i]);
                    if (error)
                        return "identifiers." + error;
                }
            }
            if (message.amount != null && message.hasOwnProperty("amount")) {
                let error = $root.ord.Amount.verify(message.amount);
                if (error)
                    return "amount." + error;
            }
            if (message.reactionRole != null && message.hasOwnProperty("reactionRole"))
                switch (message.reactionRole) {
                default:
                    return "reactionRole: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                    break;
                }
            if (message.isLimiting != null && message.hasOwnProperty("isLimiting")) {
                properties._isLimiting = 1;
                if (typeof message.isLimiting !== "boolean")
                    return "isLimiting: boolean expected";
            }
            if (message.preparations != null && message.hasOwnProperty("preparations")) {
                if (!Array.isArray(message.preparations))
                    return "preparations: array expected";
                for (let i = 0; i < message.preparations.length; ++i) {
                    let error = $root.ord.CompoundPreparation.verify(message.preparations[i]);
                    if (error)
                        return "preparations." + error;
                }
            }
            if (message.source != null && message.hasOwnProperty("source")) {
                let error = $root.ord.Compound.Source.verify(message.source);
                if (error)
                    return "source." + error;
            }
            if (message.features != null && message.hasOwnProperty("features")) {
                if (!$util.isObject(message.features))
                    return "features: object expected";
                let key = Object.keys(message.features);
                for (let i = 0; i < key.length; ++i) {
                    let error = $root.ord.Data.verify(message.features[key[i]]);
                    if (error)
                        return "features." + error;
                }
            }
            if (message.analyses != null && message.hasOwnProperty("analyses")) {
                if (!$util.isObject(message.analyses))
                    return "analyses: object expected";
                let key = Object.keys(message.analyses);
                for (let i = 0; i < key.length; ++i) {
                    let error = $root.ord.Analysis.verify(message.analyses[key[i]]);
                    if (error)
                        return "analyses." + error;
                }
            }
            if (message.texture != null && message.hasOwnProperty("texture")) {
                let error = $root.ord.Texture.verify(message.texture);
                if (error)
                    return "texture." + error;
            }
            return null;
        };

        /**
         * Creates a Compound message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.Compound
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.Compound} Compound
         */
        Compound.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.Compound)
                return object;
            let message = new $root.ord.Compound();
            if (object.identifiers) {
                if (!Array.isArray(object.identifiers))
                    throw TypeError(".ord.Compound.identifiers: array expected");
                message.identifiers = [];
                for (let i = 0; i < object.identifiers.length; ++i) {
                    if (typeof object.identifiers[i] !== "object")
                        throw TypeError(".ord.Compound.identifiers: object expected");
                    message.identifiers[i] = $root.ord.CompoundIdentifier.fromObject(object.identifiers[i]);
                }
            }
            if (object.amount != null) {
                if (typeof object.amount !== "object")
                    throw TypeError(".ord.Compound.amount: object expected");
                message.amount = $root.ord.Amount.fromObject(object.amount);
            }
            switch (object.reactionRole) {
            default:
                if (typeof object.reactionRole === "number") {
                    message.reactionRole = object.reactionRole;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.reactionRole = 0;
                break;
            case "REACTANT":
            case 1:
                message.reactionRole = 1;
                break;
            case "REAGENT":
            case 2:
                message.reactionRole = 2;
                break;
            case "SOLVENT":
            case 3:
                message.reactionRole = 3;
                break;
            case "CATALYST":
            case 4:
                message.reactionRole = 4;
                break;
            case "WORKUP":
            case 5:
                message.reactionRole = 5;
                break;
            case "INTERNAL_STANDARD":
            case 6:
                message.reactionRole = 6;
                break;
            case "AUTHENTIC_STANDARD":
            case 7:
                message.reactionRole = 7;
                break;
            case "PRODUCT":
            case 8:
                message.reactionRole = 8;
                break;
            case "BYPRODUCT":
            case 9:
                message.reactionRole = 9;
                break;
            case "SIDE_PRODUCT":
            case 10:
                message.reactionRole = 10;
                break;
            }
            if (object.isLimiting != null)
                message.isLimiting = Boolean(object.isLimiting);
            if (object.preparations) {
                if (!Array.isArray(object.preparations))
                    throw TypeError(".ord.Compound.preparations: array expected");
                message.preparations = [];
                for (let i = 0; i < object.preparations.length; ++i) {
                    if (typeof object.preparations[i] !== "object")
                        throw TypeError(".ord.Compound.preparations: object expected");
                    message.preparations[i] = $root.ord.CompoundPreparation.fromObject(object.preparations[i]);
                }
            }
            if (object.source != null) {
                if (typeof object.source !== "object")
                    throw TypeError(".ord.Compound.source: object expected");
                message.source = $root.ord.Compound.Source.fromObject(object.source);
            }
            if (object.features) {
                if (typeof object.features !== "object")
                    throw TypeError(".ord.Compound.features: object expected");
                message.features = {};
                for (let keys = Object.keys(object.features), i = 0; i < keys.length; ++i) {
                    if (typeof object.features[keys[i]] !== "object")
                        throw TypeError(".ord.Compound.features: object expected");
                    message.features[keys[i]] = $root.ord.Data.fromObject(object.features[keys[i]]);
                }
            }
            if (object.analyses) {
                if (typeof object.analyses !== "object")
                    throw TypeError(".ord.Compound.analyses: object expected");
                message.analyses = {};
                for (let keys = Object.keys(object.analyses), i = 0; i < keys.length; ++i) {
                    if (typeof object.analyses[keys[i]] !== "object")
                        throw TypeError(".ord.Compound.analyses: object expected");
                    message.analyses[keys[i]] = $root.ord.Analysis.fromObject(object.analyses[keys[i]]);
                }
            }
            if (object.texture != null) {
                if (typeof object.texture !== "object")
                    throw TypeError(".ord.Compound.texture: object expected");
                message.texture = $root.ord.Texture.fromObject(object.texture);
            }
            return message;
        };

        /**
         * Creates a plain object from a Compound message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.Compound
         * @static
         * @param {ord.Compound} message Compound
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Compound.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.identifiers = [];
                object.preparations = [];
            }
            if (options.objects || options.defaults) {
                object.features = {};
                object.analyses = {};
            }
            if (options.defaults) {
                object.amount = null;
                object.reactionRole = options.enums === String ? "UNSPECIFIED" : 0;
                object.source = null;
                object.texture = null;
            }
            if (message.identifiers && message.identifiers.length) {
                object.identifiers = [];
                for (let j = 0; j < message.identifiers.length; ++j)
                    object.identifiers[j] = $root.ord.CompoundIdentifier.toObject(message.identifiers[j], options);
            }
            if (message.amount != null && message.hasOwnProperty("amount"))
                object.amount = $root.ord.Amount.toObject(message.amount, options);
            if (message.reactionRole != null && message.hasOwnProperty("reactionRole"))
                object.reactionRole = options.enums === String ? $root.ord.ReactionRole.ReactionRoleType[message.reactionRole] === undefined ? message.reactionRole : $root.ord.ReactionRole.ReactionRoleType[message.reactionRole] : message.reactionRole;
            if (message.isLimiting != null && message.hasOwnProperty("isLimiting")) {
                object.isLimiting = message.isLimiting;
                if (options.oneofs)
                    object._isLimiting = "isLimiting";
            }
            if (message.preparations && message.preparations.length) {
                object.preparations = [];
                for (let j = 0; j < message.preparations.length; ++j)
                    object.preparations[j] = $root.ord.CompoundPreparation.toObject(message.preparations[j], options);
            }
            if (message.source != null && message.hasOwnProperty("source"))
                object.source = $root.ord.Compound.Source.toObject(message.source, options);
            let keys2;
            if (message.features && (keys2 = Object.keys(message.features)).length) {
                object.features = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.features[keys2[j]] = $root.ord.Data.toObject(message.features[keys2[j]], options);
            }
            if (message.analyses && (keys2 = Object.keys(message.analyses)).length) {
                object.analyses = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.analyses[keys2[j]] = $root.ord.Analysis.toObject(message.analyses[keys2[j]], options);
            }
            if (message.texture != null && message.hasOwnProperty("texture"))
                object.texture = $root.ord.Texture.toObject(message.texture, options);
            return object;
        };

        /**
         * Converts this Compound to JSON.
         * @function toJSON
         * @memberof ord.Compound
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Compound.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Compound
         * @function getTypeUrl
         * @memberof ord.Compound
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Compound.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.Compound";
        };

        Compound.Source = (function() {

            /**
             * Properties of a Source.
             * @memberof ord.Compound
             * @interface ISource
             * @property {string|null} [vendor] Source vendor
             * @property {string|null} [catalogId] Source catalogId
             * @property {string|null} [lot] Source lot
             */

            /**
             * Constructs a new Source.
             * @memberof ord.Compound
             * @classdesc Represents a Source.
             * @implements ISource
             * @constructor
             * @param {ord.Compound.ISource=} [properties] Properties to set
             */
            function Source(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Source vendor.
             * @member {string} vendor
             * @memberof ord.Compound.Source
             * @instance
             */
            Source.prototype.vendor = "";

            /**
             * Source catalogId.
             * @member {string} catalogId
             * @memberof ord.Compound.Source
             * @instance
             */
            Source.prototype.catalogId = "";

            /**
             * Source lot.
             * @member {string} lot
             * @memberof ord.Compound.Source
             * @instance
             */
            Source.prototype.lot = "";

            /**
             * Creates a new Source instance using the specified properties.
             * @function create
             * @memberof ord.Compound.Source
             * @static
             * @param {ord.Compound.ISource=} [properties] Properties to set
             * @returns {ord.Compound.Source} Source instance
             */
            Source.create = function create(properties) {
                return new Source(properties);
            };

            /**
             * Encodes the specified Source message. Does not implicitly {@link ord.Compound.Source.verify|verify} messages.
             * @function encode
             * @memberof ord.Compound.Source
             * @static
             * @param {ord.Compound.ISource} message Source message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Source.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.vendor != null && Object.hasOwnProperty.call(message, "vendor"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.vendor);
                if (message.catalogId != null && Object.hasOwnProperty.call(message, "catalogId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.catalogId);
                if (message.lot != null && Object.hasOwnProperty.call(message, "lot"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.lot);
                return writer;
            };

            /**
             * Encodes the specified Source message, length delimited. Does not implicitly {@link ord.Compound.Source.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ord.Compound.Source
             * @static
             * @param {ord.Compound.ISource} message Source message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Source.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Source message from the specified reader or buffer.
             * @function decode
             * @memberof ord.Compound.Source
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ord.Compound.Source} Source
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Source.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.Compound.Source();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.vendor = reader.string();
                            break;
                        }
                    case 2: {
                            message.catalogId = reader.string();
                            break;
                        }
                    case 3: {
                            message.lot = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Source message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ord.Compound.Source
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ord.Compound.Source} Source
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Source.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Source message.
             * @function verify
             * @memberof ord.Compound.Source
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Source.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.vendor != null && message.hasOwnProperty("vendor"))
                    if (!$util.isString(message.vendor))
                        return "vendor: string expected";
                if (message.catalogId != null && message.hasOwnProperty("catalogId"))
                    if (!$util.isString(message.catalogId))
                        return "catalogId: string expected";
                if (message.lot != null && message.hasOwnProperty("lot"))
                    if (!$util.isString(message.lot))
                        return "lot: string expected";
                return null;
            };

            /**
             * Creates a Source message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ord.Compound.Source
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ord.Compound.Source} Source
             */
            Source.fromObject = function fromObject(object) {
                if (object instanceof $root.ord.Compound.Source)
                    return object;
                let message = new $root.ord.Compound.Source();
                if (object.vendor != null)
                    message.vendor = String(object.vendor);
                if (object.catalogId != null)
                    message.catalogId = String(object.catalogId);
                if (object.lot != null)
                    message.lot = String(object.lot);
                return message;
            };

            /**
             * Creates a plain object from a Source message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ord.Compound.Source
             * @static
             * @param {ord.Compound.Source} message Source
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Source.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.vendor = "";
                    object.catalogId = "";
                    object.lot = "";
                }
                if (message.vendor != null && message.hasOwnProperty("vendor"))
                    object.vendor = message.vendor;
                if (message.catalogId != null && message.hasOwnProperty("catalogId"))
                    object.catalogId = message.catalogId;
                if (message.lot != null && message.hasOwnProperty("lot"))
                    object.lot = message.lot;
                return object;
            };

            /**
             * Converts this Source to JSON.
             * @function toJSON
             * @memberof ord.Compound.Source
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Source.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Source
             * @function getTypeUrl
             * @memberof ord.Compound.Source
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Source.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/ord.Compound.Source";
            };

            return Source;
        })();

        return Compound;
    })();

    ord.ReactionRole = (function() {

        /**
         * Properties of a ReactionRole.
         * @memberof ord
         * @interface IReactionRole
         */

        /**
         * Constructs a new ReactionRole.
         * @memberof ord
         * @classdesc Represents a ReactionRole.
         * @implements IReactionRole
         * @constructor
         * @param {ord.IReactionRole=} [properties] Properties to set
         */
        function ReactionRole(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ReactionRole instance using the specified properties.
         * @function create
         * @memberof ord.ReactionRole
         * @static
         * @param {ord.IReactionRole=} [properties] Properties to set
         * @returns {ord.ReactionRole} ReactionRole instance
         */
        ReactionRole.create = function create(properties) {
            return new ReactionRole(properties);
        };

        /**
         * Encodes the specified ReactionRole message. Does not implicitly {@link ord.ReactionRole.verify|verify} messages.
         * @function encode
         * @memberof ord.ReactionRole
         * @static
         * @param {ord.IReactionRole} message ReactionRole message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReactionRole.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ReactionRole message, length delimited. Does not implicitly {@link ord.ReactionRole.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.ReactionRole
         * @static
         * @param {ord.IReactionRole} message ReactionRole message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReactionRole.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReactionRole message from the specified reader or buffer.
         * @function decode
         * @memberof ord.ReactionRole
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.ReactionRole} ReactionRole
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReactionRole.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.ReactionRole();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReactionRole message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.ReactionRole
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.ReactionRole} ReactionRole
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReactionRole.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReactionRole message.
         * @function verify
         * @memberof ord.ReactionRole
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReactionRole.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ReactionRole message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.ReactionRole
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.ReactionRole} ReactionRole
         */
        ReactionRole.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.ReactionRole)
                return object;
            return new $root.ord.ReactionRole();
        };

        /**
         * Creates a plain object from a ReactionRole message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.ReactionRole
         * @static
         * @param {ord.ReactionRole} message ReactionRole
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReactionRole.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ReactionRole to JSON.
         * @function toJSON
         * @memberof ord.ReactionRole
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReactionRole.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ReactionRole
         * @function getTypeUrl
         * @memberof ord.ReactionRole
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ReactionRole.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.ReactionRole";
        };

        /**
         * ReactionRoleType enum.
         * @name ord.ReactionRole.ReactionRoleType
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} REACTANT=1 REACTANT value
         * @property {number} REAGENT=2 REAGENT value
         * @property {number} SOLVENT=3 SOLVENT value
         * @property {number} CATALYST=4 CATALYST value
         * @property {number} WORKUP=5 WORKUP value
         * @property {number} INTERNAL_STANDARD=6 INTERNAL_STANDARD value
         * @property {number} AUTHENTIC_STANDARD=7 AUTHENTIC_STANDARD value
         * @property {number} PRODUCT=8 PRODUCT value
         * @property {number} BYPRODUCT=9 BYPRODUCT value
         * @property {number} SIDE_PRODUCT=10 SIDE_PRODUCT value
         */
        ReactionRole.ReactionRoleType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "REACTANT"] = 1;
            values[valuesById[2] = "REAGENT"] = 2;
            values[valuesById[3] = "SOLVENT"] = 3;
            values[valuesById[4] = "CATALYST"] = 4;
            values[valuesById[5] = "WORKUP"] = 5;
            values[valuesById[6] = "INTERNAL_STANDARD"] = 6;
            values[valuesById[7] = "AUTHENTIC_STANDARD"] = 7;
            values[valuesById[8] = "PRODUCT"] = 8;
            values[valuesById[9] = "BYPRODUCT"] = 9;
            values[valuesById[10] = "SIDE_PRODUCT"] = 10;
            return values;
        })();

        return ReactionRole;
    })();

    ord.CompoundPreparation = (function() {

        /**
         * Properties of a CompoundPreparation.
         * @memberof ord
         * @interface ICompoundPreparation
         * @property {ord.CompoundPreparation.CompoundPreparationType|null} [type] CompoundPreparation type
         * @property {string|null} [details] CompoundPreparation details
         * @property {string|null} [reactionId] CompoundPreparation reactionId
         */

        /**
         * Constructs a new CompoundPreparation.
         * @memberof ord
         * @classdesc Compounds may undergo additional preparation before being used in a
         * reaction after being received from a supplier or vendor. We encourage
         * the use of the 'preparation' enum when possible, even if the description
         * is an oversimplification of the full procedure, which can be described
         * in the 'details' field.
         * @implements ICompoundPreparation
         * @constructor
         * @param {ord.ICompoundPreparation=} [properties] Properties to set
         */
        function CompoundPreparation(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CompoundPreparation type.
         * @member {ord.CompoundPreparation.CompoundPreparationType} type
         * @memberof ord.CompoundPreparation
         * @instance
         */
        CompoundPreparation.prototype.type = 0;

        /**
         * CompoundPreparation details.
         * @member {string} details
         * @memberof ord.CompoundPreparation
         * @instance
         */
        CompoundPreparation.prototype.details = "";

        /**
         * CompoundPreparation reactionId.
         * @member {string} reactionId
         * @memberof ord.CompoundPreparation
         * @instance
         */
        CompoundPreparation.prototype.reactionId = "";

        /**
         * Creates a new CompoundPreparation instance using the specified properties.
         * @function create
         * @memberof ord.CompoundPreparation
         * @static
         * @param {ord.ICompoundPreparation=} [properties] Properties to set
         * @returns {ord.CompoundPreparation} CompoundPreparation instance
         */
        CompoundPreparation.create = function create(properties) {
            return new CompoundPreparation(properties);
        };

        /**
         * Encodes the specified CompoundPreparation message. Does not implicitly {@link ord.CompoundPreparation.verify|verify} messages.
         * @function encode
         * @memberof ord.CompoundPreparation
         * @static
         * @param {ord.ICompoundPreparation} message CompoundPreparation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompoundPreparation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
            if (message.reactionId != null && Object.hasOwnProperty.call(message, "reactionId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.reactionId);
            return writer;
        };

        /**
         * Encodes the specified CompoundPreparation message, length delimited. Does not implicitly {@link ord.CompoundPreparation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.CompoundPreparation
         * @static
         * @param {ord.ICompoundPreparation} message CompoundPreparation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompoundPreparation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CompoundPreparation message from the specified reader or buffer.
         * @function decode
         * @memberof ord.CompoundPreparation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.CompoundPreparation} CompoundPreparation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompoundPreparation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.CompoundPreparation();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.details = reader.string();
                        break;
                    }
                case 3: {
                        message.reactionId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CompoundPreparation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.CompoundPreparation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.CompoundPreparation} CompoundPreparation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompoundPreparation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CompoundPreparation message.
         * @function verify
         * @memberof ord.CompoundPreparation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CompoundPreparation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.details != null && message.hasOwnProperty("details"))
                if (!$util.isString(message.details))
                    return "details: string expected";
            if (message.reactionId != null && message.hasOwnProperty("reactionId"))
                if (!$util.isString(message.reactionId))
                    return "reactionId: string expected";
            return null;
        };

        /**
         * Creates a CompoundPreparation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.CompoundPreparation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.CompoundPreparation} CompoundPreparation
         */
        CompoundPreparation.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.CompoundPreparation)
                return object;
            let message = new $root.ord.CompoundPreparation();
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.type = 0;
                break;
            case "CUSTOM":
            case 1:
                message.type = 1;
                break;
            case "NONE":
            case 2:
                message.type = 2;
                break;
            case "REPURIFIED":
            case 3:
                message.type = 3;
                break;
            case "SPARGED":
            case 4:
                message.type = 4;
                break;
            case "DRIED":
            case 5:
                message.type = 5;
                break;
            case "SYNTHESIZED":
            case 6:
                message.type = 6;
                break;
            }
            if (object.details != null)
                message.details = String(object.details);
            if (object.reactionId != null)
                message.reactionId = String(object.reactionId);
            return message;
        };

        /**
         * Creates a plain object from a CompoundPreparation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.CompoundPreparation
         * @static
         * @param {ord.CompoundPreparation} message CompoundPreparation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CompoundPreparation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "UNSPECIFIED" : 0;
                object.details = "";
                object.reactionId = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.ord.CompoundPreparation.CompoundPreparationType[message.type] === undefined ? message.type : $root.ord.CompoundPreparation.CompoundPreparationType[message.type] : message.type;
            if (message.details != null && message.hasOwnProperty("details"))
                object.details = message.details;
            if (message.reactionId != null && message.hasOwnProperty("reactionId"))
                object.reactionId = message.reactionId;
            return object;
        };

        /**
         * Converts this CompoundPreparation to JSON.
         * @function toJSON
         * @memberof ord.CompoundPreparation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CompoundPreparation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CompoundPreparation
         * @function getTypeUrl
         * @memberof ord.CompoundPreparation
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CompoundPreparation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.CompoundPreparation";
        };

        /**
         * CompoundPreparationType enum.
         * @name ord.CompoundPreparation.CompoundPreparationType
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} CUSTOM=1 CUSTOM value
         * @property {number} NONE=2 NONE value
         * @property {number} REPURIFIED=3 REPURIFIED value
         * @property {number} SPARGED=4 SPARGED value
         * @property {number} DRIED=5 DRIED value
         * @property {number} SYNTHESIZED=6 SYNTHESIZED value
         */
        CompoundPreparation.CompoundPreparationType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "CUSTOM"] = 1;
            values[valuesById[2] = "NONE"] = 2;
            values[valuesById[3] = "REPURIFIED"] = 3;
            values[valuesById[4] = "SPARGED"] = 4;
            values[valuesById[5] = "DRIED"] = 5;
            values[valuesById[6] = "SYNTHESIZED"] = 6;
            return values;
        })();

        return CompoundPreparation;
    })();

    ord.CompoundIdentifier = (function() {

        /**
         * Properties of a CompoundIdentifier.
         * @memberof ord
         * @interface ICompoundIdentifier
         * @property {ord.CompoundIdentifier.CompoundIdentifierType|null} [type] CompoundIdentifier type
         * @property {string|null} [details] CompoundIdentifier details
         * @property {string|null} [value] CompoundIdentifier value
         */

        /**
         * Constructs a new CompoundIdentifier.
         * @memberof ord
         * @classdesc Compound identifiers uniquely define a single (pure) chemical species.
         * While we encourage the use of SMILES strings, these do not work well in
         * all cases (e.g., handling tautomerism, axial chirality). Multiple
         * identifiers may be specified for a single compound to avoid ambiguity.
         * We discourage chemicals from being defined only by a name. For compounds
         * that are prepared or isolated as salts, the identifier should include
         * specification of which salt.
         * @implements ICompoundIdentifier
         * @constructor
         * @param {ord.ICompoundIdentifier=} [properties] Properties to set
         */
        function CompoundIdentifier(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CompoundIdentifier type.
         * @member {ord.CompoundIdentifier.CompoundIdentifierType} type
         * @memberof ord.CompoundIdentifier
         * @instance
         */
        CompoundIdentifier.prototype.type = 0;

        /**
         * CompoundIdentifier details.
         * @member {string} details
         * @memberof ord.CompoundIdentifier
         * @instance
         */
        CompoundIdentifier.prototype.details = "";

        /**
         * CompoundIdentifier value.
         * @member {string} value
         * @memberof ord.CompoundIdentifier
         * @instance
         */
        CompoundIdentifier.prototype.value = "";

        /**
         * Creates a new CompoundIdentifier instance using the specified properties.
         * @function create
         * @memberof ord.CompoundIdentifier
         * @static
         * @param {ord.ICompoundIdentifier=} [properties] Properties to set
         * @returns {ord.CompoundIdentifier} CompoundIdentifier instance
         */
        CompoundIdentifier.create = function create(properties) {
            return new CompoundIdentifier(properties);
        };

        /**
         * Encodes the specified CompoundIdentifier message. Does not implicitly {@link ord.CompoundIdentifier.verify|verify} messages.
         * @function encode
         * @memberof ord.CompoundIdentifier
         * @static
         * @param {ord.ICompoundIdentifier} message CompoundIdentifier message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompoundIdentifier.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified CompoundIdentifier message, length delimited. Does not implicitly {@link ord.CompoundIdentifier.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.CompoundIdentifier
         * @static
         * @param {ord.ICompoundIdentifier} message CompoundIdentifier message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompoundIdentifier.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CompoundIdentifier message from the specified reader or buffer.
         * @function decode
         * @memberof ord.CompoundIdentifier
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.CompoundIdentifier} CompoundIdentifier
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompoundIdentifier.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.CompoundIdentifier();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.details = reader.string();
                        break;
                    }
                case 3: {
                        message.value = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CompoundIdentifier message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.CompoundIdentifier
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.CompoundIdentifier} CompoundIdentifier
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompoundIdentifier.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CompoundIdentifier message.
         * @function verify
         * @memberof ord.CompoundIdentifier
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CompoundIdentifier.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                    break;
                }
            if (message.details != null && message.hasOwnProperty("details"))
                if (!$util.isString(message.details))
                    return "details: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };

        /**
         * Creates a CompoundIdentifier message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.CompoundIdentifier
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.CompoundIdentifier} CompoundIdentifier
         */
        CompoundIdentifier.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.CompoundIdentifier)
                return object;
            let message = new $root.ord.CompoundIdentifier();
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.type = 0;
                break;
            case "CUSTOM":
            case 1:
                message.type = 1;
                break;
            case "SMILES":
            case 2:
                message.type = 2;
                break;
            case "INCHI":
            case 3:
                message.type = 3;
                break;
            case "MOLBLOCK":
            case 4:
                message.type = 4;
                break;
            case "IUPAC_NAME":
            case 5:
                message.type = 5;
                break;
            case "NAME":
            case 6:
                message.type = 6;
                break;
            case "CAS_NUMBER":
            case 7:
                message.type = 7;
                break;
            case "PUBCHEM_CID":
            case 8:
                message.type = 8;
                break;
            case "CHEMSPIDER_ID":
            case 9:
                message.type = 9;
                break;
            case "CXSMILES":
            case 10:
                message.type = 10;
                break;
            case "INCHI_KEY":
            case 11:
                message.type = 11;
                break;
            case "XYZ":
            case 12:
                message.type = 12;
                break;
            case "UNIPROT_ID":
            case 13:
                message.type = 13;
                break;
            case "PDB_ID":
            case 14:
                message.type = 14;
                break;
            case "AMINO_ACID_SEQUENCE":
            case 15:
                message.type = 15;
                break;
            case "HELM":
            case 16:
                message.type = 16;
                break;
            case "MDL":
            case 17:
                message.type = 17;
                break;
            }
            if (object.details != null)
                message.details = String(object.details);
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a CompoundIdentifier message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.CompoundIdentifier
         * @static
         * @param {ord.CompoundIdentifier} message CompoundIdentifier
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CompoundIdentifier.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "UNSPECIFIED" : 0;
                object.details = "";
                object.value = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.ord.CompoundIdentifier.CompoundIdentifierType[message.type] === undefined ? message.type : $root.ord.CompoundIdentifier.CompoundIdentifierType[message.type] : message.type;
            if (message.details != null && message.hasOwnProperty("details"))
                object.details = message.details;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this CompoundIdentifier to JSON.
         * @function toJSON
         * @memberof ord.CompoundIdentifier
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CompoundIdentifier.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CompoundIdentifier
         * @function getTypeUrl
         * @memberof ord.CompoundIdentifier
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CompoundIdentifier.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.CompoundIdentifier";
        };

        /**
         * CompoundIdentifierType enum.
         * @name ord.CompoundIdentifier.CompoundIdentifierType
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} CUSTOM=1 CUSTOM value
         * @property {number} SMILES=2 SMILES value
         * @property {number} INCHI=3 INCHI value
         * @property {number} MOLBLOCK=4 MOLBLOCK value
         * @property {number} IUPAC_NAME=5 IUPAC_NAME value
         * @property {number} NAME=6 NAME value
         * @property {number} CAS_NUMBER=7 CAS_NUMBER value
         * @property {number} PUBCHEM_CID=8 PUBCHEM_CID value
         * @property {number} CHEMSPIDER_ID=9 CHEMSPIDER_ID value
         * @property {number} CXSMILES=10 CXSMILES value
         * @property {number} INCHI_KEY=11 INCHI_KEY value
         * @property {number} XYZ=12 XYZ value
         * @property {number} UNIPROT_ID=13 UNIPROT_ID value
         * @property {number} PDB_ID=14 PDB_ID value
         * @property {number} AMINO_ACID_SEQUENCE=15 AMINO_ACID_SEQUENCE value
         * @property {number} HELM=16 HELM value
         * @property {number} MDL=17 MDL value
         */
        CompoundIdentifier.CompoundIdentifierType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "CUSTOM"] = 1;
            values[valuesById[2] = "SMILES"] = 2;
            values[valuesById[3] = "INCHI"] = 3;
            values[valuesById[4] = "MOLBLOCK"] = 4;
            values[valuesById[5] = "IUPAC_NAME"] = 5;
            values[valuesById[6] = "NAME"] = 6;
            values[valuesById[7] = "CAS_NUMBER"] = 7;
            values[valuesById[8] = "PUBCHEM_CID"] = 8;
            values[valuesById[9] = "CHEMSPIDER_ID"] = 9;
            values[valuesById[10] = "CXSMILES"] = 10;
            values[valuesById[11] = "INCHI_KEY"] = 11;
            values[valuesById[12] = "XYZ"] = 12;
            values[valuesById[13] = "UNIPROT_ID"] = 13;
            values[valuesById[14] = "PDB_ID"] = 14;
            values[valuesById[15] = "AMINO_ACID_SEQUENCE"] = 15;
            values[valuesById[16] = "HELM"] = 16;
            values[valuesById[17] = "MDL"] = 17;
            return values;
        })();

        return CompoundIdentifier;
    })();

    ord.Vessel = (function() {

        /**
         * Properties of a Vessel.
         * @memberof ord
         * @interface IVessel
         * @property {ord.Vessel.VesselType|null} [type] Vessel type
         * @property {string|null} [details] Vessel details
         * @property {ord.IVesselMaterial|null} [material] Vessel material
         * @property {Array.<ord.IVesselPreparation>|null} [preparations] Vessel preparations
         * @property {Array.<ord.IVesselAttachment>|null} [attachments] Vessel attachments
         * @property {ord.IVolume|null} [volume] Vessel volume
         * @property {string|null} [vesselId] Vessel vesselId
         * @property {string|null} [position] Vessel position
         * @property {string|null} [row] Vessel row
         * @property {string|null} [col] Vessel col
         */

        /**
         * Constructs a new Vessel.
         * @memberof ord
         * @classdesc The Vessel defines the primary container within which the reaction was
         * performed, including the type of vessel, its primary material, any
         * preparation steps or vessel attachments, and its volume.
         * @implements IVessel
         * @constructor
         * @param {ord.IVessel=} [properties] Properties to set
         */
        function Vessel(properties) {
            this.preparations = [];
            this.attachments = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Vessel type.
         * @member {ord.Vessel.VesselType} type
         * @memberof ord.Vessel
         * @instance
         */
        Vessel.prototype.type = 0;

        /**
         * Vessel details.
         * @member {string} details
         * @memberof ord.Vessel
         * @instance
         */
        Vessel.prototype.details = "";

        /**
         * Vessel material.
         * @member {ord.IVesselMaterial|null|undefined} material
         * @memberof ord.Vessel
         * @instance
         */
        Vessel.prototype.material = null;

        /**
         * Vessel preparations.
         * @member {Array.<ord.IVesselPreparation>} preparations
         * @memberof ord.Vessel
         * @instance
         */
        Vessel.prototype.preparations = $util.emptyArray;

        /**
         * Vessel attachments.
         * @member {Array.<ord.IVesselAttachment>} attachments
         * @memberof ord.Vessel
         * @instance
         */
        Vessel.prototype.attachments = $util.emptyArray;

        /**
         * Vessel volume.
         * @member {ord.IVolume|null|undefined} volume
         * @memberof ord.Vessel
         * @instance
         */
        Vessel.prototype.volume = null;

        /**
         * Vessel vesselId.
         * @member {string} vesselId
         * @memberof ord.Vessel
         * @instance
         */
        Vessel.prototype.vesselId = "";

        /**
         * Vessel position.
         * @member {string} position
         * @memberof ord.Vessel
         * @instance
         */
        Vessel.prototype.position = "";

        /**
         * Vessel row.
         * @member {string} row
         * @memberof ord.Vessel
         * @instance
         */
        Vessel.prototype.row = "";

        /**
         * Vessel col.
         * @member {string} col
         * @memberof ord.Vessel
         * @instance
         */
        Vessel.prototype.col = "";

        /**
         * Creates a new Vessel instance using the specified properties.
         * @function create
         * @memberof ord.Vessel
         * @static
         * @param {ord.IVessel=} [properties] Properties to set
         * @returns {ord.Vessel} Vessel instance
         */
        Vessel.create = function create(properties) {
            return new Vessel(properties);
        };

        /**
         * Encodes the specified Vessel message. Does not implicitly {@link ord.Vessel.verify|verify} messages.
         * @function encode
         * @memberof ord.Vessel
         * @static
         * @param {ord.IVessel} message Vessel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Vessel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
            if (message.material != null && Object.hasOwnProperty.call(message, "material"))
                $root.ord.VesselMaterial.encode(message.material, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.preparations != null && message.preparations.length)
                for (let i = 0; i < message.preparations.length; ++i)
                    $root.ord.VesselPreparation.encode(message.preparations[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.attachments != null && message.attachments.length)
                for (let i = 0; i < message.attachments.length; ++i)
                    $root.ord.VesselAttachment.encode(message.attachments[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.volume != null && Object.hasOwnProperty.call(message, "volume"))
                $root.ord.Volume.encode(message.volume, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.vesselId != null && Object.hasOwnProperty.call(message, "vesselId"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.vesselId);
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.position);
            if (message.row != null && Object.hasOwnProperty.call(message, "row"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.row);
            if (message.col != null && Object.hasOwnProperty.call(message, "col"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.col);
            return writer;
        };

        /**
         * Encodes the specified Vessel message, length delimited. Does not implicitly {@link ord.Vessel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.Vessel
         * @static
         * @param {ord.IVessel} message Vessel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Vessel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Vessel message from the specified reader or buffer.
         * @function decode
         * @memberof ord.Vessel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.Vessel} Vessel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Vessel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.Vessel();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.details = reader.string();
                        break;
                    }
                case 3: {
                        message.material = $root.ord.VesselMaterial.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        if (!(message.preparations && message.preparations.length))
                            message.preparations = [];
                        message.preparations.push($root.ord.VesselPreparation.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        if (!(message.attachments && message.attachments.length))
                            message.attachments = [];
                        message.attachments.push($root.ord.VesselAttachment.decode(reader, reader.uint32()));
                        break;
                    }
                case 6: {
                        message.volume = $root.ord.Volume.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.vesselId = reader.string();
                        break;
                    }
                case 8: {
                        message.position = reader.string();
                        break;
                    }
                case 9: {
                        message.row = reader.string();
                        break;
                    }
                case 10: {
                        message.col = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Vessel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.Vessel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.Vessel} Vessel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Vessel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Vessel message.
         * @function verify
         * @memberof ord.Vessel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Vessel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                    break;
                }
            if (message.details != null && message.hasOwnProperty("details"))
                if (!$util.isString(message.details))
                    return "details: string expected";
            if (message.material != null && message.hasOwnProperty("material")) {
                let error = $root.ord.VesselMaterial.verify(message.material);
                if (error)
                    return "material." + error;
            }
            if (message.preparations != null && message.hasOwnProperty("preparations")) {
                if (!Array.isArray(message.preparations))
                    return "preparations: array expected";
                for (let i = 0; i < message.preparations.length; ++i) {
                    let error = $root.ord.VesselPreparation.verify(message.preparations[i]);
                    if (error)
                        return "preparations." + error;
                }
            }
            if (message.attachments != null && message.hasOwnProperty("attachments")) {
                if (!Array.isArray(message.attachments))
                    return "attachments: array expected";
                for (let i = 0; i < message.attachments.length; ++i) {
                    let error = $root.ord.VesselAttachment.verify(message.attachments[i]);
                    if (error)
                        return "attachments." + error;
                }
            }
            if (message.volume != null && message.hasOwnProperty("volume")) {
                let error = $root.ord.Volume.verify(message.volume);
                if (error)
                    return "volume." + error;
            }
            if (message.vesselId != null && message.hasOwnProperty("vesselId"))
                if (!$util.isString(message.vesselId))
                    return "vesselId: string expected";
            if (message.position != null && message.hasOwnProperty("position"))
                if (!$util.isString(message.position))
                    return "position: string expected";
            if (message.row != null && message.hasOwnProperty("row"))
                if (!$util.isString(message.row))
                    return "row: string expected";
            if (message.col != null && message.hasOwnProperty("col"))
                if (!$util.isString(message.col))
                    return "col: string expected";
            return null;
        };

        /**
         * Creates a Vessel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.Vessel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.Vessel} Vessel
         */
        Vessel.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.Vessel)
                return object;
            let message = new $root.ord.Vessel();
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.type = 0;
                break;
            case "CUSTOM":
            case 1:
                message.type = 1;
                break;
            case "ROUND_BOTTOM_FLASK":
            case 2:
                message.type = 2;
                break;
            case "VIAL":
            case 3:
                message.type = 3;
                break;
            case "WELL_PLATE":
            case 4:
                message.type = 4;
                break;
            case "MICROWAVE_VIAL":
            case 5:
                message.type = 5;
                break;
            case "TUBE":
            case 6:
                message.type = 6;
                break;
            case "CONTINUOUS_STIRRED_TANK_REACTOR":
            case 7:
                message.type = 7;
                break;
            case "PACKED_BED_REACTOR":
            case 8:
                message.type = 8;
                break;
            case "NMR_TUBE":
            case 9:
                message.type = 9;
                break;
            case "PRESSURE_FLASK":
            case 10:
                message.type = 10;
                break;
            case "PRESSURE_REACTOR":
            case 11:
                message.type = 11;
                break;
            case "ELECTROCHEMICAL_CELL":
            case 12:
                message.type = 12;
                break;
            }
            if (object.details != null)
                message.details = String(object.details);
            if (object.material != null) {
                if (typeof object.material !== "object")
                    throw TypeError(".ord.Vessel.material: object expected");
                message.material = $root.ord.VesselMaterial.fromObject(object.material);
            }
            if (object.preparations) {
                if (!Array.isArray(object.preparations))
                    throw TypeError(".ord.Vessel.preparations: array expected");
                message.preparations = [];
                for (let i = 0; i < object.preparations.length; ++i) {
                    if (typeof object.preparations[i] !== "object")
                        throw TypeError(".ord.Vessel.preparations: object expected");
                    message.preparations[i] = $root.ord.VesselPreparation.fromObject(object.preparations[i]);
                }
            }
            if (object.attachments) {
                if (!Array.isArray(object.attachments))
                    throw TypeError(".ord.Vessel.attachments: array expected");
                message.attachments = [];
                for (let i = 0; i < object.attachments.length; ++i) {
                    if (typeof object.attachments[i] !== "object")
                        throw TypeError(".ord.Vessel.attachments: object expected");
                    message.attachments[i] = $root.ord.VesselAttachment.fromObject(object.attachments[i]);
                }
            }
            if (object.volume != null) {
                if (typeof object.volume !== "object")
                    throw TypeError(".ord.Vessel.volume: object expected");
                message.volume = $root.ord.Volume.fromObject(object.volume);
            }
            if (object.vesselId != null)
                message.vesselId = String(object.vesselId);
            if (object.position != null)
                message.position = String(object.position);
            if (object.row != null)
                message.row = String(object.row);
            if (object.col != null)
                message.col = String(object.col);
            return message;
        };

        /**
         * Creates a plain object from a Vessel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.Vessel
         * @static
         * @param {ord.Vessel} message Vessel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Vessel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.preparations = [];
                object.attachments = [];
            }
            if (options.defaults) {
                object.type = options.enums === String ? "UNSPECIFIED" : 0;
                object.details = "";
                object.material = null;
                object.volume = null;
                object.vesselId = "";
                object.position = "";
                object.row = "";
                object.col = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.ord.Vessel.VesselType[message.type] === undefined ? message.type : $root.ord.Vessel.VesselType[message.type] : message.type;
            if (message.details != null && message.hasOwnProperty("details"))
                object.details = message.details;
            if (message.material != null && message.hasOwnProperty("material"))
                object.material = $root.ord.VesselMaterial.toObject(message.material, options);
            if (message.preparations && message.preparations.length) {
                object.preparations = [];
                for (let j = 0; j < message.preparations.length; ++j)
                    object.preparations[j] = $root.ord.VesselPreparation.toObject(message.preparations[j], options);
            }
            if (message.attachments && message.attachments.length) {
                object.attachments = [];
                for (let j = 0; j < message.attachments.length; ++j)
                    object.attachments[j] = $root.ord.VesselAttachment.toObject(message.attachments[j], options);
            }
            if (message.volume != null && message.hasOwnProperty("volume"))
                object.volume = $root.ord.Volume.toObject(message.volume, options);
            if (message.vesselId != null && message.hasOwnProperty("vesselId"))
                object.vesselId = message.vesselId;
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = message.position;
            if (message.row != null && message.hasOwnProperty("row"))
                object.row = message.row;
            if (message.col != null && message.hasOwnProperty("col"))
                object.col = message.col;
            return object;
        };

        /**
         * Converts this Vessel to JSON.
         * @function toJSON
         * @memberof ord.Vessel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Vessel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Vessel
         * @function getTypeUrl
         * @memberof ord.Vessel
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Vessel.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.Vessel";
        };

        /**
         * VesselType enum.
         * @name ord.Vessel.VesselType
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} CUSTOM=1 CUSTOM value
         * @property {number} ROUND_BOTTOM_FLASK=2 ROUND_BOTTOM_FLASK value
         * @property {number} VIAL=3 VIAL value
         * @property {number} WELL_PLATE=4 WELL_PLATE value
         * @property {number} MICROWAVE_VIAL=5 MICROWAVE_VIAL value
         * @property {number} TUBE=6 TUBE value
         * @property {number} CONTINUOUS_STIRRED_TANK_REACTOR=7 CONTINUOUS_STIRRED_TANK_REACTOR value
         * @property {number} PACKED_BED_REACTOR=8 PACKED_BED_REACTOR value
         * @property {number} NMR_TUBE=9 NMR_TUBE value
         * @property {number} PRESSURE_FLASK=10 PRESSURE_FLASK value
         * @property {number} PRESSURE_REACTOR=11 PRESSURE_REACTOR value
         * @property {number} ELECTROCHEMICAL_CELL=12 ELECTROCHEMICAL_CELL value
         */
        Vessel.VesselType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "CUSTOM"] = 1;
            values[valuesById[2] = "ROUND_BOTTOM_FLASK"] = 2;
            values[valuesById[3] = "VIAL"] = 3;
            values[valuesById[4] = "WELL_PLATE"] = 4;
            values[valuesById[5] = "MICROWAVE_VIAL"] = 5;
            values[valuesById[6] = "TUBE"] = 6;
            values[valuesById[7] = "CONTINUOUS_STIRRED_TANK_REACTOR"] = 7;
            values[valuesById[8] = "PACKED_BED_REACTOR"] = 8;
            values[valuesById[9] = "NMR_TUBE"] = 9;
            values[valuesById[10] = "PRESSURE_FLASK"] = 10;
            values[valuesById[11] = "PRESSURE_REACTOR"] = 11;
            values[valuesById[12] = "ELECTROCHEMICAL_CELL"] = 12;
            return values;
        })();

        return Vessel;
    })();

    ord.VesselMaterial = (function() {

        /**
         * Properties of a VesselMaterial.
         * @memberof ord
         * @interface IVesselMaterial
         * @property {ord.VesselMaterial.VesselMaterialType|null} [type] VesselMaterial type
         * @property {string|null} [details] VesselMaterial details
         */

        /**
         * Constructs a new VesselMaterial.
         * @memberof ord
         * @classdesc Represents a VesselMaterial.
         * @implements IVesselMaterial
         * @constructor
         * @param {ord.IVesselMaterial=} [properties] Properties to set
         */
        function VesselMaterial(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VesselMaterial type.
         * @member {ord.VesselMaterial.VesselMaterialType} type
         * @memberof ord.VesselMaterial
         * @instance
         */
        VesselMaterial.prototype.type = 0;

        /**
         * VesselMaterial details.
         * @member {string} details
         * @memberof ord.VesselMaterial
         * @instance
         */
        VesselMaterial.prototype.details = "";

        /**
         * Creates a new VesselMaterial instance using the specified properties.
         * @function create
         * @memberof ord.VesselMaterial
         * @static
         * @param {ord.IVesselMaterial=} [properties] Properties to set
         * @returns {ord.VesselMaterial} VesselMaterial instance
         */
        VesselMaterial.create = function create(properties) {
            return new VesselMaterial(properties);
        };

        /**
         * Encodes the specified VesselMaterial message. Does not implicitly {@link ord.VesselMaterial.verify|verify} messages.
         * @function encode
         * @memberof ord.VesselMaterial
         * @static
         * @param {ord.IVesselMaterial} message VesselMaterial message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VesselMaterial.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
            return writer;
        };

        /**
         * Encodes the specified VesselMaterial message, length delimited. Does not implicitly {@link ord.VesselMaterial.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.VesselMaterial
         * @static
         * @param {ord.IVesselMaterial} message VesselMaterial message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VesselMaterial.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VesselMaterial message from the specified reader or buffer.
         * @function decode
         * @memberof ord.VesselMaterial
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.VesselMaterial} VesselMaterial
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VesselMaterial.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.VesselMaterial();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.details = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VesselMaterial message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.VesselMaterial
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.VesselMaterial} VesselMaterial
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VesselMaterial.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VesselMaterial message.
         * @function verify
         * @memberof ord.VesselMaterial
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VesselMaterial.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.details != null && message.hasOwnProperty("details"))
                if (!$util.isString(message.details))
                    return "details: string expected";
            return null;
        };

        /**
         * Creates a VesselMaterial message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.VesselMaterial
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.VesselMaterial} VesselMaterial
         */
        VesselMaterial.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.VesselMaterial)
                return object;
            let message = new $root.ord.VesselMaterial();
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.type = 0;
                break;
            case "CUSTOM":
            case 1:
                message.type = 1;
                break;
            case "GLASS":
            case 2:
                message.type = 2;
                break;
            case "POLYPROPYLENE":
            case 3:
                message.type = 3;
                break;
            case "PLASTIC":
            case 4:
                message.type = 4;
                break;
            case "METAL":
            case 5:
                message.type = 5;
                break;
            case "QUARTZ":
            case 6:
                message.type = 6;
                break;
            }
            if (object.details != null)
                message.details = String(object.details);
            return message;
        };

        /**
         * Creates a plain object from a VesselMaterial message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.VesselMaterial
         * @static
         * @param {ord.VesselMaterial} message VesselMaterial
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VesselMaterial.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "UNSPECIFIED" : 0;
                object.details = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.ord.VesselMaterial.VesselMaterialType[message.type] === undefined ? message.type : $root.ord.VesselMaterial.VesselMaterialType[message.type] : message.type;
            if (message.details != null && message.hasOwnProperty("details"))
                object.details = message.details;
            return object;
        };

        /**
         * Converts this VesselMaterial to JSON.
         * @function toJSON
         * @memberof ord.VesselMaterial
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VesselMaterial.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for VesselMaterial
         * @function getTypeUrl
         * @memberof ord.VesselMaterial
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        VesselMaterial.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.VesselMaterial";
        };

        /**
         * VesselMaterialType enum.
         * @name ord.VesselMaterial.VesselMaterialType
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} CUSTOM=1 CUSTOM value
         * @property {number} GLASS=2 GLASS value
         * @property {number} POLYPROPYLENE=3 POLYPROPYLENE value
         * @property {number} PLASTIC=4 PLASTIC value
         * @property {number} METAL=5 METAL value
         * @property {number} QUARTZ=6 QUARTZ value
         */
        VesselMaterial.VesselMaterialType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "CUSTOM"] = 1;
            values[valuesById[2] = "GLASS"] = 2;
            values[valuesById[3] = "POLYPROPYLENE"] = 3;
            values[valuesById[4] = "PLASTIC"] = 4;
            values[valuesById[5] = "METAL"] = 5;
            values[valuesById[6] = "QUARTZ"] = 6;
            return values;
        })();

        return VesselMaterial;
    })();

    ord.VesselAttachment = (function() {

        /**
         * Properties of a VesselAttachment.
         * @memberof ord
         * @interface IVesselAttachment
         * @property {ord.VesselAttachment.VesselAttachmentType|null} [type] VesselAttachment type
         * @property {string|null} [details] VesselAttachment details
         */

        /**
         * Constructs a new VesselAttachment.
         * @memberof ord
         * @classdesc Represents a VesselAttachment.
         * @implements IVesselAttachment
         * @constructor
         * @param {ord.IVesselAttachment=} [properties] Properties to set
         */
        function VesselAttachment(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VesselAttachment type.
         * @member {ord.VesselAttachment.VesselAttachmentType} type
         * @memberof ord.VesselAttachment
         * @instance
         */
        VesselAttachment.prototype.type = 0;

        /**
         * VesselAttachment details.
         * @member {string} details
         * @memberof ord.VesselAttachment
         * @instance
         */
        VesselAttachment.prototype.details = "";

        /**
         * Creates a new VesselAttachment instance using the specified properties.
         * @function create
         * @memberof ord.VesselAttachment
         * @static
         * @param {ord.IVesselAttachment=} [properties] Properties to set
         * @returns {ord.VesselAttachment} VesselAttachment instance
         */
        VesselAttachment.create = function create(properties) {
            return new VesselAttachment(properties);
        };

        /**
         * Encodes the specified VesselAttachment message. Does not implicitly {@link ord.VesselAttachment.verify|verify} messages.
         * @function encode
         * @memberof ord.VesselAttachment
         * @static
         * @param {ord.IVesselAttachment} message VesselAttachment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VesselAttachment.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
            return writer;
        };

        /**
         * Encodes the specified VesselAttachment message, length delimited. Does not implicitly {@link ord.VesselAttachment.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.VesselAttachment
         * @static
         * @param {ord.IVesselAttachment} message VesselAttachment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VesselAttachment.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VesselAttachment message from the specified reader or buffer.
         * @function decode
         * @memberof ord.VesselAttachment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.VesselAttachment} VesselAttachment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VesselAttachment.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.VesselAttachment();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.details = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VesselAttachment message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.VesselAttachment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.VesselAttachment} VesselAttachment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VesselAttachment.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VesselAttachment message.
         * @function verify
         * @memberof ord.VesselAttachment
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VesselAttachment.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                    break;
                }
            if (message.details != null && message.hasOwnProperty("details"))
                if (!$util.isString(message.details))
                    return "details: string expected";
            return null;
        };

        /**
         * Creates a VesselAttachment message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.VesselAttachment
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.VesselAttachment} VesselAttachment
         */
        VesselAttachment.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.VesselAttachment)
                return object;
            let message = new $root.ord.VesselAttachment();
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.type = 0;
                break;
            case "NONE":
            case 1:
                message.type = 1;
                break;
            case "CUSTOM":
            case 2:
                message.type = 2;
                break;
            case "SEPTUM":
            case 3:
                message.type = 3;
                break;
            case "CAP":
            case 4:
                message.type = 4;
                break;
            case "MAT":
            case 5:
                message.type = 5;
                break;
            case "REFLUX_CONDENSER":
            case 6:
                message.type = 6;
                break;
            case "VENT_NEEDLE":
            case 7:
                message.type = 7;
                break;
            case "DEAN_STARK":
            case 8:
                message.type = 8;
                break;
            case "VACUUM_TUBE":
            case 9:
                message.type = 9;
                break;
            case "ADDITION_FUNNEL":
            case 10:
                message.type = 10;
                break;
            case "DRYING_TUBE":
            case 11:
                message.type = 11;
                break;
            case "ALUMINUM_FOIL":
            case 12:
                message.type = 12;
                break;
            case "THERMOCOUPLE":
            case 13:
                message.type = 13;
                break;
            case "BALLOON":
            case 14:
                message.type = 14;
                break;
            case "GAS_ADAPTER":
            case 15:
                message.type = 15;
                break;
            case "PRESSURE_REGULATOR":
            case 16:
                message.type = 16;
                break;
            case "RELEASE_VALVE":
            case 17:
                message.type = 17;
                break;
            }
            if (object.details != null)
                message.details = String(object.details);
            return message;
        };

        /**
         * Creates a plain object from a VesselAttachment message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.VesselAttachment
         * @static
         * @param {ord.VesselAttachment} message VesselAttachment
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VesselAttachment.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "UNSPECIFIED" : 0;
                object.details = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.ord.VesselAttachment.VesselAttachmentType[message.type] === undefined ? message.type : $root.ord.VesselAttachment.VesselAttachmentType[message.type] : message.type;
            if (message.details != null && message.hasOwnProperty("details"))
                object.details = message.details;
            return object;
        };

        /**
         * Converts this VesselAttachment to JSON.
         * @function toJSON
         * @memberof ord.VesselAttachment
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VesselAttachment.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for VesselAttachment
         * @function getTypeUrl
         * @memberof ord.VesselAttachment
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        VesselAttachment.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.VesselAttachment";
        };

        /**
         * VesselAttachmentType enum.
         * @name ord.VesselAttachment.VesselAttachmentType
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} NONE=1 NONE value
         * @property {number} CUSTOM=2 CUSTOM value
         * @property {number} SEPTUM=3 SEPTUM value
         * @property {number} CAP=4 CAP value
         * @property {number} MAT=5 MAT value
         * @property {number} REFLUX_CONDENSER=6 REFLUX_CONDENSER value
         * @property {number} VENT_NEEDLE=7 VENT_NEEDLE value
         * @property {number} DEAN_STARK=8 DEAN_STARK value
         * @property {number} VACUUM_TUBE=9 VACUUM_TUBE value
         * @property {number} ADDITION_FUNNEL=10 ADDITION_FUNNEL value
         * @property {number} DRYING_TUBE=11 DRYING_TUBE value
         * @property {number} ALUMINUM_FOIL=12 ALUMINUM_FOIL value
         * @property {number} THERMOCOUPLE=13 THERMOCOUPLE value
         * @property {number} BALLOON=14 BALLOON value
         * @property {number} GAS_ADAPTER=15 GAS_ADAPTER value
         * @property {number} PRESSURE_REGULATOR=16 PRESSURE_REGULATOR value
         * @property {number} RELEASE_VALVE=17 RELEASE_VALVE value
         */
        VesselAttachment.VesselAttachmentType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "NONE"] = 1;
            values[valuesById[2] = "CUSTOM"] = 2;
            values[valuesById[3] = "SEPTUM"] = 3;
            values[valuesById[4] = "CAP"] = 4;
            values[valuesById[5] = "MAT"] = 5;
            values[valuesById[6] = "REFLUX_CONDENSER"] = 6;
            values[valuesById[7] = "VENT_NEEDLE"] = 7;
            values[valuesById[8] = "DEAN_STARK"] = 8;
            values[valuesById[9] = "VACUUM_TUBE"] = 9;
            values[valuesById[10] = "ADDITION_FUNNEL"] = 10;
            values[valuesById[11] = "DRYING_TUBE"] = 11;
            values[valuesById[12] = "ALUMINUM_FOIL"] = 12;
            values[valuesById[13] = "THERMOCOUPLE"] = 13;
            values[valuesById[14] = "BALLOON"] = 14;
            values[valuesById[15] = "GAS_ADAPTER"] = 15;
            values[valuesById[16] = "PRESSURE_REGULATOR"] = 16;
            values[valuesById[17] = "RELEASE_VALVE"] = 17;
            return values;
        })();

        return VesselAttachment;
    })();

    ord.VesselPreparation = (function() {

        /**
         * Properties of a VesselPreparation.
         * @memberof ord
         * @interface IVesselPreparation
         * @property {ord.VesselPreparation.VesselPreparationType|null} [type] VesselPreparation type
         * @property {string|null} [details] VesselPreparation details
         */

        /**
         * Constructs a new VesselPreparation.
         * @memberof ord
         * @classdesc Represents a VesselPreparation.
         * @implements IVesselPreparation
         * @constructor
         * @param {ord.IVesselPreparation=} [properties] Properties to set
         */
        function VesselPreparation(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VesselPreparation type.
         * @member {ord.VesselPreparation.VesselPreparationType} type
         * @memberof ord.VesselPreparation
         * @instance
         */
        VesselPreparation.prototype.type = 0;

        /**
         * VesselPreparation details.
         * @member {string} details
         * @memberof ord.VesselPreparation
         * @instance
         */
        VesselPreparation.prototype.details = "";

        /**
         * Creates a new VesselPreparation instance using the specified properties.
         * @function create
         * @memberof ord.VesselPreparation
         * @static
         * @param {ord.IVesselPreparation=} [properties] Properties to set
         * @returns {ord.VesselPreparation} VesselPreparation instance
         */
        VesselPreparation.create = function create(properties) {
            return new VesselPreparation(properties);
        };

        /**
         * Encodes the specified VesselPreparation message. Does not implicitly {@link ord.VesselPreparation.verify|verify} messages.
         * @function encode
         * @memberof ord.VesselPreparation
         * @static
         * @param {ord.IVesselPreparation} message VesselPreparation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VesselPreparation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
            return writer;
        };

        /**
         * Encodes the specified VesselPreparation message, length delimited. Does not implicitly {@link ord.VesselPreparation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.VesselPreparation
         * @static
         * @param {ord.IVesselPreparation} message VesselPreparation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VesselPreparation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VesselPreparation message from the specified reader or buffer.
         * @function decode
         * @memberof ord.VesselPreparation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.VesselPreparation} VesselPreparation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VesselPreparation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.VesselPreparation();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.details = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VesselPreparation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.VesselPreparation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.VesselPreparation} VesselPreparation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VesselPreparation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VesselPreparation message.
         * @function verify
         * @memberof ord.VesselPreparation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VesselPreparation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.details != null && message.hasOwnProperty("details"))
                if (!$util.isString(message.details))
                    return "details: string expected";
            return null;
        };

        /**
         * Creates a VesselPreparation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.VesselPreparation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.VesselPreparation} VesselPreparation
         */
        VesselPreparation.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.VesselPreparation)
                return object;
            let message = new $root.ord.VesselPreparation();
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.type = 0;
                break;
            case "CUSTOM":
            case 1:
                message.type = 1;
                break;
            case "NONE":
            case 2:
                message.type = 2;
                break;
            case "OVEN_DRIED":
            case 3:
                message.type = 3;
                break;
            case "FLAME_DRIED":
            case 4:
                message.type = 4;
                break;
            case "EVACUATED_BACKFILLED":
            case 5:
                message.type = 5;
                break;
            case "PURGED":
            case 6:
                message.type = 6;
                break;
            }
            if (object.details != null)
                message.details = String(object.details);
            return message;
        };

        /**
         * Creates a plain object from a VesselPreparation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.VesselPreparation
         * @static
         * @param {ord.VesselPreparation} message VesselPreparation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VesselPreparation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "UNSPECIFIED" : 0;
                object.details = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.ord.VesselPreparation.VesselPreparationType[message.type] === undefined ? message.type : $root.ord.VesselPreparation.VesselPreparationType[message.type] : message.type;
            if (message.details != null && message.hasOwnProperty("details"))
                object.details = message.details;
            return object;
        };

        /**
         * Converts this VesselPreparation to JSON.
         * @function toJSON
         * @memberof ord.VesselPreparation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VesselPreparation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for VesselPreparation
         * @function getTypeUrl
         * @memberof ord.VesselPreparation
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        VesselPreparation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.VesselPreparation";
        };

        /**
         * VesselPreparationType enum.
         * @name ord.VesselPreparation.VesselPreparationType
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} CUSTOM=1 CUSTOM value
         * @property {number} NONE=2 NONE value
         * @property {number} OVEN_DRIED=3 OVEN_DRIED value
         * @property {number} FLAME_DRIED=4 FLAME_DRIED value
         * @property {number} EVACUATED_BACKFILLED=5 EVACUATED_BACKFILLED value
         * @property {number} PURGED=6 PURGED value
         */
        VesselPreparation.VesselPreparationType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "CUSTOM"] = 1;
            values[valuesById[2] = "NONE"] = 2;
            values[valuesById[3] = "OVEN_DRIED"] = 3;
            values[valuesById[4] = "FLAME_DRIED"] = 4;
            values[valuesById[5] = "EVACUATED_BACKFILLED"] = 5;
            values[valuesById[6] = "PURGED"] = 6;
            return values;
        })();

        return VesselPreparation;
    })();

    ord.ReactionSetup = (function() {

        /**
         * Properties of a ReactionSetup.
         * @memberof ord
         * @interface IReactionSetup
         * @property {ord.IVessel|null} [vessel] ReactionSetup vessel
         * @property {boolean|null} [isAutomated] ReactionSetup isAutomated
         * @property {string|null} [automationPlatform] ReactionSetup automationPlatform
         * @property {Object.<string,ord.IData>|null} [automationCode] ReactionSetup automationCode
         * @property {ord.ReactionSetup.IReactionEnvironment|null} [environment] ReactionSetup environment
         */

        /**
         * Constructs a new ReactionSetup.
         * @memberof ord
         * @classdesc Represents a ReactionSetup.
         * @implements IReactionSetup
         * @constructor
         * @param {ord.IReactionSetup=} [properties] Properties to set
         */
        function ReactionSetup(properties) {
            this.automationCode = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReactionSetup vessel.
         * @member {ord.IVessel|null|undefined} vessel
         * @memberof ord.ReactionSetup
         * @instance
         */
        ReactionSetup.prototype.vessel = null;

        /**
         * ReactionSetup isAutomated.
         * @member {boolean|null|undefined} isAutomated
         * @memberof ord.ReactionSetup
         * @instance
         */
        ReactionSetup.prototype.isAutomated = null;

        /**
         * ReactionSetup automationPlatform.
         * @member {string} automationPlatform
         * @memberof ord.ReactionSetup
         * @instance
         */
        ReactionSetup.prototype.automationPlatform = "";

        /**
         * ReactionSetup automationCode.
         * @member {Object.<string,ord.IData>} automationCode
         * @memberof ord.ReactionSetup
         * @instance
         */
        ReactionSetup.prototype.automationCode = $util.emptyObject;

        /**
         * ReactionSetup environment.
         * @member {ord.ReactionSetup.IReactionEnvironment|null|undefined} environment
         * @memberof ord.ReactionSetup
         * @instance
         */
        ReactionSetup.prototype.environment = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(ReactionSetup.prototype, "_isAutomated", {
            get: $util.oneOfGetter($oneOfFields = ["isAutomated"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ReactionSetup instance using the specified properties.
         * @function create
         * @memberof ord.ReactionSetup
         * @static
         * @param {ord.IReactionSetup=} [properties] Properties to set
         * @returns {ord.ReactionSetup} ReactionSetup instance
         */
        ReactionSetup.create = function create(properties) {
            return new ReactionSetup(properties);
        };

        /**
         * Encodes the specified ReactionSetup message. Does not implicitly {@link ord.ReactionSetup.verify|verify} messages.
         * @function encode
         * @memberof ord.ReactionSetup
         * @static
         * @param {ord.IReactionSetup} message ReactionSetup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReactionSetup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.vessel != null && Object.hasOwnProperty.call(message, "vessel"))
                $root.ord.Vessel.encode(message.vessel, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.isAutomated != null && Object.hasOwnProperty.call(message, "isAutomated"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isAutomated);
            if (message.automationPlatform != null && Object.hasOwnProperty.call(message, "automationPlatform"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.automationPlatform);
            if (message.automationCode != null && Object.hasOwnProperty.call(message, "automationCode"))
                for (let keys = Object.keys(message.automationCode), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.ord.Data.encode(message.automationCode[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.environment != null && Object.hasOwnProperty.call(message, "environment"))
                $root.ord.ReactionSetup.ReactionEnvironment.encode(message.environment, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ReactionSetup message, length delimited. Does not implicitly {@link ord.ReactionSetup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.ReactionSetup
         * @static
         * @param {ord.IReactionSetup} message ReactionSetup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReactionSetup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReactionSetup message from the specified reader or buffer.
         * @function decode
         * @memberof ord.ReactionSetup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.ReactionSetup} ReactionSetup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReactionSetup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.ReactionSetup(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.vessel = $root.ord.Vessel.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.isAutomated = reader.bool();
                        break;
                    }
                case 3: {
                        message.automationPlatform = reader.string();
                        break;
                    }
                case 4: {
                        if (message.automationCode === $util.emptyObject)
                            message.automationCode = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.ord.Data.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.automationCode[key] = value;
                        break;
                    }
                case 5: {
                        message.environment = $root.ord.ReactionSetup.ReactionEnvironment.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReactionSetup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.ReactionSetup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.ReactionSetup} ReactionSetup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReactionSetup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReactionSetup message.
         * @function verify
         * @memberof ord.ReactionSetup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReactionSetup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.vessel != null && message.hasOwnProperty("vessel")) {
                let error = $root.ord.Vessel.verify(message.vessel);
                if (error)
                    return "vessel." + error;
            }
            if (message.isAutomated != null && message.hasOwnProperty("isAutomated")) {
                properties._isAutomated = 1;
                if (typeof message.isAutomated !== "boolean")
                    return "isAutomated: boolean expected";
            }
            if (message.automationPlatform != null && message.hasOwnProperty("automationPlatform"))
                if (!$util.isString(message.automationPlatform))
                    return "automationPlatform: string expected";
            if (message.automationCode != null && message.hasOwnProperty("automationCode")) {
                if (!$util.isObject(message.automationCode))
                    return "automationCode: object expected";
                let key = Object.keys(message.automationCode);
                for (let i = 0; i < key.length; ++i) {
                    let error = $root.ord.Data.verify(message.automationCode[key[i]]);
                    if (error)
                        return "automationCode." + error;
                }
            }
            if (message.environment != null && message.hasOwnProperty("environment")) {
                let error = $root.ord.ReactionSetup.ReactionEnvironment.verify(message.environment);
                if (error)
                    return "environment." + error;
            }
            return null;
        };

        /**
         * Creates a ReactionSetup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.ReactionSetup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.ReactionSetup} ReactionSetup
         */
        ReactionSetup.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.ReactionSetup)
                return object;
            let message = new $root.ord.ReactionSetup();
            if (object.vessel != null) {
                if (typeof object.vessel !== "object")
                    throw TypeError(".ord.ReactionSetup.vessel: object expected");
                message.vessel = $root.ord.Vessel.fromObject(object.vessel);
            }
            if (object.isAutomated != null)
                message.isAutomated = Boolean(object.isAutomated);
            if (object.automationPlatform != null)
                message.automationPlatform = String(object.automationPlatform);
            if (object.automationCode) {
                if (typeof object.automationCode !== "object")
                    throw TypeError(".ord.ReactionSetup.automationCode: object expected");
                message.automationCode = {};
                for (let keys = Object.keys(object.automationCode), i = 0; i < keys.length; ++i) {
                    if (typeof object.automationCode[keys[i]] !== "object")
                        throw TypeError(".ord.ReactionSetup.automationCode: object expected");
                    message.automationCode[keys[i]] = $root.ord.Data.fromObject(object.automationCode[keys[i]]);
                }
            }
            if (object.environment != null) {
                if (typeof object.environment !== "object")
                    throw TypeError(".ord.ReactionSetup.environment: object expected");
                message.environment = $root.ord.ReactionSetup.ReactionEnvironment.fromObject(object.environment);
            }
            return message;
        };

        /**
         * Creates a plain object from a ReactionSetup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.ReactionSetup
         * @static
         * @param {ord.ReactionSetup} message ReactionSetup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReactionSetup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.objects || options.defaults)
                object.automationCode = {};
            if (options.defaults) {
                object.vessel = null;
                object.automationPlatform = "";
                object.environment = null;
            }
            if (message.vessel != null && message.hasOwnProperty("vessel"))
                object.vessel = $root.ord.Vessel.toObject(message.vessel, options);
            if (message.isAutomated != null && message.hasOwnProperty("isAutomated")) {
                object.isAutomated = message.isAutomated;
                if (options.oneofs)
                    object._isAutomated = "isAutomated";
            }
            if (message.automationPlatform != null && message.hasOwnProperty("automationPlatform"))
                object.automationPlatform = message.automationPlatform;
            let keys2;
            if (message.automationCode && (keys2 = Object.keys(message.automationCode)).length) {
                object.automationCode = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.automationCode[keys2[j]] = $root.ord.Data.toObject(message.automationCode[keys2[j]], options);
            }
            if (message.environment != null && message.hasOwnProperty("environment"))
                object.environment = $root.ord.ReactionSetup.ReactionEnvironment.toObject(message.environment, options);
            return object;
        };

        /**
         * Converts this ReactionSetup to JSON.
         * @function toJSON
         * @memberof ord.ReactionSetup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReactionSetup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ReactionSetup
         * @function getTypeUrl
         * @memberof ord.ReactionSetup
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ReactionSetup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.ReactionSetup";
        };

        ReactionSetup.ReactionEnvironment = (function() {

            /**
             * Properties of a ReactionEnvironment.
             * @memberof ord.ReactionSetup
             * @interface IReactionEnvironment
             * @property {ord.ReactionSetup.ReactionEnvironment.ReactionEnvironmentType|null} [type] ReactionEnvironment type
             * @property {string|null} [details] ReactionEnvironment details
             */

            /**
             * Constructs a new ReactionEnvironment.
             * @memberof ord.ReactionSetup
             * @classdesc Represents a ReactionEnvironment.
             * @implements IReactionEnvironment
             * @constructor
             * @param {ord.ReactionSetup.IReactionEnvironment=} [properties] Properties to set
             */
            function ReactionEnvironment(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReactionEnvironment type.
             * @member {ord.ReactionSetup.ReactionEnvironment.ReactionEnvironmentType} type
             * @memberof ord.ReactionSetup.ReactionEnvironment
             * @instance
             */
            ReactionEnvironment.prototype.type = 0;

            /**
             * ReactionEnvironment details.
             * @member {string} details
             * @memberof ord.ReactionSetup.ReactionEnvironment
             * @instance
             */
            ReactionEnvironment.prototype.details = "";

            /**
             * Creates a new ReactionEnvironment instance using the specified properties.
             * @function create
             * @memberof ord.ReactionSetup.ReactionEnvironment
             * @static
             * @param {ord.ReactionSetup.IReactionEnvironment=} [properties] Properties to set
             * @returns {ord.ReactionSetup.ReactionEnvironment} ReactionEnvironment instance
             */
            ReactionEnvironment.create = function create(properties) {
                return new ReactionEnvironment(properties);
            };

            /**
             * Encodes the specified ReactionEnvironment message. Does not implicitly {@link ord.ReactionSetup.ReactionEnvironment.verify|verify} messages.
             * @function encode
             * @memberof ord.ReactionSetup.ReactionEnvironment
             * @static
             * @param {ord.ReactionSetup.IReactionEnvironment} message ReactionEnvironment message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReactionEnvironment.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
                return writer;
            };

            /**
             * Encodes the specified ReactionEnvironment message, length delimited. Does not implicitly {@link ord.ReactionSetup.ReactionEnvironment.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ord.ReactionSetup.ReactionEnvironment
             * @static
             * @param {ord.ReactionSetup.IReactionEnvironment} message ReactionEnvironment message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReactionEnvironment.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReactionEnvironment message from the specified reader or buffer.
             * @function decode
             * @memberof ord.ReactionSetup.ReactionEnvironment
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ord.ReactionSetup.ReactionEnvironment} ReactionEnvironment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReactionEnvironment.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.ReactionSetup.ReactionEnvironment();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.details = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReactionEnvironment message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ord.ReactionSetup.ReactionEnvironment
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ord.ReactionSetup.ReactionEnvironment} ReactionEnvironment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReactionEnvironment.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReactionEnvironment message.
             * @function verify
             * @memberof ord.ReactionSetup.ReactionEnvironment
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReactionEnvironment.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                if (message.details != null && message.hasOwnProperty("details"))
                    if (!$util.isString(message.details))
                        return "details: string expected";
                return null;
            };

            /**
             * Creates a ReactionEnvironment message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ord.ReactionSetup.ReactionEnvironment
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ord.ReactionSetup.ReactionEnvironment} ReactionEnvironment
             */
            ReactionEnvironment.fromObject = function fromObject(object) {
                if (object instanceof $root.ord.ReactionSetup.ReactionEnvironment)
                    return object;
                let message = new $root.ord.ReactionSetup.ReactionEnvironment();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "UNSPECIFIED":
                case 0:
                    message.type = 0;
                    break;
                case "CUSTOM":
                case 1:
                    message.type = 1;
                    break;
                case "FUME_HOOD":
                case 2:
                    message.type = 2;
                    break;
                case "BENCH_TOP":
                case 3:
                    message.type = 3;
                    break;
                case "GLOVE_BOX":
                case 4:
                    message.type = 4;
                    break;
                case "GLOVE_BAG":
                case 5:
                    message.type = 5;
                    break;
                }
                if (object.details != null)
                    message.details = String(object.details);
                return message;
            };

            /**
             * Creates a plain object from a ReactionEnvironment message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ord.ReactionSetup.ReactionEnvironment
             * @static
             * @param {ord.ReactionSetup.ReactionEnvironment} message ReactionEnvironment
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReactionEnvironment.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "UNSPECIFIED" : 0;
                    object.details = "";
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.ord.ReactionSetup.ReactionEnvironment.ReactionEnvironmentType[message.type] === undefined ? message.type : $root.ord.ReactionSetup.ReactionEnvironment.ReactionEnvironmentType[message.type] : message.type;
                if (message.details != null && message.hasOwnProperty("details"))
                    object.details = message.details;
                return object;
            };

            /**
             * Converts this ReactionEnvironment to JSON.
             * @function toJSON
             * @memberof ord.ReactionSetup.ReactionEnvironment
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReactionEnvironment.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ReactionEnvironment
             * @function getTypeUrl
             * @memberof ord.ReactionSetup.ReactionEnvironment
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ReactionEnvironment.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/ord.ReactionSetup.ReactionEnvironment";
            };

            /**
             * ReactionEnvironmentType enum.
             * @name ord.ReactionSetup.ReactionEnvironment.ReactionEnvironmentType
             * @enum {number}
             * @property {number} UNSPECIFIED=0 UNSPECIFIED value
             * @property {number} CUSTOM=1 CUSTOM value
             * @property {number} FUME_HOOD=2 FUME_HOOD value
             * @property {number} BENCH_TOP=3 BENCH_TOP value
             * @property {number} GLOVE_BOX=4 GLOVE_BOX value
             * @property {number} GLOVE_BAG=5 GLOVE_BAG value
             */
            ReactionEnvironment.ReactionEnvironmentType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSPECIFIED"] = 0;
                values[valuesById[1] = "CUSTOM"] = 1;
                values[valuesById[2] = "FUME_HOOD"] = 2;
                values[valuesById[3] = "BENCH_TOP"] = 3;
                values[valuesById[4] = "GLOVE_BOX"] = 4;
                values[valuesById[5] = "GLOVE_BAG"] = 5;
                return values;
            })();

            return ReactionEnvironment;
        })();

        return ReactionSetup;
    })();

    ord.ReactionConditions = (function() {

        /**
         * Properties of a ReactionConditions.
         * @memberof ord
         * @interface IReactionConditions
         * @property {ord.ITemperatureConditions|null} [temperature] ReactionConditions temperature
         * @property {ord.IPressureConditions|null} [pressure] ReactionConditions pressure
         * @property {ord.IStirringConditions|null} [stirring] ReactionConditions stirring
         * @property {ord.IIlluminationConditions|null} [illumination] ReactionConditions illumination
         * @property {ord.IElectrochemistryConditions|null} [electrochemistry] ReactionConditions electrochemistry
         * @property {ord.IFlowConditions|null} [flow] ReactionConditions flow
         * @property {boolean|null} [reflux] ReactionConditions reflux
         * @property {number|null} [ph] ReactionConditions ph
         * @property {boolean|null} [conditionsAreDynamic] ReactionConditions conditionsAreDynamic
         * @property {string|null} [details] ReactionConditions details
         */

        /**
         * Constructs a new ReactionConditions.
         * @memberof ord
         * @classdesc Represents a ReactionConditions.
         * @implements IReactionConditions
         * @constructor
         * @param {ord.IReactionConditions=} [properties] Properties to set
         */
        function ReactionConditions(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReactionConditions temperature.
         * @member {ord.ITemperatureConditions|null|undefined} temperature
         * @memberof ord.ReactionConditions
         * @instance
         */
        ReactionConditions.prototype.temperature = null;

        /**
         * ReactionConditions pressure.
         * @member {ord.IPressureConditions|null|undefined} pressure
         * @memberof ord.ReactionConditions
         * @instance
         */
        ReactionConditions.prototype.pressure = null;

        /**
         * ReactionConditions stirring.
         * @member {ord.IStirringConditions|null|undefined} stirring
         * @memberof ord.ReactionConditions
         * @instance
         */
        ReactionConditions.prototype.stirring = null;

        /**
         * ReactionConditions illumination.
         * @member {ord.IIlluminationConditions|null|undefined} illumination
         * @memberof ord.ReactionConditions
         * @instance
         */
        ReactionConditions.prototype.illumination = null;

        /**
         * ReactionConditions electrochemistry.
         * @member {ord.IElectrochemistryConditions|null|undefined} electrochemistry
         * @memberof ord.ReactionConditions
         * @instance
         */
        ReactionConditions.prototype.electrochemistry = null;

        /**
         * ReactionConditions flow.
         * @member {ord.IFlowConditions|null|undefined} flow
         * @memberof ord.ReactionConditions
         * @instance
         */
        ReactionConditions.prototype.flow = null;

        /**
         * ReactionConditions reflux.
         * @member {boolean|null|undefined} reflux
         * @memberof ord.ReactionConditions
         * @instance
         */
        ReactionConditions.prototype.reflux = null;

        /**
         * ReactionConditions ph.
         * @member {number|null|undefined} ph
         * @memberof ord.ReactionConditions
         * @instance
         */
        ReactionConditions.prototype.ph = null;

        /**
         * ReactionConditions conditionsAreDynamic.
         * @member {boolean|null|undefined} conditionsAreDynamic
         * @memberof ord.ReactionConditions
         * @instance
         */
        ReactionConditions.prototype.conditionsAreDynamic = null;

        /**
         * ReactionConditions details.
         * @member {string} details
         * @memberof ord.ReactionConditions
         * @instance
         */
        ReactionConditions.prototype.details = "";

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(ReactionConditions.prototype, "_reflux", {
            get: $util.oneOfGetter($oneOfFields = ["reflux"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(ReactionConditions.prototype, "_ph", {
            get: $util.oneOfGetter($oneOfFields = ["ph"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(ReactionConditions.prototype, "_conditionsAreDynamic", {
            get: $util.oneOfGetter($oneOfFields = ["conditionsAreDynamic"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ReactionConditions instance using the specified properties.
         * @function create
         * @memberof ord.ReactionConditions
         * @static
         * @param {ord.IReactionConditions=} [properties] Properties to set
         * @returns {ord.ReactionConditions} ReactionConditions instance
         */
        ReactionConditions.create = function create(properties) {
            return new ReactionConditions(properties);
        };

        /**
         * Encodes the specified ReactionConditions message. Does not implicitly {@link ord.ReactionConditions.verify|verify} messages.
         * @function encode
         * @memberof ord.ReactionConditions
         * @static
         * @param {ord.IReactionConditions} message ReactionConditions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReactionConditions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.temperature != null && Object.hasOwnProperty.call(message, "temperature"))
                $root.ord.TemperatureConditions.encode(message.temperature, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.pressure != null && Object.hasOwnProperty.call(message, "pressure"))
                $root.ord.PressureConditions.encode(message.pressure, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.stirring != null && Object.hasOwnProperty.call(message, "stirring"))
                $root.ord.StirringConditions.encode(message.stirring, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.illumination != null && Object.hasOwnProperty.call(message, "illumination"))
                $root.ord.IlluminationConditions.encode(message.illumination, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.electrochemistry != null && Object.hasOwnProperty.call(message, "electrochemistry"))
                $root.ord.ElectrochemistryConditions.encode(message.electrochemistry, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.flow != null && Object.hasOwnProperty.call(message, "flow"))
                $root.ord.FlowConditions.encode(message.flow, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.reflux != null && Object.hasOwnProperty.call(message, "reflux"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.reflux);
            if (message.ph != null && Object.hasOwnProperty.call(message, "ph"))
                writer.uint32(/* id 8, wireType 5 =*/69).float(message.ph);
            if (message.conditionsAreDynamic != null && Object.hasOwnProperty.call(message, "conditionsAreDynamic"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.conditionsAreDynamic);
            if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.details);
            return writer;
        };

        /**
         * Encodes the specified ReactionConditions message, length delimited. Does not implicitly {@link ord.ReactionConditions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.ReactionConditions
         * @static
         * @param {ord.IReactionConditions} message ReactionConditions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReactionConditions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReactionConditions message from the specified reader or buffer.
         * @function decode
         * @memberof ord.ReactionConditions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.ReactionConditions} ReactionConditions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReactionConditions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.ReactionConditions();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.temperature = $root.ord.TemperatureConditions.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.pressure = $root.ord.PressureConditions.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.stirring = $root.ord.StirringConditions.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.illumination = $root.ord.IlluminationConditions.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.electrochemistry = $root.ord.ElectrochemistryConditions.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.flow = $root.ord.FlowConditions.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.reflux = reader.bool();
                        break;
                    }
                case 8: {
                        message.ph = reader.float();
                        break;
                    }
                case 9: {
                        message.conditionsAreDynamic = reader.bool();
                        break;
                    }
                case 10: {
                        message.details = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReactionConditions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.ReactionConditions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.ReactionConditions} ReactionConditions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReactionConditions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReactionConditions message.
         * @function verify
         * @memberof ord.ReactionConditions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReactionConditions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.temperature != null && message.hasOwnProperty("temperature")) {
                let error = $root.ord.TemperatureConditions.verify(message.temperature);
                if (error)
                    return "temperature." + error;
            }
            if (message.pressure != null && message.hasOwnProperty("pressure")) {
                let error = $root.ord.PressureConditions.verify(message.pressure);
                if (error)
                    return "pressure." + error;
            }
            if (message.stirring != null && message.hasOwnProperty("stirring")) {
                let error = $root.ord.StirringConditions.verify(message.stirring);
                if (error)
                    return "stirring." + error;
            }
            if (message.illumination != null && message.hasOwnProperty("illumination")) {
                let error = $root.ord.IlluminationConditions.verify(message.illumination);
                if (error)
                    return "illumination." + error;
            }
            if (message.electrochemistry != null && message.hasOwnProperty("electrochemistry")) {
                let error = $root.ord.ElectrochemistryConditions.verify(message.electrochemistry);
                if (error)
                    return "electrochemistry." + error;
            }
            if (message.flow != null && message.hasOwnProperty("flow")) {
                let error = $root.ord.FlowConditions.verify(message.flow);
                if (error)
                    return "flow." + error;
            }
            if (message.reflux != null && message.hasOwnProperty("reflux")) {
                properties._reflux = 1;
                if (typeof message.reflux !== "boolean")
                    return "reflux: boolean expected";
            }
            if (message.ph != null && message.hasOwnProperty("ph")) {
                properties._ph = 1;
                if (typeof message.ph !== "number")
                    return "ph: number expected";
            }
            if (message.conditionsAreDynamic != null && message.hasOwnProperty("conditionsAreDynamic")) {
                properties._conditionsAreDynamic = 1;
                if (typeof message.conditionsAreDynamic !== "boolean")
                    return "conditionsAreDynamic: boolean expected";
            }
            if (message.details != null && message.hasOwnProperty("details"))
                if (!$util.isString(message.details))
                    return "details: string expected";
            return null;
        };

        /**
         * Creates a ReactionConditions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.ReactionConditions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.ReactionConditions} ReactionConditions
         */
        ReactionConditions.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.ReactionConditions)
                return object;
            let message = new $root.ord.ReactionConditions();
            if (object.temperature != null) {
                if (typeof object.temperature !== "object")
                    throw TypeError(".ord.ReactionConditions.temperature: object expected");
                message.temperature = $root.ord.TemperatureConditions.fromObject(object.temperature);
            }
            if (object.pressure != null) {
                if (typeof object.pressure !== "object")
                    throw TypeError(".ord.ReactionConditions.pressure: object expected");
                message.pressure = $root.ord.PressureConditions.fromObject(object.pressure);
            }
            if (object.stirring != null) {
                if (typeof object.stirring !== "object")
                    throw TypeError(".ord.ReactionConditions.stirring: object expected");
                message.stirring = $root.ord.StirringConditions.fromObject(object.stirring);
            }
            if (object.illumination != null) {
                if (typeof object.illumination !== "object")
                    throw TypeError(".ord.ReactionConditions.illumination: object expected");
                message.illumination = $root.ord.IlluminationConditions.fromObject(object.illumination);
            }
            if (object.electrochemistry != null) {
                if (typeof object.electrochemistry !== "object")
                    throw TypeError(".ord.ReactionConditions.electrochemistry: object expected");
                message.electrochemistry = $root.ord.ElectrochemistryConditions.fromObject(object.electrochemistry);
            }
            if (object.flow != null) {
                if (typeof object.flow !== "object")
                    throw TypeError(".ord.ReactionConditions.flow: object expected");
                message.flow = $root.ord.FlowConditions.fromObject(object.flow);
            }
            if (object.reflux != null)
                message.reflux = Boolean(object.reflux);
            if (object.ph != null)
                message.ph = Number(object.ph);
            if (object.conditionsAreDynamic != null)
                message.conditionsAreDynamic = Boolean(object.conditionsAreDynamic);
            if (object.details != null)
                message.details = String(object.details);
            return message;
        };

        /**
         * Creates a plain object from a ReactionConditions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.ReactionConditions
         * @static
         * @param {ord.ReactionConditions} message ReactionConditions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReactionConditions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.temperature = null;
                object.pressure = null;
                object.stirring = null;
                object.illumination = null;
                object.electrochemistry = null;
                object.flow = null;
                object.details = "";
            }
            if (message.temperature != null && message.hasOwnProperty("temperature"))
                object.temperature = $root.ord.TemperatureConditions.toObject(message.temperature, options);
            if (message.pressure != null && message.hasOwnProperty("pressure"))
                object.pressure = $root.ord.PressureConditions.toObject(message.pressure, options);
            if (message.stirring != null && message.hasOwnProperty("stirring"))
                object.stirring = $root.ord.StirringConditions.toObject(message.stirring, options);
            if (message.illumination != null && message.hasOwnProperty("illumination"))
                object.illumination = $root.ord.IlluminationConditions.toObject(message.illumination, options);
            if (message.electrochemistry != null && message.hasOwnProperty("electrochemistry"))
                object.electrochemistry = $root.ord.ElectrochemistryConditions.toObject(message.electrochemistry, options);
            if (message.flow != null && message.hasOwnProperty("flow"))
                object.flow = $root.ord.FlowConditions.toObject(message.flow, options);
            if (message.reflux != null && message.hasOwnProperty("reflux")) {
                object.reflux = message.reflux;
                if (options.oneofs)
                    object._reflux = "reflux";
            }
            if (message.ph != null && message.hasOwnProperty("ph")) {
                object.ph = options.json && !isFinite(message.ph) ? String(message.ph) : message.ph;
                if (options.oneofs)
                    object._ph = "ph";
            }
            if (message.conditionsAreDynamic != null && message.hasOwnProperty("conditionsAreDynamic")) {
                object.conditionsAreDynamic = message.conditionsAreDynamic;
                if (options.oneofs)
                    object._conditionsAreDynamic = "conditionsAreDynamic";
            }
            if (message.details != null && message.hasOwnProperty("details"))
                object.details = message.details;
            return object;
        };

        /**
         * Converts this ReactionConditions to JSON.
         * @function toJSON
         * @memberof ord.ReactionConditions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReactionConditions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ReactionConditions
         * @function getTypeUrl
         * @memberof ord.ReactionConditions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ReactionConditions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.ReactionConditions";
        };

        return ReactionConditions;
    })();

    ord.TemperatureConditions = (function() {

        /**
         * Properties of a TemperatureConditions.
         * @memberof ord
         * @interface ITemperatureConditions
         * @property {ord.TemperatureConditions.ITemperatureControl|null} [control] TemperatureConditions control
         * @property {ord.ITemperature|null} [setpoint] TemperatureConditions setpoint
         * @property {Array.<ord.TemperatureConditions.ITemperatureMeasurement>|null} [measurements] TemperatureConditions measurements
         */

        /**
         * Constructs a new TemperatureConditions.
         * @memberof ord
         * @classdesc Represents a TemperatureConditions.
         * @implements ITemperatureConditions
         * @constructor
         * @param {ord.ITemperatureConditions=} [properties] Properties to set
         */
        function TemperatureConditions(properties) {
            this.measurements = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TemperatureConditions control.
         * @member {ord.TemperatureConditions.ITemperatureControl|null|undefined} control
         * @memberof ord.TemperatureConditions
         * @instance
         */
        TemperatureConditions.prototype.control = null;

        /**
         * TemperatureConditions setpoint.
         * @member {ord.ITemperature|null|undefined} setpoint
         * @memberof ord.TemperatureConditions
         * @instance
         */
        TemperatureConditions.prototype.setpoint = null;

        /**
         * TemperatureConditions measurements.
         * @member {Array.<ord.TemperatureConditions.ITemperatureMeasurement>} measurements
         * @memberof ord.TemperatureConditions
         * @instance
         */
        TemperatureConditions.prototype.measurements = $util.emptyArray;

        /**
         * Creates a new TemperatureConditions instance using the specified properties.
         * @function create
         * @memberof ord.TemperatureConditions
         * @static
         * @param {ord.ITemperatureConditions=} [properties] Properties to set
         * @returns {ord.TemperatureConditions} TemperatureConditions instance
         */
        TemperatureConditions.create = function create(properties) {
            return new TemperatureConditions(properties);
        };

        /**
         * Encodes the specified TemperatureConditions message. Does not implicitly {@link ord.TemperatureConditions.verify|verify} messages.
         * @function encode
         * @memberof ord.TemperatureConditions
         * @static
         * @param {ord.ITemperatureConditions} message TemperatureConditions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TemperatureConditions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                $root.ord.TemperatureConditions.TemperatureControl.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.setpoint != null && Object.hasOwnProperty.call(message, "setpoint"))
                $root.ord.Temperature.encode(message.setpoint, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.measurements != null && message.measurements.length)
                for (let i = 0; i < message.measurements.length; ++i)
                    $root.ord.TemperatureConditions.TemperatureMeasurement.encode(message.measurements[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TemperatureConditions message, length delimited. Does not implicitly {@link ord.TemperatureConditions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.TemperatureConditions
         * @static
         * @param {ord.ITemperatureConditions} message TemperatureConditions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TemperatureConditions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TemperatureConditions message from the specified reader or buffer.
         * @function decode
         * @memberof ord.TemperatureConditions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.TemperatureConditions} TemperatureConditions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TemperatureConditions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.TemperatureConditions();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.control = $root.ord.TemperatureConditions.TemperatureControl.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.setpoint = $root.ord.Temperature.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        if (!(message.measurements && message.measurements.length))
                            message.measurements = [];
                        message.measurements.push($root.ord.TemperatureConditions.TemperatureMeasurement.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TemperatureConditions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.TemperatureConditions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.TemperatureConditions} TemperatureConditions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TemperatureConditions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TemperatureConditions message.
         * @function verify
         * @memberof ord.TemperatureConditions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TemperatureConditions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.control != null && message.hasOwnProperty("control")) {
                let error = $root.ord.TemperatureConditions.TemperatureControl.verify(message.control);
                if (error)
                    return "control." + error;
            }
            if (message.setpoint != null && message.hasOwnProperty("setpoint")) {
                let error = $root.ord.Temperature.verify(message.setpoint);
                if (error)
                    return "setpoint." + error;
            }
            if (message.measurements != null && message.hasOwnProperty("measurements")) {
                if (!Array.isArray(message.measurements))
                    return "measurements: array expected";
                for (let i = 0; i < message.measurements.length; ++i) {
                    let error = $root.ord.TemperatureConditions.TemperatureMeasurement.verify(message.measurements[i]);
                    if (error)
                        return "measurements." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TemperatureConditions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.TemperatureConditions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.TemperatureConditions} TemperatureConditions
         */
        TemperatureConditions.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.TemperatureConditions)
                return object;
            let message = new $root.ord.TemperatureConditions();
            if (object.control != null) {
                if (typeof object.control !== "object")
                    throw TypeError(".ord.TemperatureConditions.control: object expected");
                message.control = $root.ord.TemperatureConditions.TemperatureControl.fromObject(object.control);
            }
            if (object.setpoint != null) {
                if (typeof object.setpoint !== "object")
                    throw TypeError(".ord.TemperatureConditions.setpoint: object expected");
                message.setpoint = $root.ord.Temperature.fromObject(object.setpoint);
            }
            if (object.measurements) {
                if (!Array.isArray(object.measurements))
                    throw TypeError(".ord.TemperatureConditions.measurements: array expected");
                message.measurements = [];
                for (let i = 0; i < object.measurements.length; ++i) {
                    if (typeof object.measurements[i] !== "object")
                        throw TypeError(".ord.TemperatureConditions.measurements: object expected");
                    message.measurements[i] = $root.ord.TemperatureConditions.TemperatureMeasurement.fromObject(object.measurements[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TemperatureConditions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.TemperatureConditions
         * @static
         * @param {ord.TemperatureConditions} message TemperatureConditions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TemperatureConditions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.measurements = [];
            if (options.defaults) {
                object.control = null;
                object.setpoint = null;
            }
            if (message.control != null && message.hasOwnProperty("control"))
                object.control = $root.ord.TemperatureConditions.TemperatureControl.toObject(message.control, options);
            if (message.setpoint != null && message.hasOwnProperty("setpoint"))
                object.setpoint = $root.ord.Temperature.toObject(message.setpoint, options);
            if (message.measurements && message.measurements.length) {
                object.measurements = [];
                for (let j = 0; j < message.measurements.length; ++j)
                    object.measurements[j] = $root.ord.TemperatureConditions.TemperatureMeasurement.toObject(message.measurements[j], options);
            }
            return object;
        };

        /**
         * Converts this TemperatureConditions to JSON.
         * @function toJSON
         * @memberof ord.TemperatureConditions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TemperatureConditions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TemperatureConditions
         * @function getTypeUrl
         * @memberof ord.TemperatureConditions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TemperatureConditions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.TemperatureConditions";
        };

        TemperatureConditions.TemperatureControl = (function() {

            /**
             * Properties of a TemperatureControl.
             * @memberof ord.TemperatureConditions
             * @interface ITemperatureControl
             * @property {ord.TemperatureConditions.TemperatureControl.TemperatureControlType|null} [type] TemperatureControl type
             * @property {string|null} [details] TemperatureControl details
             */

            /**
             * Constructs a new TemperatureControl.
             * @memberof ord.TemperatureConditions
             * @classdesc Represents a TemperatureControl.
             * @implements ITemperatureControl
             * @constructor
             * @param {ord.TemperatureConditions.ITemperatureControl=} [properties] Properties to set
             */
            function TemperatureControl(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TemperatureControl type.
             * @member {ord.TemperatureConditions.TemperatureControl.TemperatureControlType} type
             * @memberof ord.TemperatureConditions.TemperatureControl
             * @instance
             */
            TemperatureControl.prototype.type = 0;

            /**
             * TemperatureControl details.
             * @member {string} details
             * @memberof ord.TemperatureConditions.TemperatureControl
             * @instance
             */
            TemperatureControl.prototype.details = "";

            /**
             * Creates a new TemperatureControl instance using the specified properties.
             * @function create
             * @memberof ord.TemperatureConditions.TemperatureControl
             * @static
             * @param {ord.TemperatureConditions.ITemperatureControl=} [properties] Properties to set
             * @returns {ord.TemperatureConditions.TemperatureControl} TemperatureControl instance
             */
            TemperatureControl.create = function create(properties) {
                return new TemperatureControl(properties);
            };

            /**
             * Encodes the specified TemperatureControl message. Does not implicitly {@link ord.TemperatureConditions.TemperatureControl.verify|verify} messages.
             * @function encode
             * @memberof ord.TemperatureConditions.TemperatureControl
             * @static
             * @param {ord.TemperatureConditions.ITemperatureControl} message TemperatureControl message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TemperatureControl.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
                return writer;
            };

            /**
             * Encodes the specified TemperatureControl message, length delimited. Does not implicitly {@link ord.TemperatureConditions.TemperatureControl.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ord.TemperatureConditions.TemperatureControl
             * @static
             * @param {ord.TemperatureConditions.ITemperatureControl} message TemperatureControl message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TemperatureControl.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TemperatureControl message from the specified reader or buffer.
             * @function decode
             * @memberof ord.TemperatureConditions.TemperatureControl
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ord.TemperatureConditions.TemperatureControl} TemperatureControl
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TemperatureControl.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.TemperatureConditions.TemperatureControl();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.details = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TemperatureControl message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ord.TemperatureConditions.TemperatureControl
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ord.TemperatureConditions.TemperatureControl} TemperatureControl
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TemperatureControl.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TemperatureControl message.
             * @function verify
             * @memberof ord.TemperatureConditions.TemperatureControl
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TemperatureControl.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                        break;
                    }
                if (message.details != null && message.hasOwnProperty("details"))
                    if (!$util.isString(message.details))
                        return "details: string expected";
                return null;
            };

            /**
             * Creates a TemperatureControl message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ord.TemperatureConditions.TemperatureControl
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ord.TemperatureConditions.TemperatureControl} TemperatureControl
             */
            TemperatureControl.fromObject = function fromObject(object) {
                if (object instanceof $root.ord.TemperatureConditions.TemperatureControl)
                    return object;
                let message = new $root.ord.TemperatureConditions.TemperatureControl();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "UNSPECIFIED":
                case 0:
                    message.type = 0;
                    break;
                case "CUSTOM":
                case 1:
                    message.type = 1;
                    break;
                case "AMBIENT":
                case 2:
                    message.type = 2;
                    break;
                case "OIL_BATH":
                case 3:
                    message.type = 3;
                    break;
                case "WATER_BATH":
                case 4:
                    message.type = 4;
                    break;
                case "SAND_BATH":
                case 5:
                    message.type = 5;
                    break;
                case "ICE_BATH":
                case 6:
                    message.type = 6;
                    break;
                case "DRY_ALUMINUM_PLATE":
                case 7:
                    message.type = 7;
                    break;
                case "MICROWAVE":
                case 8:
                    message.type = 8;
                    break;
                case "DRY_ICE_BATH":
                case 9:
                    message.type = 9;
                    break;
                case "AIR_FAN":
                case 10:
                    message.type = 10;
                    break;
                case "LIQUID_NITROGEN":
                case 11:
                    message.type = 11;
                    break;
                }
                if (object.details != null)
                    message.details = String(object.details);
                return message;
            };

            /**
             * Creates a plain object from a TemperatureControl message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ord.TemperatureConditions.TemperatureControl
             * @static
             * @param {ord.TemperatureConditions.TemperatureControl} message TemperatureControl
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TemperatureControl.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "UNSPECIFIED" : 0;
                    object.details = "";
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.ord.TemperatureConditions.TemperatureControl.TemperatureControlType[message.type] === undefined ? message.type : $root.ord.TemperatureConditions.TemperatureControl.TemperatureControlType[message.type] : message.type;
                if (message.details != null && message.hasOwnProperty("details"))
                    object.details = message.details;
                return object;
            };

            /**
             * Converts this TemperatureControl to JSON.
             * @function toJSON
             * @memberof ord.TemperatureConditions.TemperatureControl
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TemperatureControl.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TemperatureControl
             * @function getTypeUrl
             * @memberof ord.TemperatureConditions.TemperatureControl
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TemperatureControl.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/ord.TemperatureConditions.TemperatureControl";
            };

            /**
             * TemperatureControlType enum.
             * @name ord.TemperatureConditions.TemperatureControl.TemperatureControlType
             * @enum {number}
             * @property {number} UNSPECIFIED=0 UNSPECIFIED value
             * @property {number} CUSTOM=1 CUSTOM value
             * @property {number} AMBIENT=2 AMBIENT value
             * @property {number} OIL_BATH=3 OIL_BATH value
             * @property {number} WATER_BATH=4 WATER_BATH value
             * @property {number} SAND_BATH=5 SAND_BATH value
             * @property {number} ICE_BATH=6 ICE_BATH value
             * @property {number} DRY_ALUMINUM_PLATE=7 DRY_ALUMINUM_PLATE value
             * @property {number} MICROWAVE=8 MICROWAVE value
             * @property {number} DRY_ICE_BATH=9 DRY_ICE_BATH value
             * @property {number} AIR_FAN=10 AIR_FAN value
             * @property {number} LIQUID_NITROGEN=11 LIQUID_NITROGEN value
             */
            TemperatureControl.TemperatureControlType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSPECIFIED"] = 0;
                values[valuesById[1] = "CUSTOM"] = 1;
                values[valuesById[2] = "AMBIENT"] = 2;
                values[valuesById[3] = "OIL_BATH"] = 3;
                values[valuesById[4] = "WATER_BATH"] = 4;
                values[valuesById[5] = "SAND_BATH"] = 5;
                values[valuesById[6] = "ICE_BATH"] = 6;
                values[valuesById[7] = "DRY_ALUMINUM_PLATE"] = 7;
                values[valuesById[8] = "MICROWAVE"] = 8;
                values[valuesById[9] = "DRY_ICE_BATH"] = 9;
                values[valuesById[10] = "AIR_FAN"] = 10;
                values[valuesById[11] = "LIQUID_NITROGEN"] = 11;
                return values;
            })();

            return TemperatureControl;
        })();

        TemperatureConditions.TemperatureMeasurement = (function() {

            /**
             * Properties of a TemperatureMeasurement.
             * @memberof ord.TemperatureConditions
             * @interface ITemperatureMeasurement
             * @property {ord.TemperatureConditions.TemperatureMeasurement.TemperatureMeasurementType|null} [type] TemperatureMeasurement type
             * @property {string|null} [details] TemperatureMeasurement details
             * @property {ord.ITime|null} [time] TemperatureMeasurement time
             * @property {ord.ITemperature|null} [temperature] TemperatureMeasurement temperature
             */

            /**
             * Constructs a new TemperatureMeasurement.
             * @memberof ord.TemperatureConditions
             * @classdesc Represents a TemperatureMeasurement.
             * @implements ITemperatureMeasurement
             * @constructor
             * @param {ord.TemperatureConditions.ITemperatureMeasurement=} [properties] Properties to set
             */
            function TemperatureMeasurement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TemperatureMeasurement type.
             * @member {ord.TemperatureConditions.TemperatureMeasurement.TemperatureMeasurementType} type
             * @memberof ord.TemperatureConditions.TemperatureMeasurement
             * @instance
             */
            TemperatureMeasurement.prototype.type = 0;

            /**
             * TemperatureMeasurement details.
             * @member {string} details
             * @memberof ord.TemperatureConditions.TemperatureMeasurement
             * @instance
             */
            TemperatureMeasurement.prototype.details = "";

            /**
             * TemperatureMeasurement time.
             * @member {ord.ITime|null|undefined} time
             * @memberof ord.TemperatureConditions.TemperatureMeasurement
             * @instance
             */
            TemperatureMeasurement.prototype.time = null;

            /**
             * TemperatureMeasurement temperature.
             * @member {ord.ITemperature|null|undefined} temperature
             * @memberof ord.TemperatureConditions.TemperatureMeasurement
             * @instance
             */
            TemperatureMeasurement.prototype.temperature = null;

            /**
             * Creates a new TemperatureMeasurement instance using the specified properties.
             * @function create
             * @memberof ord.TemperatureConditions.TemperatureMeasurement
             * @static
             * @param {ord.TemperatureConditions.ITemperatureMeasurement=} [properties] Properties to set
             * @returns {ord.TemperatureConditions.TemperatureMeasurement} TemperatureMeasurement instance
             */
            TemperatureMeasurement.create = function create(properties) {
                return new TemperatureMeasurement(properties);
            };

            /**
             * Encodes the specified TemperatureMeasurement message. Does not implicitly {@link ord.TemperatureConditions.TemperatureMeasurement.verify|verify} messages.
             * @function encode
             * @memberof ord.TemperatureConditions.TemperatureMeasurement
             * @static
             * @param {ord.TemperatureConditions.ITemperatureMeasurement} message TemperatureMeasurement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TemperatureMeasurement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    $root.ord.Time.encode(message.time, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.temperature != null && Object.hasOwnProperty.call(message, "temperature"))
                    $root.ord.Temperature.encode(message.temperature, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TemperatureMeasurement message, length delimited. Does not implicitly {@link ord.TemperatureConditions.TemperatureMeasurement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ord.TemperatureConditions.TemperatureMeasurement
             * @static
             * @param {ord.TemperatureConditions.ITemperatureMeasurement} message TemperatureMeasurement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TemperatureMeasurement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TemperatureMeasurement message from the specified reader or buffer.
             * @function decode
             * @memberof ord.TemperatureConditions.TemperatureMeasurement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ord.TemperatureConditions.TemperatureMeasurement} TemperatureMeasurement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TemperatureMeasurement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.TemperatureConditions.TemperatureMeasurement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.details = reader.string();
                            break;
                        }
                    case 3: {
                            message.time = $root.ord.Time.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.temperature = $root.ord.Temperature.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TemperatureMeasurement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ord.TemperatureConditions.TemperatureMeasurement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ord.TemperatureConditions.TemperatureMeasurement} TemperatureMeasurement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TemperatureMeasurement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TemperatureMeasurement message.
             * @function verify
             * @memberof ord.TemperatureConditions.TemperatureMeasurement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TemperatureMeasurement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.details != null && message.hasOwnProperty("details"))
                    if (!$util.isString(message.details))
                        return "details: string expected";
                if (message.time != null && message.hasOwnProperty("time")) {
                    let error = $root.ord.Time.verify(message.time);
                    if (error)
                        return "time." + error;
                }
                if (message.temperature != null && message.hasOwnProperty("temperature")) {
                    let error = $root.ord.Temperature.verify(message.temperature);
                    if (error)
                        return "temperature." + error;
                }
                return null;
            };

            /**
             * Creates a TemperatureMeasurement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ord.TemperatureConditions.TemperatureMeasurement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ord.TemperatureConditions.TemperatureMeasurement} TemperatureMeasurement
             */
            TemperatureMeasurement.fromObject = function fromObject(object) {
                if (object instanceof $root.ord.TemperatureConditions.TemperatureMeasurement)
                    return object;
                let message = new $root.ord.TemperatureConditions.TemperatureMeasurement();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "UNSPECIFIED":
                case 0:
                    message.type = 0;
                    break;
                case "CUSTOM":
                case 1:
                    message.type = 1;
                    break;
                case "THERMOCOUPLE_INTERNAL":
                case 2:
                    message.type = 2;
                    break;
                case "THERMOCOUPLE_EXTERNAL":
                case 3:
                    message.type = 3;
                    break;
                case "INFRARED":
                case 4:
                    message.type = 4;
                    break;
                }
                if (object.details != null)
                    message.details = String(object.details);
                if (object.time != null) {
                    if (typeof object.time !== "object")
                        throw TypeError(".ord.TemperatureConditions.TemperatureMeasurement.time: object expected");
                    message.time = $root.ord.Time.fromObject(object.time);
                }
                if (object.temperature != null) {
                    if (typeof object.temperature !== "object")
                        throw TypeError(".ord.TemperatureConditions.TemperatureMeasurement.temperature: object expected");
                    message.temperature = $root.ord.Temperature.fromObject(object.temperature);
                }
                return message;
            };

            /**
             * Creates a plain object from a TemperatureMeasurement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ord.TemperatureConditions.TemperatureMeasurement
             * @static
             * @param {ord.TemperatureConditions.TemperatureMeasurement} message TemperatureMeasurement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TemperatureMeasurement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "UNSPECIFIED" : 0;
                    object.details = "";
                    object.time = null;
                    object.temperature = null;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.ord.TemperatureConditions.TemperatureMeasurement.TemperatureMeasurementType[message.type] === undefined ? message.type : $root.ord.TemperatureConditions.TemperatureMeasurement.TemperatureMeasurementType[message.type] : message.type;
                if (message.details != null && message.hasOwnProperty("details"))
                    object.details = message.details;
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = $root.ord.Time.toObject(message.time, options);
                if (message.temperature != null && message.hasOwnProperty("temperature"))
                    object.temperature = $root.ord.Temperature.toObject(message.temperature, options);
                return object;
            };

            /**
             * Converts this TemperatureMeasurement to JSON.
             * @function toJSON
             * @memberof ord.TemperatureConditions.TemperatureMeasurement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TemperatureMeasurement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TemperatureMeasurement
             * @function getTypeUrl
             * @memberof ord.TemperatureConditions.TemperatureMeasurement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TemperatureMeasurement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/ord.TemperatureConditions.TemperatureMeasurement";
            };

            /**
             * TemperatureMeasurementType enum.
             * @name ord.TemperatureConditions.TemperatureMeasurement.TemperatureMeasurementType
             * @enum {number}
             * @property {number} UNSPECIFIED=0 UNSPECIFIED value
             * @property {number} CUSTOM=1 CUSTOM value
             * @property {number} THERMOCOUPLE_INTERNAL=2 THERMOCOUPLE_INTERNAL value
             * @property {number} THERMOCOUPLE_EXTERNAL=3 THERMOCOUPLE_EXTERNAL value
             * @property {number} INFRARED=4 INFRARED value
             */
            TemperatureMeasurement.TemperatureMeasurementType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSPECIFIED"] = 0;
                values[valuesById[1] = "CUSTOM"] = 1;
                values[valuesById[2] = "THERMOCOUPLE_INTERNAL"] = 2;
                values[valuesById[3] = "THERMOCOUPLE_EXTERNAL"] = 3;
                values[valuesById[4] = "INFRARED"] = 4;
                return values;
            })();

            return TemperatureMeasurement;
        })();

        return TemperatureConditions;
    })();

    ord.PressureConditions = (function() {

        /**
         * Properties of a PressureConditions.
         * @memberof ord
         * @interface IPressureConditions
         * @property {ord.PressureConditions.IPressureControl|null} [control] PressureConditions control
         * @property {ord.IPressure|null} [setpoint] PressureConditions setpoint
         * @property {ord.PressureConditions.IAtmosphere|null} [atmosphere] PressureConditions atmosphere
         * @property {Array.<ord.PressureConditions.IPressureMeasurement>|null} [measurements] PressureConditions measurements
         */

        /**
         * Constructs a new PressureConditions.
         * @memberof ord
         * @classdesc Represents a PressureConditions.
         * @implements IPressureConditions
         * @constructor
         * @param {ord.IPressureConditions=} [properties] Properties to set
         */
        function PressureConditions(properties) {
            this.measurements = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PressureConditions control.
         * @member {ord.PressureConditions.IPressureControl|null|undefined} control
         * @memberof ord.PressureConditions
         * @instance
         */
        PressureConditions.prototype.control = null;

        /**
         * PressureConditions setpoint.
         * @member {ord.IPressure|null|undefined} setpoint
         * @memberof ord.PressureConditions
         * @instance
         */
        PressureConditions.prototype.setpoint = null;

        /**
         * PressureConditions atmosphere.
         * @member {ord.PressureConditions.IAtmosphere|null|undefined} atmosphere
         * @memberof ord.PressureConditions
         * @instance
         */
        PressureConditions.prototype.atmosphere = null;

        /**
         * PressureConditions measurements.
         * @member {Array.<ord.PressureConditions.IPressureMeasurement>} measurements
         * @memberof ord.PressureConditions
         * @instance
         */
        PressureConditions.prototype.measurements = $util.emptyArray;

        /**
         * Creates a new PressureConditions instance using the specified properties.
         * @function create
         * @memberof ord.PressureConditions
         * @static
         * @param {ord.IPressureConditions=} [properties] Properties to set
         * @returns {ord.PressureConditions} PressureConditions instance
         */
        PressureConditions.create = function create(properties) {
            return new PressureConditions(properties);
        };

        /**
         * Encodes the specified PressureConditions message. Does not implicitly {@link ord.PressureConditions.verify|verify} messages.
         * @function encode
         * @memberof ord.PressureConditions
         * @static
         * @param {ord.IPressureConditions} message PressureConditions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PressureConditions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                $root.ord.PressureConditions.PressureControl.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.setpoint != null && Object.hasOwnProperty.call(message, "setpoint"))
                $root.ord.Pressure.encode(message.setpoint, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.atmosphere != null && Object.hasOwnProperty.call(message, "atmosphere"))
                $root.ord.PressureConditions.Atmosphere.encode(message.atmosphere, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.measurements != null && message.measurements.length)
                for (let i = 0; i < message.measurements.length; ++i)
                    $root.ord.PressureConditions.PressureMeasurement.encode(message.measurements[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PressureConditions message, length delimited. Does not implicitly {@link ord.PressureConditions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.PressureConditions
         * @static
         * @param {ord.IPressureConditions} message PressureConditions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PressureConditions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PressureConditions message from the specified reader or buffer.
         * @function decode
         * @memberof ord.PressureConditions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.PressureConditions} PressureConditions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PressureConditions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.PressureConditions();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.control = $root.ord.PressureConditions.PressureControl.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.setpoint = $root.ord.Pressure.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.atmosphere = $root.ord.PressureConditions.Atmosphere.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        if (!(message.measurements && message.measurements.length))
                            message.measurements = [];
                        message.measurements.push($root.ord.PressureConditions.PressureMeasurement.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PressureConditions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.PressureConditions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.PressureConditions} PressureConditions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PressureConditions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PressureConditions message.
         * @function verify
         * @memberof ord.PressureConditions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PressureConditions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.control != null && message.hasOwnProperty("control")) {
                let error = $root.ord.PressureConditions.PressureControl.verify(message.control);
                if (error)
                    return "control." + error;
            }
            if (message.setpoint != null && message.hasOwnProperty("setpoint")) {
                let error = $root.ord.Pressure.verify(message.setpoint);
                if (error)
                    return "setpoint." + error;
            }
            if (message.atmosphere != null && message.hasOwnProperty("atmosphere")) {
                let error = $root.ord.PressureConditions.Atmosphere.verify(message.atmosphere);
                if (error)
                    return "atmosphere." + error;
            }
            if (message.measurements != null && message.hasOwnProperty("measurements")) {
                if (!Array.isArray(message.measurements))
                    return "measurements: array expected";
                for (let i = 0; i < message.measurements.length; ++i) {
                    let error = $root.ord.PressureConditions.PressureMeasurement.verify(message.measurements[i]);
                    if (error)
                        return "measurements." + error;
                }
            }
            return null;
        };

        /**
         * Creates a PressureConditions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.PressureConditions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.PressureConditions} PressureConditions
         */
        PressureConditions.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.PressureConditions)
                return object;
            let message = new $root.ord.PressureConditions();
            if (object.control != null) {
                if (typeof object.control !== "object")
                    throw TypeError(".ord.PressureConditions.control: object expected");
                message.control = $root.ord.PressureConditions.PressureControl.fromObject(object.control);
            }
            if (object.setpoint != null) {
                if (typeof object.setpoint !== "object")
                    throw TypeError(".ord.PressureConditions.setpoint: object expected");
                message.setpoint = $root.ord.Pressure.fromObject(object.setpoint);
            }
            if (object.atmosphere != null) {
                if (typeof object.atmosphere !== "object")
                    throw TypeError(".ord.PressureConditions.atmosphere: object expected");
                message.atmosphere = $root.ord.PressureConditions.Atmosphere.fromObject(object.atmosphere);
            }
            if (object.measurements) {
                if (!Array.isArray(object.measurements))
                    throw TypeError(".ord.PressureConditions.measurements: array expected");
                message.measurements = [];
                for (let i = 0; i < object.measurements.length; ++i) {
                    if (typeof object.measurements[i] !== "object")
                        throw TypeError(".ord.PressureConditions.measurements: object expected");
                    message.measurements[i] = $root.ord.PressureConditions.PressureMeasurement.fromObject(object.measurements[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PressureConditions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.PressureConditions
         * @static
         * @param {ord.PressureConditions} message PressureConditions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PressureConditions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.measurements = [];
            if (options.defaults) {
                object.control = null;
                object.setpoint = null;
                object.atmosphere = null;
            }
            if (message.control != null && message.hasOwnProperty("control"))
                object.control = $root.ord.PressureConditions.PressureControl.toObject(message.control, options);
            if (message.setpoint != null && message.hasOwnProperty("setpoint"))
                object.setpoint = $root.ord.Pressure.toObject(message.setpoint, options);
            if (message.atmosphere != null && message.hasOwnProperty("atmosphere"))
                object.atmosphere = $root.ord.PressureConditions.Atmosphere.toObject(message.atmosphere, options);
            if (message.measurements && message.measurements.length) {
                object.measurements = [];
                for (let j = 0; j < message.measurements.length; ++j)
                    object.measurements[j] = $root.ord.PressureConditions.PressureMeasurement.toObject(message.measurements[j], options);
            }
            return object;
        };

        /**
         * Converts this PressureConditions to JSON.
         * @function toJSON
         * @memberof ord.PressureConditions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PressureConditions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PressureConditions
         * @function getTypeUrl
         * @memberof ord.PressureConditions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PressureConditions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.PressureConditions";
        };

        PressureConditions.PressureControl = (function() {

            /**
             * Properties of a PressureControl.
             * @memberof ord.PressureConditions
             * @interface IPressureControl
             * @property {ord.PressureConditions.PressureControl.PressureControlType|null} [type] PressureControl type
             * @property {string|null} [details] PressureControl details
             */

            /**
             * Constructs a new PressureControl.
             * @memberof ord.PressureConditions
             * @classdesc Represents a PressureControl.
             * @implements IPressureControl
             * @constructor
             * @param {ord.PressureConditions.IPressureControl=} [properties] Properties to set
             */
            function PressureControl(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PressureControl type.
             * @member {ord.PressureConditions.PressureControl.PressureControlType} type
             * @memberof ord.PressureConditions.PressureControl
             * @instance
             */
            PressureControl.prototype.type = 0;

            /**
             * PressureControl details.
             * @member {string} details
             * @memberof ord.PressureConditions.PressureControl
             * @instance
             */
            PressureControl.prototype.details = "";

            /**
             * Creates a new PressureControl instance using the specified properties.
             * @function create
             * @memberof ord.PressureConditions.PressureControl
             * @static
             * @param {ord.PressureConditions.IPressureControl=} [properties] Properties to set
             * @returns {ord.PressureConditions.PressureControl} PressureControl instance
             */
            PressureControl.create = function create(properties) {
                return new PressureControl(properties);
            };

            /**
             * Encodes the specified PressureControl message. Does not implicitly {@link ord.PressureConditions.PressureControl.verify|verify} messages.
             * @function encode
             * @memberof ord.PressureConditions.PressureControl
             * @static
             * @param {ord.PressureConditions.IPressureControl} message PressureControl message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PressureControl.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
                return writer;
            };

            /**
             * Encodes the specified PressureControl message, length delimited. Does not implicitly {@link ord.PressureConditions.PressureControl.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ord.PressureConditions.PressureControl
             * @static
             * @param {ord.PressureConditions.IPressureControl} message PressureControl message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PressureControl.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PressureControl message from the specified reader or buffer.
             * @function decode
             * @memberof ord.PressureConditions.PressureControl
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ord.PressureConditions.PressureControl} PressureControl
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PressureControl.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.PressureConditions.PressureControl();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.details = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PressureControl message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ord.PressureConditions.PressureControl
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ord.PressureConditions.PressureControl} PressureControl
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PressureControl.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PressureControl message.
             * @function verify
             * @memberof ord.PressureConditions.PressureControl
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PressureControl.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                if (message.details != null && message.hasOwnProperty("details"))
                    if (!$util.isString(message.details))
                        return "details: string expected";
                return null;
            };

            /**
             * Creates a PressureControl message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ord.PressureConditions.PressureControl
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ord.PressureConditions.PressureControl} PressureControl
             */
            PressureControl.fromObject = function fromObject(object) {
                if (object instanceof $root.ord.PressureConditions.PressureControl)
                    return object;
                let message = new $root.ord.PressureConditions.PressureControl();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "UNSPECIFIED":
                case 0:
                    message.type = 0;
                    break;
                case "CUSTOM":
                case 1:
                    message.type = 1;
                    break;
                case "AMBIENT":
                case 2:
                    message.type = 2;
                    break;
                case "SLIGHT_POSITIVE":
                case 3:
                    message.type = 3;
                    break;
                case "SEALED":
                case 4:
                    message.type = 4;
                    break;
                case "PRESSURIZED":
                case 5:
                    message.type = 5;
                    break;
                }
                if (object.details != null)
                    message.details = String(object.details);
                return message;
            };

            /**
             * Creates a plain object from a PressureControl message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ord.PressureConditions.PressureControl
             * @static
             * @param {ord.PressureConditions.PressureControl} message PressureControl
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PressureControl.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "UNSPECIFIED" : 0;
                    object.details = "";
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.ord.PressureConditions.PressureControl.PressureControlType[message.type] === undefined ? message.type : $root.ord.PressureConditions.PressureControl.PressureControlType[message.type] : message.type;
                if (message.details != null && message.hasOwnProperty("details"))
                    object.details = message.details;
                return object;
            };

            /**
             * Converts this PressureControl to JSON.
             * @function toJSON
             * @memberof ord.PressureConditions.PressureControl
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PressureControl.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PressureControl
             * @function getTypeUrl
             * @memberof ord.PressureConditions.PressureControl
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PressureControl.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/ord.PressureConditions.PressureControl";
            };

            /**
             * PressureControlType enum.
             * @name ord.PressureConditions.PressureControl.PressureControlType
             * @enum {number}
             * @property {number} UNSPECIFIED=0 UNSPECIFIED value
             * @property {number} CUSTOM=1 CUSTOM value
             * @property {number} AMBIENT=2 AMBIENT value
             * @property {number} SLIGHT_POSITIVE=3 SLIGHT_POSITIVE value
             * @property {number} SEALED=4 SEALED value
             * @property {number} PRESSURIZED=5 PRESSURIZED value
             */
            PressureControl.PressureControlType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSPECIFIED"] = 0;
                values[valuesById[1] = "CUSTOM"] = 1;
                values[valuesById[2] = "AMBIENT"] = 2;
                values[valuesById[3] = "SLIGHT_POSITIVE"] = 3;
                values[valuesById[4] = "SEALED"] = 4;
                values[valuesById[5] = "PRESSURIZED"] = 5;
                return values;
            })();

            return PressureControl;
        })();

        PressureConditions.Atmosphere = (function() {

            /**
             * Properties of an Atmosphere.
             * @memberof ord.PressureConditions
             * @interface IAtmosphere
             * @property {ord.PressureConditions.Atmosphere.AtmosphereType|null} [type] Atmosphere type
             * @property {string|null} [details] Atmosphere details
             */

            /**
             * Constructs a new Atmosphere.
             * @memberof ord.PressureConditions
             * @classdesc Represents an Atmosphere.
             * @implements IAtmosphere
             * @constructor
             * @param {ord.PressureConditions.IAtmosphere=} [properties] Properties to set
             */
            function Atmosphere(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Atmosphere type.
             * @member {ord.PressureConditions.Atmosphere.AtmosphereType} type
             * @memberof ord.PressureConditions.Atmosphere
             * @instance
             */
            Atmosphere.prototype.type = 0;

            /**
             * Atmosphere details.
             * @member {string} details
             * @memberof ord.PressureConditions.Atmosphere
             * @instance
             */
            Atmosphere.prototype.details = "";

            /**
             * Creates a new Atmosphere instance using the specified properties.
             * @function create
             * @memberof ord.PressureConditions.Atmosphere
             * @static
             * @param {ord.PressureConditions.IAtmosphere=} [properties] Properties to set
             * @returns {ord.PressureConditions.Atmosphere} Atmosphere instance
             */
            Atmosphere.create = function create(properties) {
                return new Atmosphere(properties);
            };

            /**
             * Encodes the specified Atmosphere message. Does not implicitly {@link ord.PressureConditions.Atmosphere.verify|verify} messages.
             * @function encode
             * @memberof ord.PressureConditions.Atmosphere
             * @static
             * @param {ord.PressureConditions.IAtmosphere} message Atmosphere message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Atmosphere.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
                return writer;
            };

            /**
             * Encodes the specified Atmosphere message, length delimited. Does not implicitly {@link ord.PressureConditions.Atmosphere.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ord.PressureConditions.Atmosphere
             * @static
             * @param {ord.PressureConditions.IAtmosphere} message Atmosphere message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Atmosphere.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Atmosphere message from the specified reader or buffer.
             * @function decode
             * @memberof ord.PressureConditions.Atmosphere
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ord.PressureConditions.Atmosphere} Atmosphere
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Atmosphere.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.PressureConditions.Atmosphere();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.details = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Atmosphere message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ord.PressureConditions.Atmosphere
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ord.PressureConditions.Atmosphere} Atmosphere
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Atmosphere.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Atmosphere message.
             * @function verify
             * @memberof ord.PressureConditions.Atmosphere
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Atmosphere.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                        break;
                    }
                if (message.details != null && message.hasOwnProperty("details"))
                    if (!$util.isString(message.details))
                        return "details: string expected";
                return null;
            };

            /**
             * Creates an Atmosphere message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ord.PressureConditions.Atmosphere
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ord.PressureConditions.Atmosphere} Atmosphere
             */
            Atmosphere.fromObject = function fromObject(object) {
                if (object instanceof $root.ord.PressureConditions.Atmosphere)
                    return object;
                let message = new $root.ord.PressureConditions.Atmosphere();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "UNSPECIFIED":
                case 0:
                    message.type = 0;
                    break;
                case "CUSTOM":
                case 1:
                    message.type = 1;
                    break;
                case "AIR":
                case 2:
                    message.type = 2;
                    break;
                case "NITROGEN":
                case 3:
                    message.type = 3;
                    break;
                case "ARGON":
                case 4:
                    message.type = 4;
                    break;
                case "OXYGEN":
                case 5:
                    message.type = 5;
                    break;
                case "HYDROGEN":
                case 6:
                    message.type = 6;
                    break;
                case "CARBON_MONOXIDE":
                case 7:
                    message.type = 7;
                    break;
                case "CARBON_DIOXIDE":
                case 8:
                    message.type = 8;
                    break;
                case "METHANE":
                case 9:
                    message.type = 9;
                    break;
                case "AMMONIA":
                case 10:
                    message.type = 10;
                    break;
                case "OZONE":
                case 11:
                    message.type = 11;
                    break;
                case "ETHYLENE":
                case 12:
                    message.type = 12;
                    break;
                case "ACETYLENE":
                case 13:
                    message.type = 13;
                    break;
                }
                if (object.details != null)
                    message.details = String(object.details);
                return message;
            };

            /**
             * Creates a plain object from an Atmosphere message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ord.PressureConditions.Atmosphere
             * @static
             * @param {ord.PressureConditions.Atmosphere} message Atmosphere
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Atmosphere.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "UNSPECIFIED" : 0;
                    object.details = "";
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.ord.PressureConditions.Atmosphere.AtmosphereType[message.type] === undefined ? message.type : $root.ord.PressureConditions.Atmosphere.AtmosphereType[message.type] : message.type;
                if (message.details != null && message.hasOwnProperty("details"))
                    object.details = message.details;
                return object;
            };

            /**
             * Converts this Atmosphere to JSON.
             * @function toJSON
             * @memberof ord.PressureConditions.Atmosphere
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Atmosphere.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Atmosphere
             * @function getTypeUrl
             * @memberof ord.PressureConditions.Atmosphere
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Atmosphere.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/ord.PressureConditions.Atmosphere";
            };

            /**
             * AtmosphereType enum.
             * @name ord.PressureConditions.Atmosphere.AtmosphereType
             * @enum {number}
             * @property {number} UNSPECIFIED=0 UNSPECIFIED value
             * @property {number} CUSTOM=1 CUSTOM value
             * @property {number} AIR=2 AIR value
             * @property {number} NITROGEN=3 NITROGEN value
             * @property {number} ARGON=4 ARGON value
             * @property {number} OXYGEN=5 OXYGEN value
             * @property {number} HYDROGEN=6 HYDROGEN value
             * @property {number} CARBON_MONOXIDE=7 CARBON_MONOXIDE value
             * @property {number} CARBON_DIOXIDE=8 CARBON_DIOXIDE value
             * @property {number} METHANE=9 METHANE value
             * @property {number} AMMONIA=10 AMMONIA value
             * @property {number} OZONE=11 OZONE value
             * @property {number} ETHYLENE=12 ETHYLENE value
             * @property {number} ACETYLENE=13 ACETYLENE value
             */
            Atmosphere.AtmosphereType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSPECIFIED"] = 0;
                values[valuesById[1] = "CUSTOM"] = 1;
                values[valuesById[2] = "AIR"] = 2;
                values[valuesById[3] = "NITROGEN"] = 3;
                values[valuesById[4] = "ARGON"] = 4;
                values[valuesById[5] = "OXYGEN"] = 5;
                values[valuesById[6] = "HYDROGEN"] = 6;
                values[valuesById[7] = "CARBON_MONOXIDE"] = 7;
                values[valuesById[8] = "CARBON_DIOXIDE"] = 8;
                values[valuesById[9] = "METHANE"] = 9;
                values[valuesById[10] = "AMMONIA"] = 10;
                values[valuesById[11] = "OZONE"] = 11;
                values[valuesById[12] = "ETHYLENE"] = 12;
                values[valuesById[13] = "ACETYLENE"] = 13;
                return values;
            })();

            return Atmosphere;
        })();

        PressureConditions.PressureMeasurement = (function() {

            /**
             * Properties of a PressureMeasurement.
             * @memberof ord.PressureConditions
             * @interface IPressureMeasurement
             * @property {ord.PressureConditions.PressureMeasurement.PressureMeasurementType|null} [type] PressureMeasurement type
             * @property {string|null} [details] PressureMeasurement details
             * @property {ord.ITime|null} [time] PressureMeasurement time
             * @property {ord.IPressure|null} [pressure] PressureMeasurement pressure
             */

            /**
             * Constructs a new PressureMeasurement.
             * @memberof ord.PressureConditions
             * @classdesc Represents a PressureMeasurement.
             * @implements IPressureMeasurement
             * @constructor
             * @param {ord.PressureConditions.IPressureMeasurement=} [properties] Properties to set
             */
            function PressureMeasurement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PressureMeasurement type.
             * @member {ord.PressureConditions.PressureMeasurement.PressureMeasurementType} type
             * @memberof ord.PressureConditions.PressureMeasurement
             * @instance
             */
            PressureMeasurement.prototype.type = 0;

            /**
             * PressureMeasurement details.
             * @member {string} details
             * @memberof ord.PressureConditions.PressureMeasurement
             * @instance
             */
            PressureMeasurement.prototype.details = "";

            /**
             * PressureMeasurement time.
             * @member {ord.ITime|null|undefined} time
             * @memberof ord.PressureConditions.PressureMeasurement
             * @instance
             */
            PressureMeasurement.prototype.time = null;

            /**
             * PressureMeasurement pressure.
             * @member {ord.IPressure|null|undefined} pressure
             * @memberof ord.PressureConditions.PressureMeasurement
             * @instance
             */
            PressureMeasurement.prototype.pressure = null;

            /**
             * Creates a new PressureMeasurement instance using the specified properties.
             * @function create
             * @memberof ord.PressureConditions.PressureMeasurement
             * @static
             * @param {ord.PressureConditions.IPressureMeasurement=} [properties] Properties to set
             * @returns {ord.PressureConditions.PressureMeasurement} PressureMeasurement instance
             */
            PressureMeasurement.create = function create(properties) {
                return new PressureMeasurement(properties);
            };

            /**
             * Encodes the specified PressureMeasurement message. Does not implicitly {@link ord.PressureConditions.PressureMeasurement.verify|verify} messages.
             * @function encode
             * @memberof ord.PressureConditions.PressureMeasurement
             * @static
             * @param {ord.PressureConditions.IPressureMeasurement} message PressureMeasurement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PressureMeasurement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    $root.ord.Time.encode(message.time, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.pressure != null && Object.hasOwnProperty.call(message, "pressure"))
                    $root.ord.Pressure.encode(message.pressure, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PressureMeasurement message, length delimited. Does not implicitly {@link ord.PressureConditions.PressureMeasurement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ord.PressureConditions.PressureMeasurement
             * @static
             * @param {ord.PressureConditions.IPressureMeasurement} message PressureMeasurement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PressureMeasurement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PressureMeasurement message from the specified reader or buffer.
             * @function decode
             * @memberof ord.PressureConditions.PressureMeasurement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ord.PressureConditions.PressureMeasurement} PressureMeasurement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PressureMeasurement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.PressureConditions.PressureMeasurement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.details = reader.string();
                            break;
                        }
                    case 3: {
                            message.time = $root.ord.Time.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.pressure = $root.ord.Pressure.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PressureMeasurement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ord.PressureConditions.PressureMeasurement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ord.PressureConditions.PressureMeasurement} PressureMeasurement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PressureMeasurement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PressureMeasurement message.
             * @function verify
             * @memberof ord.PressureConditions.PressureMeasurement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PressureMeasurement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.details != null && message.hasOwnProperty("details"))
                    if (!$util.isString(message.details))
                        return "details: string expected";
                if (message.time != null && message.hasOwnProperty("time")) {
                    let error = $root.ord.Time.verify(message.time);
                    if (error)
                        return "time." + error;
                }
                if (message.pressure != null && message.hasOwnProperty("pressure")) {
                    let error = $root.ord.Pressure.verify(message.pressure);
                    if (error)
                        return "pressure." + error;
                }
                return null;
            };

            /**
             * Creates a PressureMeasurement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ord.PressureConditions.PressureMeasurement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ord.PressureConditions.PressureMeasurement} PressureMeasurement
             */
            PressureMeasurement.fromObject = function fromObject(object) {
                if (object instanceof $root.ord.PressureConditions.PressureMeasurement)
                    return object;
                let message = new $root.ord.PressureConditions.PressureMeasurement();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "UNSPECIFIED":
                case 0:
                    message.type = 0;
                    break;
                case "CUSTOM":
                case 1:
                    message.type = 1;
                    break;
                case "PRESSURE_TRANSDUCER":
                case 2:
                    message.type = 2;
                    break;
                }
                if (object.details != null)
                    message.details = String(object.details);
                if (object.time != null) {
                    if (typeof object.time !== "object")
                        throw TypeError(".ord.PressureConditions.PressureMeasurement.time: object expected");
                    message.time = $root.ord.Time.fromObject(object.time);
                }
                if (object.pressure != null) {
                    if (typeof object.pressure !== "object")
                        throw TypeError(".ord.PressureConditions.PressureMeasurement.pressure: object expected");
                    message.pressure = $root.ord.Pressure.fromObject(object.pressure);
                }
                return message;
            };

            /**
             * Creates a plain object from a PressureMeasurement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ord.PressureConditions.PressureMeasurement
             * @static
             * @param {ord.PressureConditions.PressureMeasurement} message PressureMeasurement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PressureMeasurement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "UNSPECIFIED" : 0;
                    object.details = "";
                    object.time = null;
                    object.pressure = null;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.ord.PressureConditions.PressureMeasurement.PressureMeasurementType[message.type] === undefined ? message.type : $root.ord.PressureConditions.PressureMeasurement.PressureMeasurementType[message.type] : message.type;
                if (message.details != null && message.hasOwnProperty("details"))
                    object.details = message.details;
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = $root.ord.Time.toObject(message.time, options);
                if (message.pressure != null && message.hasOwnProperty("pressure"))
                    object.pressure = $root.ord.Pressure.toObject(message.pressure, options);
                return object;
            };

            /**
             * Converts this PressureMeasurement to JSON.
             * @function toJSON
             * @memberof ord.PressureConditions.PressureMeasurement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PressureMeasurement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PressureMeasurement
             * @function getTypeUrl
             * @memberof ord.PressureConditions.PressureMeasurement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PressureMeasurement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/ord.PressureConditions.PressureMeasurement";
            };

            /**
             * PressureMeasurementType enum.
             * @name ord.PressureConditions.PressureMeasurement.PressureMeasurementType
             * @enum {number}
             * @property {number} UNSPECIFIED=0 UNSPECIFIED value
             * @property {number} CUSTOM=1 CUSTOM value
             * @property {number} PRESSURE_TRANSDUCER=2 PRESSURE_TRANSDUCER value
             */
            PressureMeasurement.PressureMeasurementType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSPECIFIED"] = 0;
                values[valuesById[1] = "CUSTOM"] = 1;
                values[valuesById[2] = "PRESSURE_TRANSDUCER"] = 2;
                return values;
            })();

            return PressureMeasurement;
        })();

        return PressureConditions;
    })();

    ord.StirringConditions = (function() {

        /**
         * Properties of a StirringConditions.
         * @memberof ord
         * @interface IStirringConditions
         * @property {ord.StirringConditions.StirringMethodType|null} [type] StirringConditions type
         * @property {string|null} [details] StirringConditions details
         * @property {ord.StirringConditions.IStirringRate|null} [rate] StirringConditions rate
         */

        /**
         * Constructs a new StirringConditions.
         * @memberof ord
         * @classdesc Represents a StirringConditions.
         * @implements IStirringConditions
         * @constructor
         * @param {ord.IStirringConditions=} [properties] Properties to set
         */
        function StirringConditions(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StirringConditions type.
         * @member {ord.StirringConditions.StirringMethodType} type
         * @memberof ord.StirringConditions
         * @instance
         */
        StirringConditions.prototype.type = 0;

        /**
         * StirringConditions details.
         * @member {string} details
         * @memberof ord.StirringConditions
         * @instance
         */
        StirringConditions.prototype.details = "";

        /**
         * StirringConditions rate.
         * @member {ord.StirringConditions.IStirringRate|null|undefined} rate
         * @memberof ord.StirringConditions
         * @instance
         */
        StirringConditions.prototype.rate = null;

        /**
         * Creates a new StirringConditions instance using the specified properties.
         * @function create
         * @memberof ord.StirringConditions
         * @static
         * @param {ord.IStirringConditions=} [properties] Properties to set
         * @returns {ord.StirringConditions} StirringConditions instance
         */
        StirringConditions.create = function create(properties) {
            return new StirringConditions(properties);
        };

        /**
         * Encodes the specified StirringConditions message. Does not implicitly {@link ord.StirringConditions.verify|verify} messages.
         * @function encode
         * @memberof ord.StirringConditions
         * @static
         * @param {ord.IStirringConditions} message StirringConditions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StirringConditions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
            if (message.rate != null && Object.hasOwnProperty.call(message, "rate"))
                $root.ord.StirringConditions.StirringRate.encode(message.rate, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StirringConditions message, length delimited. Does not implicitly {@link ord.StirringConditions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.StirringConditions
         * @static
         * @param {ord.IStirringConditions} message StirringConditions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StirringConditions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StirringConditions message from the specified reader or buffer.
         * @function decode
         * @memberof ord.StirringConditions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.StirringConditions} StirringConditions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StirringConditions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.StirringConditions();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.details = reader.string();
                        break;
                    }
                case 3: {
                        message.rate = $root.ord.StirringConditions.StirringRate.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StirringConditions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.StirringConditions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.StirringConditions} StirringConditions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StirringConditions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StirringConditions message.
         * @function verify
         * @memberof ord.StirringConditions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StirringConditions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    break;
                }
            if (message.details != null && message.hasOwnProperty("details"))
                if (!$util.isString(message.details))
                    return "details: string expected";
            if (message.rate != null && message.hasOwnProperty("rate")) {
                let error = $root.ord.StirringConditions.StirringRate.verify(message.rate);
                if (error)
                    return "rate." + error;
            }
            return null;
        };

        /**
         * Creates a StirringConditions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.StirringConditions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.StirringConditions} StirringConditions
         */
        StirringConditions.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.StirringConditions)
                return object;
            let message = new $root.ord.StirringConditions();
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.type = 0;
                break;
            case "CUSTOM":
            case 1:
                message.type = 1;
                break;
            case "NONE":
            case 2:
                message.type = 2;
                break;
            case "STIR_BAR":
            case 3:
                message.type = 3;
                break;
            case "OVERHEAD_MIXER":
            case 4:
                message.type = 4;
                break;
            case "AGITATION":
            case 5:
                message.type = 5;
                break;
            case "BALL_MILLING":
            case 6:
                message.type = 6;
                break;
            case "SONICATION":
            case 7:
                message.type = 7;
                break;
            }
            if (object.details != null)
                message.details = String(object.details);
            if (object.rate != null) {
                if (typeof object.rate !== "object")
                    throw TypeError(".ord.StirringConditions.rate: object expected");
                message.rate = $root.ord.StirringConditions.StirringRate.fromObject(object.rate);
            }
            return message;
        };

        /**
         * Creates a plain object from a StirringConditions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.StirringConditions
         * @static
         * @param {ord.StirringConditions} message StirringConditions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StirringConditions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "UNSPECIFIED" : 0;
                object.details = "";
                object.rate = null;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.ord.StirringConditions.StirringMethodType[message.type] === undefined ? message.type : $root.ord.StirringConditions.StirringMethodType[message.type] : message.type;
            if (message.details != null && message.hasOwnProperty("details"))
                object.details = message.details;
            if (message.rate != null && message.hasOwnProperty("rate"))
                object.rate = $root.ord.StirringConditions.StirringRate.toObject(message.rate, options);
            return object;
        };

        /**
         * Converts this StirringConditions to JSON.
         * @function toJSON
         * @memberof ord.StirringConditions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StirringConditions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for StirringConditions
         * @function getTypeUrl
         * @memberof ord.StirringConditions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        StirringConditions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.StirringConditions";
        };

        /**
         * StirringMethodType enum.
         * @name ord.StirringConditions.StirringMethodType
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} CUSTOM=1 CUSTOM value
         * @property {number} NONE=2 NONE value
         * @property {number} STIR_BAR=3 STIR_BAR value
         * @property {number} OVERHEAD_MIXER=4 OVERHEAD_MIXER value
         * @property {number} AGITATION=5 AGITATION value
         * @property {number} BALL_MILLING=6 BALL_MILLING value
         * @property {number} SONICATION=7 SONICATION value
         */
        StirringConditions.StirringMethodType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "CUSTOM"] = 1;
            values[valuesById[2] = "NONE"] = 2;
            values[valuesById[3] = "STIR_BAR"] = 3;
            values[valuesById[4] = "OVERHEAD_MIXER"] = 4;
            values[valuesById[5] = "AGITATION"] = 5;
            values[valuesById[6] = "BALL_MILLING"] = 6;
            values[valuesById[7] = "SONICATION"] = 7;
            return values;
        })();

        StirringConditions.StirringRate = (function() {

            /**
             * Properties of a StirringRate.
             * @memberof ord.StirringConditions
             * @interface IStirringRate
             * @property {ord.StirringConditions.StirringRate.StirringRateType|null} [type] StirringRate type
             * @property {string|null} [details] StirringRate details
             * @property {number|null} [rpm] StirringRate rpm
             */

            /**
             * Constructs a new StirringRate.
             * @memberof ord.StirringConditions
             * @classdesc Represents a StirringRate.
             * @implements IStirringRate
             * @constructor
             * @param {ord.StirringConditions.IStirringRate=} [properties] Properties to set
             */
            function StirringRate(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StirringRate type.
             * @member {ord.StirringConditions.StirringRate.StirringRateType} type
             * @memberof ord.StirringConditions.StirringRate
             * @instance
             */
            StirringRate.prototype.type = 0;

            /**
             * StirringRate details.
             * @member {string} details
             * @memberof ord.StirringConditions.StirringRate
             * @instance
             */
            StirringRate.prototype.details = "";

            /**
             * StirringRate rpm.
             * @member {number} rpm
             * @memberof ord.StirringConditions.StirringRate
             * @instance
             */
            StirringRate.prototype.rpm = 0;

            /**
             * Creates a new StirringRate instance using the specified properties.
             * @function create
             * @memberof ord.StirringConditions.StirringRate
             * @static
             * @param {ord.StirringConditions.IStirringRate=} [properties] Properties to set
             * @returns {ord.StirringConditions.StirringRate} StirringRate instance
             */
            StirringRate.create = function create(properties) {
                return new StirringRate(properties);
            };

            /**
             * Encodes the specified StirringRate message. Does not implicitly {@link ord.StirringConditions.StirringRate.verify|verify} messages.
             * @function encode
             * @memberof ord.StirringConditions.StirringRate
             * @static
             * @param {ord.StirringConditions.IStirringRate} message StirringRate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StirringRate.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
                if (message.rpm != null && Object.hasOwnProperty.call(message, "rpm"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.rpm);
                return writer;
            };

            /**
             * Encodes the specified StirringRate message, length delimited. Does not implicitly {@link ord.StirringConditions.StirringRate.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ord.StirringConditions.StirringRate
             * @static
             * @param {ord.StirringConditions.IStirringRate} message StirringRate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StirringRate.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StirringRate message from the specified reader or buffer.
             * @function decode
             * @memberof ord.StirringConditions.StirringRate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ord.StirringConditions.StirringRate} StirringRate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StirringRate.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.StirringConditions.StirringRate();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.details = reader.string();
                            break;
                        }
                    case 3: {
                            message.rpm = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StirringRate message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ord.StirringConditions.StirringRate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ord.StirringConditions.StirringRate} StirringRate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StirringRate.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StirringRate message.
             * @function verify
             * @memberof ord.StirringConditions.StirringRate
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StirringRate.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.details != null && message.hasOwnProperty("details"))
                    if (!$util.isString(message.details))
                        return "details: string expected";
                if (message.rpm != null && message.hasOwnProperty("rpm"))
                    if (!$util.isInteger(message.rpm))
                        return "rpm: integer expected";
                return null;
            };

            /**
             * Creates a StirringRate message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ord.StirringConditions.StirringRate
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ord.StirringConditions.StirringRate} StirringRate
             */
            StirringRate.fromObject = function fromObject(object) {
                if (object instanceof $root.ord.StirringConditions.StirringRate)
                    return object;
                let message = new $root.ord.StirringConditions.StirringRate();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "UNSPECIFIED":
                case 0:
                    message.type = 0;
                    break;
                case "HIGH":
                case 1:
                    message.type = 1;
                    break;
                case "MEDIUM":
                case 2:
                    message.type = 2;
                    break;
                case "LOW":
                case 3:
                    message.type = 3;
                    break;
                }
                if (object.details != null)
                    message.details = String(object.details);
                if (object.rpm != null)
                    message.rpm = object.rpm | 0;
                return message;
            };

            /**
             * Creates a plain object from a StirringRate message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ord.StirringConditions.StirringRate
             * @static
             * @param {ord.StirringConditions.StirringRate} message StirringRate
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StirringRate.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "UNSPECIFIED" : 0;
                    object.details = "";
                    object.rpm = 0;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.ord.StirringConditions.StirringRate.StirringRateType[message.type] === undefined ? message.type : $root.ord.StirringConditions.StirringRate.StirringRateType[message.type] : message.type;
                if (message.details != null && message.hasOwnProperty("details"))
                    object.details = message.details;
                if (message.rpm != null && message.hasOwnProperty("rpm"))
                    object.rpm = message.rpm;
                return object;
            };

            /**
             * Converts this StirringRate to JSON.
             * @function toJSON
             * @memberof ord.StirringConditions.StirringRate
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StirringRate.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for StirringRate
             * @function getTypeUrl
             * @memberof ord.StirringConditions.StirringRate
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            StirringRate.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/ord.StirringConditions.StirringRate";
            };

            /**
             * StirringRateType enum.
             * @name ord.StirringConditions.StirringRate.StirringRateType
             * @enum {number}
             * @property {number} UNSPECIFIED=0 UNSPECIFIED value
             * @property {number} HIGH=1 HIGH value
             * @property {number} MEDIUM=2 MEDIUM value
             * @property {number} LOW=3 LOW value
             */
            StirringRate.StirringRateType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSPECIFIED"] = 0;
                values[valuesById[1] = "HIGH"] = 1;
                values[valuesById[2] = "MEDIUM"] = 2;
                values[valuesById[3] = "LOW"] = 3;
                return values;
            })();

            return StirringRate;
        })();

        return StirringConditions;
    })();

    ord.IlluminationConditions = (function() {

        /**
         * Properties of an IlluminationConditions.
         * @memberof ord
         * @interface IIlluminationConditions
         * @property {ord.IlluminationConditions.IlluminationType|null} [type] IlluminationConditions type
         * @property {string|null} [details] IlluminationConditions details
         * @property {ord.IWavelength|null} [peakWavelength] IlluminationConditions peakWavelength
         * @property {string|null} [color] IlluminationConditions color
         * @property {ord.ILength|null} [distanceToVessel] IlluminationConditions distanceToVessel
         */

        /**
         * Constructs a new IlluminationConditions.
         * @memberof ord
         * @classdesc Represents an IlluminationConditions.
         * @implements IIlluminationConditions
         * @constructor
         * @param {ord.IIlluminationConditions=} [properties] Properties to set
         */
        function IlluminationConditions(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IlluminationConditions type.
         * @member {ord.IlluminationConditions.IlluminationType} type
         * @memberof ord.IlluminationConditions
         * @instance
         */
        IlluminationConditions.prototype.type = 0;

        /**
         * IlluminationConditions details.
         * @member {string} details
         * @memberof ord.IlluminationConditions
         * @instance
         */
        IlluminationConditions.prototype.details = "";

        /**
         * IlluminationConditions peakWavelength.
         * @member {ord.IWavelength|null|undefined} peakWavelength
         * @memberof ord.IlluminationConditions
         * @instance
         */
        IlluminationConditions.prototype.peakWavelength = null;

        /**
         * IlluminationConditions color.
         * @member {string} color
         * @memberof ord.IlluminationConditions
         * @instance
         */
        IlluminationConditions.prototype.color = "";

        /**
         * IlluminationConditions distanceToVessel.
         * @member {ord.ILength|null|undefined} distanceToVessel
         * @memberof ord.IlluminationConditions
         * @instance
         */
        IlluminationConditions.prototype.distanceToVessel = null;

        /**
         * Creates a new IlluminationConditions instance using the specified properties.
         * @function create
         * @memberof ord.IlluminationConditions
         * @static
         * @param {ord.IIlluminationConditions=} [properties] Properties to set
         * @returns {ord.IlluminationConditions} IlluminationConditions instance
         */
        IlluminationConditions.create = function create(properties) {
            return new IlluminationConditions(properties);
        };

        /**
         * Encodes the specified IlluminationConditions message. Does not implicitly {@link ord.IlluminationConditions.verify|verify} messages.
         * @function encode
         * @memberof ord.IlluminationConditions
         * @static
         * @param {ord.IIlluminationConditions} message IlluminationConditions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IlluminationConditions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
            if (message.peakWavelength != null && Object.hasOwnProperty.call(message, "peakWavelength"))
                $root.ord.Wavelength.encode(message.peakWavelength, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.color);
            if (message.distanceToVessel != null && Object.hasOwnProperty.call(message, "distanceToVessel"))
                $root.ord.Length.encode(message.distanceToVessel, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IlluminationConditions message, length delimited. Does not implicitly {@link ord.IlluminationConditions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.IlluminationConditions
         * @static
         * @param {ord.IIlluminationConditions} message IlluminationConditions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IlluminationConditions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IlluminationConditions message from the specified reader or buffer.
         * @function decode
         * @memberof ord.IlluminationConditions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.IlluminationConditions} IlluminationConditions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IlluminationConditions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.IlluminationConditions();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.details = reader.string();
                        break;
                    }
                case 3: {
                        message.peakWavelength = $root.ord.Wavelength.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.color = reader.string();
                        break;
                    }
                case 5: {
                        message.distanceToVessel = $root.ord.Length.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IlluminationConditions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.IlluminationConditions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.IlluminationConditions} IlluminationConditions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IlluminationConditions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IlluminationConditions message.
         * @function verify
         * @memberof ord.IlluminationConditions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IlluminationConditions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            if (message.details != null && message.hasOwnProperty("details"))
                if (!$util.isString(message.details))
                    return "details: string expected";
            if (message.peakWavelength != null && message.hasOwnProperty("peakWavelength")) {
                let error = $root.ord.Wavelength.verify(message.peakWavelength);
                if (error)
                    return "peakWavelength." + error;
            }
            if (message.color != null && message.hasOwnProperty("color"))
                if (!$util.isString(message.color))
                    return "color: string expected";
            if (message.distanceToVessel != null && message.hasOwnProperty("distanceToVessel")) {
                let error = $root.ord.Length.verify(message.distanceToVessel);
                if (error)
                    return "distanceToVessel." + error;
            }
            return null;
        };

        /**
         * Creates an IlluminationConditions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.IlluminationConditions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.IlluminationConditions} IlluminationConditions
         */
        IlluminationConditions.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.IlluminationConditions)
                return object;
            let message = new $root.ord.IlluminationConditions();
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.type = 0;
                break;
            case "CUSTOM":
            case 1:
                message.type = 1;
                break;
            case "AMBIENT":
            case 2:
                message.type = 2;
                break;
            case "DARK":
            case 3:
                message.type = 3;
                break;
            case "LED":
            case 4:
                message.type = 4;
                break;
            case "HALOGEN_LAMP":
            case 5:
                message.type = 5;
                break;
            case "DEUTERIUM_LAMP":
            case 6:
                message.type = 6;
                break;
            case "SOLAR_SIMULATOR":
            case 7:
                message.type = 7;
                break;
            case "BROAD_SPECTRUM":
            case 8:
                message.type = 8;
                break;
            }
            if (object.details != null)
                message.details = String(object.details);
            if (object.peakWavelength != null) {
                if (typeof object.peakWavelength !== "object")
                    throw TypeError(".ord.IlluminationConditions.peakWavelength: object expected");
                message.peakWavelength = $root.ord.Wavelength.fromObject(object.peakWavelength);
            }
            if (object.color != null)
                message.color = String(object.color);
            if (object.distanceToVessel != null) {
                if (typeof object.distanceToVessel !== "object")
                    throw TypeError(".ord.IlluminationConditions.distanceToVessel: object expected");
                message.distanceToVessel = $root.ord.Length.fromObject(object.distanceToVessel);
            }
            return message;
        };

        /**
         * Creates a plain object from an IlluminationConditions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.IlluminationConditions
         * @static
         * @param {ord.IlluminationConditions} message IlluminationConditions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IlluminationConditions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "UNSPECIFIED" : 0;
                object.details = "";
                object.peakWavelength = null;
                object.color = "";
                object.distanceToVessel = null;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.ord.IlluminationConditions.IlluminationType[message.type] === undefined ? message.type : $root.ord.IlluminationConditions.IlluminationType[message.type] : message.type;
            if (message.details != null && message.hasOwnProperty("details"))
                object.details = message.details;
            if (message.peakWavelength != null && message.hasOwnProperty("peakWavelength"))
                object.peakWavelength = $root.ord.Wavelength.toObject(message.peakWavelength, options);
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            if (message.distanceToVessel != null && message.hasOwnProperty("distanceToVessel"))
                object.distanceToVessel = $root.ord.Length.toObject(message.distanceToVessel, options);
            return object;
        };

        /**
         * Converts this IlluminationConditions to JSON.
         * @function toJSON
         * @memberof ord.IlluminationConditions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IlluminationConditions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for IlluminationConditions
         * @function getTypeUrl
         * @memberof ord.IlluminationConditions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        IlluminationConditions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.IlluminationConditions";
        };

        /**
         * IlluminationType enum.
         * @name ord.IlluminationConditions.IlluminationType
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} CUSTOM=1 CUSTOM value
         * @property {number} AMBIENT=2 AMBIENT value
         * @property {number} DARK=3 DARK value
         * @property {number} LED=4 LED value
         * @property {number} HALOGEN_LAMP=5 HALOGEN_LAMP value
         * @property {number} DEUTERIUM_LAMP=6 DEUTERIUM_LAMP value
         * @property {number} SOLAR_SIMULATOR=7 SOLAR_SIMULATOR value
         * @property {number} BROAD_SPECTRUM=8 BROAD_SPECTRUM value
         */
        IlluminationConditions.IlluminationType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "CUSTOM"] = 1;
            values[valuesById[2] = "AMBIENT"] = 2;
            values[valuesById[3] = "DARK"] = 3;
            values[valuesById[4] = "LED"] = 4;
            values[valuesById[5] = "HALOGEN_LAMP"] = 5;
            values[valuesById[6] = "DEUTERIUM_LAMP"] = 6;
            values[valuesById[7] = "SOLAR_SIMULATOR"] = 7;
            values[valuesById[8] = "BROAD_SPECTRUM"] = 8;
            return values;
        })();

        return IlluminationConditions;
    })();

    ord.ElectrochemistryConditions = (function() {

        /**
         * Properties of an ElectrochemistryConditions.
         * @memberof ord
         * @interface IElectrochemistryConditions
         * @property {ord.ElectrochemistryConditions.ElectrochemistryType|null} [type] ElectrochemistryConditions type
         * @property {string|null} [details] ElectrochemistryConditions details
         * @property {ord.ICurrent|null} [current] ElectrochemistryConditions current
         * @property {ord.IVoltage|null} [voltage] ElectrochemistryConditions voltage
         * @property {string|null} [anodeMaterial] ElectrochemistryConditions anodeMaterial
         * @property {string|null} [cathodeMaterial] ElectrochemistryConditions cathodeMaterial
         * @property {ord.ILength|null} [electrodeSeparation] ElectrochemistryConditions electrodeSeparation
         * @property {Array.<ord.ElectrochemistryConditions.IElectrochemistryMeasurement>|null} [measurements] ElectrochemistryConditions measurements
         * @property {ord.ElectrochemistryConditions.IElectrochemistryCell|null} [cell] ElectrochemistryConditions cell
         */

        /**
         * Constructs a new ElectrochemistryConditions.
         * @memberof ord
         * @classdesc Represents an ElectrochemistryConditions.
         * @implements IElectrochemistryConditions
         * @constructor
         * @param {ord.IElectrochemistryConditions=} [properties] Properties to set
         */
        function ElectrochemistryConditions(properties) {
            this.measurements = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ElectrochemistryConditions type.
         * @member {ord.ElectrochemistryConditions.ElectrochemistryType} type
         * @memberof ord.ElectrochemistryConditions
         * @instance
         */
        ElectrochemistryConditions.prototype.type = 0;

        /**
         * ElectrochemistryConditions details.
         * @member {string} details
         * @memberof ord.ElectrochemistryConditions
         * @instance
         */
        ElectrochemistryConditions.prototype.details = "";

        /**
         * ElectrochemistryConditions current.
         * @member {ord.ICurrent|null|undefined} current
         * @memberof ord.ElectrochemistryConditions
         * @instance
         */
        ElectrochemistryConditions.prototype.current = null;

        /**
         * ElectrochemistryConditions voltage.
         * @member {ord.IVoltage|null|undefined} voltage
         * @memberof ord.ElectrochemistryConditions
         * @instance
         */
        ElectrochemistryConditions.prototype.voltage = null;

        /**
         * ElectrochemistryConditions anodeMaterial.
         * @member {string} anodeMaterial
         * @memberof ord.ElectrochemistryConditions
         * @instance
         */
        ElectrochemistryConditions.prototype.anodeMaterial = "";

        /**
         * ElectrochemistryConditions cathodeMaterial.
         * @member {string} cathodeMaterial
         * @memberof ord.ElectrochemistryConditions
         * @instance
         */
        ElectrochemistryConditions.prototype.cathodeMaterial = "";

        /**
         * ElectrochemistryConditions electrodeSeparation.
         * @member {ord.ILength|null|undefined} electrodeSeparation
         * @memberof ord.ElectrochemistryConditions
         * @instance
         */
        ElectrochemistryConditions.prototype.electrodeSeparation = null;

        /**
         * ElectrochemistryConditions measurements.
         * @member {Array.<ord.ElectrochemistryConditions.IElectrochemistryMeasurement>} measurements
         * @memberof ord.ElectrochemistryConditions
         * @instance
         */
        ElectrochemistryConditions.prototype.measurements = $util.emptyArray;

        /**
         * ElectrochemistryConditions cell.
         * @member {ord.ElectrochemistryConditions.IElectrochemistryCell|null|undefined} cell
         * @memberof ord.ElectrochemistryConditions
         * @instance
         */
        ElectrochemistryConditions.prototype.cell = null;

        /**
         * Creates a new ElectrochemistryConditions instance using the specified properties.
         * @function create
         * @memberof ord.ElectrochemistryConditions
         * @static
         * @param {ord.IElectrochemistryConditions=} [properties] Properties to set
         * @returns {ord.ElectrochemistryConditions} ElectrochemistryConditions instance
         */
        ElectrochemistryConditions.create = function create(properties) {
            return new ElectrochemistryConditions(properties);
        };

        /**
         * Encodes the specified ElectrochemistryConditions message. Does not implicitly {@link ord.ElectrochemistryConditions.verify|verify} messages.
         * @function encode
         * @memberof ord.ElectrochemistryConditions
         * @static
         * @param {ord.IElectrochemistryConditions} message ElectrochemistryConditions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ElectrochemistryConditions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
            if (message.current != null && Object.hasOwnProperty.call(message, "current"))
                $root.ord.Current.encode(message.current, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.voltage != null && Object.hasOwnProperty.call(message, "voltage"))
                $root.ord.Voltage.encode(message.voltage, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.anodeMaterial != null && Object.hasOwnProperty.call(message, "anodeMaterial"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.anodeMaterial);
            if (message.cathodeMaterial != null && Object.hasOwnProperty.call(message, "cathodeMaterial"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.cathodeMaterial);
            if (message.electrodeSeparation != null && Object.hasOwnProperty.call(message, "electrodeSeparation"))
                $root.ord.Length.encode(message.electrodeSeparation, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.measurements != null && message.measurements.length)
                for (let i = 0; i < message.measurements.length; ++i)
                    $root.ord.ElectrochemistryConditions.ElectrochemistryMeasurement.encode(message.measurements[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.cell != null && Object.hasOwnProperty.call(message, "cell"))
                $root.ord.ElectrochemistryConditions.ElectrochemistryCell.encode(message.cell, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ElectrochemistryConditions message, length delimited. Does not implicitly {@link ord.ElectrochemistryConditions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.ElectrochemistryConditions
         * @static
         * @param {ord.IElectrochemistryConditions} message ElectrochemistryConditions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ElectrochemistryConditions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ElectrochemistryConditions message from the specified reader or buffer.
         * @function decode
         * @memberof ord.ElectrochemistryConditions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.ElectrochemistryConditions} ElectrochemistryConditions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ElectrochemistryConditions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.ElectrochemistryConditions();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.details = reader.string();
                        break;
                    }
                case 3: {
                        message.current = $root.ord.Current.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.voltage = $root.ord.Voltage.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.anodeMaterial = reader.string();
                        break;
                    }
                case 6: {
                        message.cathodeMaterial = reader.string();
                        break;
                    }
                case 7: {
                        message.electrodeSeparation = $root.ord.Length.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        if (!(message.measurements && message.measurements.length))
                            message.measurements = [];
                        message.measurements.push($root.ord.ElectrochemistryConditions.ElectrochemistryMeasurement.decode(reader, reader.uint32()));
                        break;
                    }
                case 9: {
                        message.cell = $root.ord.ElectrochemistryConditions.ElectrochemistryCell.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ElectrochemistryConditions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.ElectrochemistryConditions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.ElectrochemistryConditions} ElectrochemistryConditions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ElectrochemistryConditions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ElectrochemistryConditions message.
         * @function verify
         * @memberof ord.ElectrochemistryConditions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ElectrochemistryConditions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.details != null && message.hasOwnProperty("details"))
                if (!$util.isString(message.details))
                    return "details: string expected";
            if (message.current != null && message.hasOwnProperty("current")) {
                let error = $root.ord.Current.verify(message.current);
                if (error)
                    return "current." + error;
            }
            if (message.voltage != null && message.hasOwnProperty("voltage")) {
                let error = $root.ord.Voltage.verify(message.voltage);
                if (error)
                    return "voltage." + error;
            }
            if (message.anodeMaterial != null && message.hasOwnProperty("anodeMaterial"))
                if (!$util.isString(message.anodeMaterial))
                    return "anodeMaterial: string expected";
            if (message.cathodeMaterial != null && message.hasOwnProperty("cathodeMaterial"))
                if (!$util.isString(message.cathodeMaterial))
                    return "cathodeMaterial: string expected";
            if (message.electrodeSeparation != null && message.hasOwnProperty("electrodeSeparation")) {
                let error = $root.ord.Length.verify(message.electrodeSeparation);
                if (error)
                    return "electrodeSeparation." + error;
            }
            if (message.measurements != null && message.hasOwnProperty("measurements")) {
                if (!Array.isArray(message.measurements))
                    return "measurements: array expected";
                for (let i = 0; i < message.measurements.length; ++i) {
                    let error = $root.ord.ElectrochemistryConditions.ElectrochemistryMeasurement.verify(message.measurements[i]);
                    if (error)
                        return "measurements." + error;
                }
            }
            if (message.cell != null && message.hasOwnProperty("cell")) {
                let error = $root.ord.ElectrochemistryConditions.ElectrochemistryCell.verify(message.cell);
                if (error)
                    return "cell." + error;
            }
            return null;
        };

        /**
         * Creates an ElectrochemistryConditions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.ElectrochemistryConditions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.ElectrochemistryConditions} ElectrochemistryConditions
         */
        ElectrochemistryConditions.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.ElectrochemistryConditions)
                return object;
            let message = new $root.ord.ElectrochemistryConditions();
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.type = 0;
                break;
            case "CUSTOM":
            case 1:
                message.type = 1;
                break;
            case "CONSTANT_CURRENT":
            case 2:
                message.type = 2;
                break;
            case "CONSTANT_VOLTAGE":
            case 3:
                message.type = 3;
                break;
            }
            if (object.details != null)
                message.details = String(object.details);
            if (object.current != null) {
                if (typeof object.current !== "object")
                    throw TypeError(".ord.ElectrochemistryConditions.current: object expected");
                message.current = $root.ord.Current.fromObject(object.current);
            }
            if (object.voltage != null) {
                if (typeof object.voltage !== "object")
                    throw TypeError(".ord.ElectrochemistryConditions.voltage: object expected");
                message.voltage = $root.ord.Voltage.fromObject(object.voltage);
            }
            if (object.anodeMaterial != null)
                message.anodeMaterial = String(object.anodeMaterial);
            if (object.cathodeMaterial != null)
                message.cathodeMaterial = String(object.cathodeMaterial);
            if (object.electrodeSeparation != null) {
                if (typeof object.electrodeSeparation !== "object")
                    throw TypeError(".ord.ElectrochemistryConditions.electrodeSeparation: object expected");
                message.electrodeSeparation = $root.ord.Length.fromObject(object.electrodeSeparation);
            }
            if (object.measurements) {
                if (!Array.isArray(object.measurements))
                    throw TypeError(".ord.ElectrochemistryConditions.measurements: array expected");
                message.measurements = [];
                for (let i = 0; i < object.measurements.length; ++i) {
                    if (typeof object.measurements[i] !== "object")
                        throw TypeError(".ord.ElectrochemistryConditions.measurements: object expected");
                    message.measurements[i] = $root.ord.ElectrochemistryConditions.ElectrochemistryMeasurement.fromObject(object.measurements[i]);
                }
            }
            if (object.cell != null) {
                if (typeof object.cell !== "object")
                    throw TypeError(".ord.ElectrochemistryConditions.cell: object expected");
                message.cell = $root.ord.ElectrochemistryConditions.ElectrochemistryCell.fromObject(object.cell);
            }
            return message;
        };

        /**
         * Creates a plain object from an ElectrochemistryConditions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.ElectrochemistryConditions
         * @static
         * @param {ord.ElectrochemistryConditions} message ElectrochemistryConditions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ElectrochemistryConditions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.measurements = [];
            if (options.defaults) {
                object.type = options.enums === String ? "UNSPECIFIED" : 0;
                object.details = "";
                object.current = null;
                object.voltage = null;
                object.anodeMaterial = "";
                object.cathodeMaterial = "";
                object.electrodeSeparation = null;
                object.cell = null;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.ord.ElectrochemistryConditions.ElectrochemistryType[message.type] === undefined ? message.type : $root.ord.ElectrochemistryConditions.ElectrochemistryType[message.type] : message.type;
            if (message.details != null && message.hasOwnProperty("details"))
                object.details = message.details;
            if (message.current != null && message.hasOwnProperty("current"))
                object.current = $root.ord.Current.toObject(message.current, options);
            if (message.voltage != null && message.hasOwnProperty("voltage"))
                object.voltage = $root.ord.Voltage.toObject(message.voltage, options);
            if (message.anodeMaterial != null && message.hasOwnProperty("anodeMaterial"))
                object.anodeMaterial = message.anodeMaterial;
            if (message.cathodeMaterial != null && message.hasOwnProperty("cathodeMaterial"))
                object.cathodeMaterial = message.cathodeMaterial;
            if (message.electrodeSeparation != null && message.hasOwnProperty("electrodeSeparation"))
                object.electrodeSeparation = $root.ord.Length.toObject(message.electrodeSeparation, options);
            if (message.measurements && message.measurements.length) {
                object.measurements = [];
                for (let j = 0; j < message.measurements.length; ++j)
                    object.measurements[j] = $root.ord.ElectrochemistryConditions.ElectrochemistryMeasurement.toObject(message.measurements[j], options);
            }
            if (message.cell != null && message.hasOwnProperty("cell"))
                object.cell = $root.ord.ElectrochemistryConditions.ElectrochemistryCell.toObject(message.cell, options);
            return object;
        };

        /**
         * Converts this ElectrochemistryConditions to JSON.
         * @function toJSON
         * @memberof ord.ElectrochemistryConditions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ElectrochemistryConditions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ElectrochemistryConditions
         * @function getTypeUrl
         * @memberof ord.ElectrochemistryConditions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ElectrochemistryConditions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.ElectrochemistryConditions";
        };

        /**
         * ElectrochemistryType enum.
         * @name ord.ElectrochemistryConditions.ElectrochemistryType
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} CUSTOM=1 CUSTOM value
         * @property {number} CONSTANT_CURRENT=2 CONSTANT_CURRENT value
         * @property {number} CONSTANT_VOLTAGE=3 CONSTANT_VOLTAGE value
         */
        ElectrochemistryConditions.ElectrochemistryType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "CUSTOM"] = 1;
            values[valuesById[2] = "CONSTANT_CURRENT"] = 2;
            values[valuesById[3] = "CONSTANT_VOLTAGE"] = 3;
            return values;
        })();

        ElectrochemistryConditions.ElectrochemistryMeasurement = (function() {

            /**
             * Properties of an ElectrochemistryMeasurement.
             * @memberof ord.ElectrochemistryConditions
             * @interface IElectrochemistryMeasurement
             * @property {ord.ITime|null} [time] ElectrochemistryMeasurement time
             * @property {ord.ICurrent|null} [current] ElectrochemistryMeasurement current
             * @property {ord.IVoltage|null} [voltage] ElectrochemistryMeasurement voltage
             */

            /**
             * Constructs a new ElectrochemistryMeasurement.
             * @memberof ord.ElectrochemistryConditions
             * @classdesc Represents an ElectrochemistryMeasurement.
             * @implements IElectrochemistryMeasurement
             * @constructor
             * @param {ord.ElectrochemistryConditions.IElectrochemistryMeasurement=} [properties] Properties to set
             */
            function ElectrochemistryMeasurement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ElectrochemistryMeasurement time.
             * @member {ord.ITime|null|undefined} time
             * @memberof ord.ElectrochemistryConditions.ElectrochemistryMeasurement
             * @instance
             */
            ElectrochemistryMeasurement.prototype.time = null;

            /**
             * ElectrochemistryMeasurement current.
             * @member {ord.ICurrent|null|undefined} current
             * @memberof ord.ElectrochemistryConditions.ElectrochemistryMeasurement
             * @instance
             */
            ElectrochemistryMeasurement.prototype.current = null;

            /**
             * ElectrochemistryMeasurement voltage.
             * @member {ord.IVoltage|null|undefined} voltage
             * @memberof ord.ElectrochemistryConditions.ElectrochemistryMeasurement
             * @instance
             */
            ElectrochemistryMeasurement.prototype.voltage = null;

            /**
             * Creates a new ElectrochemistryMeasurement instance using the specified properties.
             * @function create
             * @memberof ord.ElectrochemistryConditions.ElectrochemistryMeasurement
             * @static
             * @param {ord.ElectrochemistryConditions.IElectrochemistryMeasurement=} [properties] Properties to set
             * @returns {ord.ElectrochemistryConditions.ElectrochemistryMeasurement} ElectrochemistryMeasurement instance
             */
            ElectrochemistryMeasurement.create = function create(properties) {
                return new ElectrochemistryMeasurement(properties);
            };

            /**
             * Encodes the specified ElectrochemistryMeasurement message. Does not implicitly {@link ord.ElectrochemistryConditions.ElectrochemistryMeasurement.verify|verify} messages.
             * @function encode
             * @memberof ord.ElectrochemistryConditions.ElectrochemistryMeasurement
             * @static
             * @param {ord.ElectrochemistryConditions.IElectrochemistryMeasurement} message ElectrochemistryMeasurement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ElectrochemistryMeasurement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    $root.ord.Time.encode(message.time, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.current != null && Object.hasOwnProperty.call(message, "current"))
                    $root.ord.Current.encode(message.current, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.voltage != null && Object.hasOwnProperty.call(message, "voltage"))
                    $root.ord.Voltage.encode(message.voltage, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ElectrochemistryMeasurement message, length delimited. Does not implicitly {@link ord.ElectrochemistryConditions.ElectrochemistryMeasurement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ord.ElectrochemistryConditions.ElectrochemistryMeasurement
             * @static
             * @param {ord.ElectrochemistryConditions.IElectrochemistryMeasurement} message ElectrochemistryMeasurement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ElectrochemistryMeasurement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ElectrochemistryMeasurement message from the specified reader or buffer.
             * @function decode
             * @memberof ord.ElectrochemistryConditions.ElectrochemistryMeasurement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ord.ElectrochemistryConditions.ElectrochemistryMeasurement} ElectrochemistryMeasurement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ElectrochemistryMeasurement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.ElectrochemistryConditions.ElectrochemistryMeasurement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.time = $root.ord.Time.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.current = $root.ord.Current.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.voltage = $root.ord.Voltage.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ElectrochemistryMeasurement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ord.ElectrochemistryConditions.ElectrochemistryMeasurement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ord.ElectrochemistryConditions.ElectrochemistryMeasurement} ElectrochemistryMeasurement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ElectrochemistryMeasurement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ElectrochemistryMeasurement message.
             * @function verify
             * @memberof ord.ElectrochemistryConditions.ElectrochemistryMeasurement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ElectrochemistryMeasurement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.time != null && message.hasOwnProperty("time")) {
                    let error = $root.ord.Time.verify(message.time);
                    if (error)
                        return "time." + error;
                }
                if (message.current != null && message.hasOwnProperty("current")) {
                    let error = $root.ord.Current.verify(message.current);
                    if (error)
                        return "current." + error;
                }
                if (message.voltage != null && message.hasOwnProperty("voltage")) {
                    let error = $root.ord.Voltage.verify(message.voltage);
                    if (error)
                        return "voltage." + error;
                }
                return null;
            };

            /**
             * Creates an ElectrochemistryMeasurement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ord.ElectrochemistryConditions.ElectrochemistryMeasurement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ord.ElectrochemistryConditions.ElectrochemistryMeasurement} ElectrochemistryMeasurement
             */
            ElectrochemistryMeasurement.fromObject = function fromObject(object) {
                if (object instanceof $root.ord.ElectrochemistryConditions.ElectrochemistryMeasurement)
                    return object;
                let message = new $root.ord.ElectrochemistryConditions.ElectrochemistryMeasurement();
                if (object.time != null) {
                    if (typeof object.time !== "object")
                        throw TypeError(".ord.ElectrochemistryConditions.ElectrochemistryMeasurement.time: object expected");
                    message.time = $root.ord.Time.fromObject(object.time);
                }
                if (object.current != null) {
                    if (typeof object.current !== "object")
                        throw TypeError(".ord.ElectrochemistryConditions.ElectrochemistryMeasurement.current: object expected");
                    message.current = $root.ord.Current.fromObject(object.current);
                }
                if (object.voltage != null) {
                    if (typeof object.voltage !== "object")
                        throw TypeError(".ord.ElectrochemistryConditions.ElectrochemistryMeasurement.voltage: object expected");
                    message.voltage = $root.ord.Voltage.fromObject(object.voltage);
                }
                return message;
            };

            /**
             * Creates a plain object from an ElectrochemistryMeasurement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ord.ElectrochemistryConditions.ElectrochemistryMeasurement
             * @static
             * @param {ord.ElectrochemistryConditions.ElectrochemistryMeasurement} message ElectrochemistryMeasurement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ElectrochemistryMeasurement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.time = null;
                    object.current = null;
                    object.voltage = null;
                }
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = $root.ord.Time.toObject(message.time, options);
                if (message.current != null && message.hasOwnProperty("current"))
                    object.current = $root.ord.Current.toObject(message.current, options);
                if (message.voltage != null && message.hasOwnProperty("voltage"))
                    object.voltage = $root.ord.Voltage.toObject(message.voltage, options);
                return object;
            };

            /**
             * Converts this ElectrochemistryMeasurement to JSON.
             * @function toJSON
             * @memberof ord.ElectrochemistryConditions.ElectrochemistryMeasurement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ElectrochemistryMeasurement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ElectrochemistryMeasurement
             * @function getTypeUrl
             * @memberof ord.ElectrochemistryConditions.ElectrochemistryMeasurement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ElectrochemistryMeasurement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/ord.ElectrochemistryConditions.ElectrochemistryMeasurement";
            };

            return ElectrochemistryMeasurement;
        })();

        ElectrochemistryConditions.ElectrochemistryCell = (function() {

            /**
             * Properties of an ElectrochemistryCell.
             * @memberof ord.ElectrochemistryConditions
             * @interface IElectrochemistryCell
             * @property {ord.ElectrochemistryConditions.ElectrochemistryCell.ElectrochemistryCellType|null} [type] ElectrochemistryCell type
             * @property {string|null} [details] ElectrochemistryCell details
             */

            /**
             * Constructs a new ElectrochemistryCell.
             * @memberof ord.ElectrochemistryConditions
             * @classdesc Represents an ElectrochemistryCell.
             * @implements IElectrochemistryCell
             * @constructor
             * @param {ord.ElectrochemistryConditions.IElectrochemistryCell=} [properties] Properties to set
             */
            function ElectrochemistryCell(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ElectrochemistryCell type.
             * @member {ord.ElectrochemistryConditions.ElectrochemistryCell.ElectrochemistryCellType} type
             * @memberof ord.ElectrochemistryConditions.ElectrochemistryCell
             * @instance
             */
            ElectrochemistryCell.prototype.type = 0;

            /**
             * ElectrochemistryCell details.
             * @member {string} details
             * @memberof ord.ElectrochemistryConditions.ElectrochemistryCell
             * @instance
             */
            ElectrochemistryCell.prototype.details = "";

            /**
             * Creates a new ElectrochemistryCell instance using the specified properties.
             * @function create
             * @memberof ord.ElectrochemistryConditions.ElectrochemistryCell
             * @static
             * @param {ord.ElectrochemistryConditions.IElectrochemistryCell=} [properties] Properties to set
             * @returns {ord.ElectrochemistryConditions.ElectrochemistryCell} ElectrochemistryCell instance
             */
            ElectrochemistryCell.create = function create(properties) {
                return new ElectrochemistryCell(properties);
            };

            /**
             * Encodes the specified ElectrochemistryCell message. Does not implicitly {@link ord.ElectrochemistryConditions.ElectrochemistryCell.verify|verify} messages.
             * @function encode
             * @memberof ord.ElectrochemistryConditions.ElectrochemistryCell
             * @static
             * @param {ord.ElectrochemistryConditions.IElectrochemistryCell} message ElectrochemistryCell message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ElectrochemistryCell.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
                return writer;
            };

            /**
             * Encodes the specified ElectrochemistryCell message, length delimited. Does not implicitly {@link ord.ElectrochemistryConditions.ElectrochemistryCell.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ord.ElectrochemistryConditions.ElectrochemistryCell
             * @static
             * @param {ord.ElectrochemistryConditions.IElectrochemistryCell} message ElectrochemistryCell message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ElectrochemistryCell.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ElectrochemistryCell message from the specified reader or buffer.
             * @function decode
             * @memberof ord.ElectrochemistryConditions.ElectrochemistryCell
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ord.ElectrochemistryConditions.ElectrochemistryCell} ElectrochemistryCell
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ElectrochemistryCell.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.ElectrochemistryConditions.ElectrochemistryCell();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.details = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ElectrochemistryCell message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ord.ElectrochemistryConditions.ElectrochemistryCell
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ord.ElectrochemistryConditions.ElectrochemistryCell} ElectrochemistryCell
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ElectrochemistryCell.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ElectrochemistryCell message.
             * @function verify
             * @memberof ord.ElectrochemistryConditions.ElectrochemistryCell
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ElectrochemistryCell.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.details != null && message.hasOwnProperty("details"))
                    if (!$util.isString(message.details))
                        return "details: string expected";
                return null;
            };

            /**
             * Creates an ElectrochemistryCell message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ord.ElectrochemistryConditions.ElectrochemistryCell
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ord.ElectrochemistryConditions.ElectrochemistryCell} ElectrochemistryCell
             */
            ElectrochemistryCell.fromObject = function fromObject(object) {
                if (object instanceof $root.ord.ElectrochemistryConditions.ElectrochemistryCell)
                    return object;
                let message = new $root.ord.ElectrochemistryConditions.ElectrochemistryCell();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "UNSPECIFIED":
                case 0:
                    message.type = 0;
                    break;
                case "CUSTOM":
                case 1:
                    message.type = 1;
                    break;
                case "DIVIDED_CELL":
                case 2:
                    message.type = 2;
                    break;
                case "UNDIVIDED_CELL":
                case 3:
                    message.type = 3;
                    break;
                }
                if (object.details != null)
                    message.details = String(object.details);
                return message;
            };

            /**
             * Creates a plain object from an ElectrochemistryCell message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ord.ElectrochemistryConditions.ElectrochemistryCell
             * @static
             * @param {ord.ElectrochemistryConditions.ElectrochemistryCell} message ElectrochemistryCell
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ElectrochemistryCell.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "UNSPECIFIED" : 0;
                    object.details = "";
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.ord.ElectrochemistryConditions.ElectrochemistryCell.ElectrochemistryCellType[message.type] === undefined ? message.type : $root.ord.ElectrochemistryConditions.ElectrochemistryCell.ElectrochemistryCellType[message.type] : message.type;
                if (message.details != null && message.hasOwnProperty("details"))
                    object.details = message.details;
                return object;
            };

            /**
             * Converts this ElectrochemistryCell to JSON.
             * @function toJSON
             * @memberof ord.ElectrochemistryConditions.ElectrochemistryCell
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ElectrochemistryCell.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ElectrochemistryCell
             * @function getTypeUrl
             * @memberof ord.ElectrochemistryConditions.ElectrochemistryCell
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ElectrochemistryCell.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/ord.ElectrochemistryConditions.ElectrochemistryCell";
            };

            /**
             * ElectrochemistryCellType enum.
             * @name ord.ElectrochemistryConditions.ElectrochemistryCell.ElectrochemistryCellType
             * @enum {number}
             * @property {number} UNSPECIFIED=0 UNSPECIFIED value
             * @property {number} CUSTOM=1 CUSTOM value
             * @property {number} DIVIDED_CELL=2 DIVIDED_CELL value
             * @property {number} UNDIVIDED_CELL=3 UNDIVIDED_CELL value
             */
            ElectrochemistryCell.ElectrochemistryCellType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSPECIFIED"] = 0;
                values[valuesById[1] = "CUSTOM"] = 1;
                values[valuesById[2] = "DIVIDED_CELL"] = 2;
                values[valuesById[3] = "UNDIVIDED_CELL"] = 3;
                return values;
            })();

            return ElectrochemistryCell;
        })();

        return ElectrochemistryConditions;
    })();

    ord.FlowConditions = (function() {

        /**
         * Properties of a FlowConditions.
         * @memberof ord
         * @interface IFlowConditions
         * @property {ord.FlowConditions.FlowType|null} [type] FlowConditions type
         * @property {string|null} [details] FlowConditions details
         * @property {string|null} [pumpType] FlowConditions pumpType
         * @property {ord.FlowConditions.ITubing|null} [tubing] FlowConditions tubing
         */

        /**
         * Constructs a new FlowConditions.
         * @memberof ord
         * @classdesc Represents a FlowConditions.
         * @implements IFlowConditions
         * @constructor
         * @param {ord.IFlowConditions=} [properties] Properties to set
         */
        function FlowConditions(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FlowConditions type.
         * @member {ord.FlowConditions.FlowType} type
         * @memberof ord.FlowConditions
         * @instance
         */
        FlowConditions.prototype.type = 0;

        /**
         * FlowConditions details.
         * @member {string} details
         * @memberof ord.FlowConditions
         * @instance
         */
        FlowConditions.prototype.details = "";

        /**
         * FlowConditions pumpType.
         * @member {string} pumpType
         * @memberof ord.FlowConditions
         * @instance
         */
        FlowConditions.prototype.pumpType = "";

        /**
         * FlowConditions tubing.
         * @member {ord.FlowConditions.ITubing|null|undefined} tubing
         * @memberof ord.FlowConditions
         * @instance
         */
        FlowConditions.prototype.tubing = null;

        /**
         * Creates a new FlowConditions instance using the specified properties.
         * @function create
         * @memberof ord.FlowConditions
         * @static
         * @param {ord.IFlowConditions=} [properties] Properties to set
         * @returns {ord.FlowConditions} FlowConditions instance
         */
        FlowConditions.create = function create(properties) {
            return new FlowConditions(properties);
        };

        /**
         * Encodes the specified FlowConditions message. Does not implicitly {@link ord.FlowConditions.verify|verify} messages.
         * @function encode
         * @memberof ord.FlowConditions
         * @static
         * @param {ord.IFlowConditions} message FlowConditions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FlowConditions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
            if (message.pumpType != null && Object.hasOwnProperty.call(message, "pumpType"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.pumpType);
            if (message.tubing != null && Object.hasOwnProperty.call(message, "tubing"))
                $root.ord.FlowConditions.Tubing.encode(message.tubing, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FlowConditions message, length delimited. Does not implicitly {@link ord.FlowConditions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.FlowConditions
         * @static
         * @param {ord.IFlowConditions} message FlowConditions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FlowConditions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FlowConditions message from the specified reader or buffer.
         * @function decode
         * @memberof ord.FlowConditions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.FlowConditions} FlowConditions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FlowConditions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.FlowConditions();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.details = reader.string();
                        break;
                    }
                case 3: {
                        message.pumpType = reader.string();
                        break;
                    }
                case 4: {
                        message.tubing = $root.ord.FlowConditions.Tubing.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FlowConditions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.FlowConditions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.FlowConditions} FlowConditions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FlowConditions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FlowConditions message.
         * @function verify
         * @memberof ord.FlowConditions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FlowConditions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.details != null && message.hasOwnProperty("details"))
                if (!$util.isString(message.details))
                    return "details: string expected";
            if (message.pumpType != null && message.hasOwnProperty("pumpType"))
                if (!$util.isString(message.pumpType))
                    return "pumpType: string expected";
            if (message.tubing != null && message.hasOwnProperty("tubing")) {
                let error = $root.ord.FlowConditions.Tubing.verify(message.tubing);
                if (error)
                    return "tubing." + error;
            }
            return null;
        };

        /**
         * Creates a FlowConditions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.FlowConditions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.FlowConditions} FlowConditions
         */
        FlowConditions.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.FlowConditions)
                return object;
            let message = new $root.ord.FlowConditions();
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.type = 0;
                break;
            case "CUSTOM":
            case 1:
                message.type = 1;
                break;
            case "PLUG_FLOW_REACTOR":
            case 2:
                message.type = 2;
                break;
            case "CONTINUOUS_STIRRED_TANK_REACTOR":
            case 3:
                message.type = 3;
                break;
            case "PACKED_BED_REACTOR":
            case 4:
                message.type = 4;
                break;
            }
            if (object.details != null)
                message.details = String(object.details);
            if (object.pumpType != null)
                message.pumpType = String(object.pumpType);
            if (object.tubing != null) {
                if (typeof object.tubing !== "object")
                    throw TypeError(".ord.FlowConditions.tubing: object expected");
                message.tubing = $root.ord.FlowConditions.Tubing.fromObject(object.tubing);
            }
            return message;
        };

        /**
         * Creates a plain object from a FlowConditions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.FlowConditions
         * @static
         * @param {ord.FlowConditions} message FlowConditions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FlowConditions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "UNSPECIFIED" : 0;
                object.details = "";
                object.pumpType = "";
                object.tubing = null;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.ord.FlowConditions.FlowType[message.type] === undefined ? message.type : $root.ord.FlowConditions.FlowType[message.type] : message.type;
            if (message.details != null && message.hasOwnProperty("details"))
                object.details = message.details;
            if (message.pumpType != null && message.hasOwnProperty("pumpType"))
                object.pumpType = message.pumpType;
            if (message.tubing != null && message.hasOwnProperty("tubing"))
                object.tubing = $root.ord.FlowConditions.Tubing.toObject(message.tubing, options);
            return object;
        };

        /**
         * Converts this FlowConditions to JSON.
         * @function toJSON
         * @memberof ord.FlowConditions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FlowConditions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for FlowConditions
         * @function getTypeUrl
         * @memberof ord.FlowConditions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FlowConditions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.FlowConditions";
        };

        /**
         * FlowType enum.
         * @name ord.FlowConditions.FlowType
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} CUSTOM=1 CUSTOM value
         * @property {number} PLUG_FLOW_REACTOR=2 PLUG_FLOW_REACTOR value
         * @property {number} CONTINUOUS_STIRRED_TANK_REACTOR=3 CONTINUOUS_STIRRED_TANK_REACTOR value
         * @property {number} PACKED_BED_REACTOR=4 PACKED_BED_REACTOR value
         */
        FlowConditions.FlowType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "CUSTOM"] = 1;
            values[valuesById[2] = "PLUG_FLOW_REACTOR"] = 2;
            values[valuesById[3] = "CONTINUOUS_STIRRED_TANK_REACTOR"] = 3;
            values[valuesById[4] = "PACKED_BED_REACTOR"] = 4;
            return values;
        })();

        FlowConditions.Tubing = (function() {

            /**
             * Properties of a Tubing.
             * @memberof ord.FlowConditions
             * @interface ITubing
             * @property {ord.FlowConditions.Tubing.TubingType|null} [type] Tubing type
             * @property {string|null} [details] Tubing details
             * @property {ord.ILength|null} [diameter] Tubing diameter
             */

            /**
             * Constructs a new Tubing.
             * @memberof ord.FlowConditions
             * @classdesc Represents a Tubing.
             * @implements ITubing
             * @constructor
             * @param {ord.FlowConditions.ITubing=} [properties] Properties to set
             */
            function Tubing(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Tubing type.
             * @member {ord.FlowConditions.Tubing.TubingType} type
             * @memberof ord.FlowConditions.Tubing
             * @instance
             */
            Tubing.prototype.type = 0;

            /**
             * Tubing details.
             * @member {string} details
             * @memberof ord.FlowConditions.Tubing
             * @instance
             */
            Tubing.prototype.details = "";

            /**
             * Tubing diameter.
             * @member {ord.ILength|null|undefined} diameter
             * @memberof ord.FlowConditions.Tubing
             * @instance
             */
            Tubing.prototype.diameter = null;

            /**
             * Creates a new Tubing instance using the specified properties.
             * @function create
             * @memberof ord.FlowConditions.Tubing
             * @static
             * @param {ord.FlowConditions.ITubing=} [properties] Properties to set
             * @returns {ord.FlowConditions.Tubing} Tubing instance
             */
            Tubing.create = function create(properties) {
                return new Tubing(properties);
            };

            /**
             * Encodes the specified Tubing message. Does not implicitly {@link ord.FlowConditions.Tubing.verify|verify} messages.
             * @function encode
             * @memberof ord.FlowConditions.Tubing
             * @static
             * @param {ord.FlowConditions.ITubing} message Tubing message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Tubing.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
                if (message.diameter != null && Object.hasOwnProperty.call(message, "diameter"))
                    $root.ord.Length.encode(message.diameter, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Tubing message, length delimited. Does not implicitly {@link ord.FlowConditions.Tubing.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ord.FlowConditions.Tubing
             * @static
             * @param {ord.FlowConditions.ITubing} message Tubing message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Tubing.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Tubing message from the specified reader or buffer.
             * @function decode
             * @memberof ord.FlowConditions.Tubing
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ord.FlowConditions.Tubing} Tubing
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Tubing.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.FlowConditions.Tubing();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.details = reader.string();
                            break;
                        }
                    case 3: {
                            message.diameter = $root.ord.Length.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Tubing message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ord.FlowConditions.Tubing
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ord.FlowConditions.Tubing} Tubing
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Tubing.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Tubing message.
             * @function verify
             * @memberof ord.FlowConditions.Tubing
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Tubing.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                        break;
                    }
                if (message.details != null && message.hasOwnProperty("details"))
                    if (!$util.isString(message.details))
                        return "details: string expected";
                if (message.diameter != null && message.hasOwnProperty("diameter")) {
                    let error = $root.ord.Length.verify(message.diameter);
                    if (error)
                        return "diameter." + error;
                }
                return null;
            };

            /**
             * Creates a Tubing message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ord.FlowConditions.Tubing
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ord.FlowConditions.Tubing} Tubing
             */
            Tubing.fromObject = function fromObject(object) {
                if (object instanceof $root.ord.FlowConditions.Tubing)
                    return object;
                let message = new $root.ord.FlowConditions.Tubing();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "UNSPECIFIED":
                case 0:
                    message.type = 0;
                    break;
                case "CUSTOM":
                case 1:
                    message.type = 1;
                    break;
                case "STEEL":
                case 2:
                    message.type = 2;
                    break;
                case "COPPER":
                case 3:
                    message.type = 3;
                    break;
                case "PFA":
                case 4:
                    message.type = 4;
                    break;
                case "FEP":
                case 5:
                    message.type = 5;
                    break;
                case "TEFLONAF":
                case 6:
                    message.type = 6;
                    break;
                case "PTFE":
                case 7:
                    message.type = 7;
                    break;
                case "GLASS":
                case 8:
                    message.type = 8;
                    break;
                case "QUARTZ":
                case 9:
                    message.type = 9;
                    break;
                case "SILICON":
                case 10:
                    message.type = 10;
                    break;
                case "PDMS":
                case 11:
                    message.type = 11;
                    break;
                }
                if (object.details != null)
                    message.details = String(object.details);
                if (object.diameter != null) {
                    if (typeof object.diameter !== "object")
                        throw TypeError(".ord.FlowConditions.Tubing.diameter: object expected");
                    message.diameter = $root.ord.Length.fromObject(object.diameter);
                }
                return message;
            };

            /**
             * Creates a plain object from a Tubing message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ord.FlowConditions.Tubing
             * @static
             * @param {ord.FlowConditions.Tubing} message Tubing
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Tubing.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "UNSPECIFIED" : 0;
                    object.details = "";
                    object.diameter = null;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.ord.FlowConditions.Tubing.TubingType[message.type] === undefined ? message.type : $root.ord.FlowConditions.Tubing.TubingType[message.type] : message.type;
                if (message.details != null && message.hasOwnProperty("details"))
                    object.details = message.details;
                if (message.diameter != null && message.hasOwnProperty("diameter"))
                    object.diameter = $root.ord.Length.toObject(message.diameter, options);
                return object;
            };

            /**
             * Converts this Tubing to JSON.
             * @function toJSON
             * @memberof ord.FlowConditions.Tubing
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Tubing.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Tubing
             * @function getTypeUrl
             * @memberof ord.FlowConditions.Tubing
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Tubing.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/ord.FlowConditions.Tubing";
            };

            /**
             * TubingType enum.
             * @name ord.FlowConditions.Tubing.TubingType
             * @enum {number}
             * @property {number} UNSPECIFIED=0 UNSPECIFIED value
             * @property {number} CUSTOM=1 CUSTOM value
             * @property {number} STEEL=2 STEEL value
             * @property {number} COPPER=3 COPPER value
             * @property {number} PFA=4 PFA value
             * @property {number} FEP=5 FEP value
             * @property {number} TEFLONAF=6 TEFLONAF value
             * @property {number} PTFE=7 PTFE value
             * @property {number} GLASS=8 GLASS value
             * @property {number} QUARTZ=9 QUARTZ value
             * @property {number} SILICON=10 SILICON value
             * @property {number} PDMS=11 PDMS value
             */
            Tubing.TubingType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSPECIFIED"] = 0;
                values[valuesById[1] = "CUSTOM"] = 1;
                values[valuesById[2] = "STEEL"] = 2;
                values[valuesById[3] = "COPPER"] = 3;
                values[valuesById[4] = "PFA"] = 4;
                values[valuesById[5] = "FEP"] = 5;
                values[valuesById[6] = "TEFLONAF"] = 6;
                values[valuesById[7] = "PTFE"] = 7;
                values[valuesById[8] = "GLASS"] = 8;
                values[valuesById[9] = "QUARTZ"] = 9;
                values[valuesById[10] = "SILICON"] = 10;
                values[valuesById[11] = "PDMS"] = 11;
                return values;
            })();

            return Tubing;
        })();

        return FlowConditions;
    })();

    ord.ReactionNotes = (function() {

        /**
         * Properties of a ReactionNotes.
         * @memberof ord
         * @interface IReactionNotes
         * @property {boolean|null} [isHeterogeneous] ReactionNotes isHeterogeneous
         * @property {boolean|null} [formsPrecipitate] ReactionNotes formsPrecipitate
         * @property {boolean|null} [isExothermic] ReactionNotes isExothermic
         * @property {boolean|null} [offgasses] ReactionNotes offgasses
         * @property {boolean|null} [isSensitiveToMoisture] ReactionNotes isSensitiveToMoisture
         * @property {boolean|null} [isSensitiveToOxygen] ReactionNotes isSensitiveToOxygen
         * @property {boolean|null} [isSensitiveToLight] ReactionNotes isSensitiveToLight
         * @property {string|null} [safetyNotes] ReactionNotes safetyNotes
         * @property {string|null} [procedureDetails] ReactionNotes procedureDetails
         */

        /**
         * Constructs a new ReactionNotes.
         * @memberof ord
         * @classdesc Represents a ReactionNotes.
         * @implements IReactionNotes
         * @constructor
         * @param {ord.IReactionNotes=} [properties] Properties to set
         */
        function ReactionNotes(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReactionNotes isHeterogeneous.
         * @member {boolean|null|undefined} isHeterogeneous
         * @memberof ord.ReactionNotes
         * @instance
         */
        ReactionNotes.prototype.isHeterogeneous = null;

        /**
         * ReactionNotes formsPrecipitate.
         * @member {boolean|null|undefined} formsPrecipitate
         * @memberof ord.ReactionNotes
         * @instance
         */
        ReactionNotes.prototype.formsPrecipitate = null;

        /**
         * ReactionNotes isExothermic.
         * @member {boolean|null|undefined} isExothermic
         * @memberof ord.ReactionNotes
         * @instance
         */
        ReactionNotes.prototype.isExothermic = null;

        /**
         * ReactionNotes offgasses.
         * @member {boolean|null|undefined} offgasses
         * @memberof ord.ReactionNotes
         * @instance
         */
        ReactionNotes.prototype.offgasses = null;

        /**
         * ReactionNotes isSensitiveToMoisture.
         * @member {boolean|null|undefined} isSensitiveToMoisture
         * @memberof ord.ReactionNotes
         * @instance
         */
        ReactionNotes.prototype.isSensitiveToMoisture = null;

        /**
         * ReactionNotes isSensitiveToOxygen.
         * @member {boolean|null|undefined} isSensitiveToOxygen
         * @memberof ord.ReactionNotes
         * @instance
         */
        ReactionNotes.prototype.isSensitiveToOxygen = null;

        /**
         * ReactionNotes isSensitiveToLight.
         * @member {boolean|null|undefined} isSensitiveToLight
         * @memberof ord.ReactionNotes
         * @instance
         */
        ReactionNotes.prototype.isSensitiveToLight = null;

        /**
         * ReactionNotes safetyNotes.
         * @member {string} safetyNotes
         * @memberof ord.ReactionNotes
         * @instance
         */
        ReactionNotes.prototype.safetyNotes = "";

        /**
         * ReactionNotes procedureDetails.
         * @member {string} procedureDetails
         * @memberof ord.ReactionNotes
         * @instance
         */
        ReactionNotes.prototype.procedureDetails = "";

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(ReactionNotes.prototype, "_isHeterogeneous", {
            get: $util.oneOfGetter($oneOfFields = ["isHeterogeneous"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(ReactionNotes.prototype, "_formsPrecipitate", {
            get: $util.oneOfGetter($oneOfFields = ["formsPrecipitate"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(ReactionNotes.prototype, "_isExothermic", {
            get: $util.oneOfGetter($oneOfFields = ["isExothermic"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(ReactionNotes.prototype, "_offgasses", {
            get: $util.oneOfGetter($oneOfFields = ["offgasses"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(ReactionNotes.prototype, "_isSensitiveToMoisture", {
            get: $util.oneOfGetter($oneOfFields = ["isSensitiveToMoisture"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(ReactionNotes.prototype, "_isSensitiveToOxygen", {
            get: $util.oneOfGetter($oneOfFields = ["isSensitiveToOxygen"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(ReactionNotes.prototype, "_isSensitiveToLight", {
            get: $util.oneOfGetter($oneOfFields = ["isSensitiveToLight"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ReactionNotes instance using the specified properties.
         * @function create
         * @memberof ord.ReactionNotes
         * @static
         * @param {ord.IReactionNotes=} [properties] Properties to set
         * @returns {ord.ReactionNotes} ReactionNotes instance
         */
        ReactionNotes.create = function create(properties) {
            return new ReactionNotes(properties);
        };

        /**
         * Encodes the specified ReactionNotes message. Does not implicitly {@link ord.ReactionNotes.verify|verify} messages.
         * @function encode
         * @memberof ord.ReactionNotes
         * @static
         * @param {ord.IReactionNotes} message ReactionNotes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReactionNotes.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isHeterogeneous != null && Object.hasOwnProperty.call(message, "isHeterogeneous"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isHeterogeneous);
            if (message.formsPrecipitate != null && Object.hasOwnProperty.call(message, "formsPrecipitate"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.formsPrecipitate);
            if (message.isExothermic != null && Object.hasOwnProperty.call(message, "isExothermic"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isExothermic);
            if (message.offgasses != null && Object.hasOwnProperty.call(message, "offgasses"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.offgasses);
            if (message.isSensitiveToMoisture != null && Object.hasOwnProperty.call(message, "isSensitiveToMoisture"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.isSensitiveToMoisture);
            if (message.isSensitiveToOxygen != null && Object.hasOwnProperty.call(message, "isSensitiveToOxygen"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isSensitiveToOxygen);
            if (message.isSensitiveToLight != null && Object.hasOwnProperty.call(message, "isSensitiveToLight"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.isSensitiveToLight);
            if (message.safetyNotes != null && Object.hasOwnProperty.call(message, "safetyNotes"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.safetyNotes);
            if (message.procedureDetails != null && Object.hasOwnProperty.call(message, "procedureDetails"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.procedureDetails);
            return writer;
        };

        /**
         * Encodes the specified ReactionNotes message, length delimited. Does not implicitly {@link ord.ReactionNotes.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.ReactionNotes
         * @static
         * @param {ord.IReactionNotes} message ReactionNotes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReactionNotes.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReactionNotes message from the specified reader or buffer.
         * @function decode
         * @memberof ord.ReactionNotes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.ReactionNotes} ReactionNotes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReactionNotes.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.ReactionNotes();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.isHeterogeneous = reader.bool();
                        break;
                    }
                case 2: {
                        message.formsPrecipitate = reader.bool();
                        break;
                    }
                case 3: {
                        message.isExothermic = reader.bool();
                        break;
                    }
                case 4: {
                        message.offgasses = reader.bool();
                        break;
                    }
                case 5: {
                        message.isSensitiveToMoisture = reader.bool();
                        break;
                    }
                case 6: {
                        message.isSensitiveToOxygen = reader.bool();
                        break;
                    }
                case 7: {
                        message.isSensitiveToLight = reader.bool();
                        break;
                    }
                case 8: {
                        message.safetyNotes = reader.string();
                        break;
                    }
                case 9: {
                        message.procedureDetails = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReactionNotes message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.ReactionNotes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.ReactionNotes} ReactionNotes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReactionNotes.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReactionNotes message.
         * @function verify
         * @memberof ord.ReactionNotes
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReactionNotes.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.isHeterogeneous != null && message.hasOwnProperty("isHeterogeneous")) {
                properties._isHeterogeneous = 1;
                if (typeof message.isHeterogeneous !== "boolean")
                    return "isHeterogeneous: boolean expected";
            }
            if (message.formsPrecipitate != null && message.hasOwnProperty("formsPrecipitate")) {
                properties._formsPrecipitate = 1;
                if (typeof message.formsPrecipitate !== "boolean")
                    return "formsPrecipitate: boolean expected";
            }
            if (message.isExothermic != null && message.hasOwnProperty("isExothermic")) {
                properties._isExothermic = 1;
                if (typeof message.isExothermic !== "boolean")
                    return "isExothermic: boolean expected";
            }
            if (message.offgasses != null && message.hasOwnProperty("offgasses")) {
                properties._offgasses = 1;
                if (typeof message.offgasses !== "boolean")
                    return "offgasses: boolean expected";
            }
            if (message.isSensitiveToMoisture != null && message.hasOwnProperty("isSensitiveToMoisture")) {
                properties._isSensitiveToMoisture = 1;
                if (typeof message.isSensitiveToMoisture !== "boolean")
                    return "isSensitiveToMoisture: boolean expected";
            }
            if (message.isSensitiveToOxygen != null && message.hasOwnProperty("isSensitiveToOxygen")) {
                properties._isSensitiveToOxygen = 1;
                if (typeof message.isSensitiveToOxygen !== "boolean")
                    return "isSensitiveToOxygen: boolean expected";
            }
            if (message.isSensitiveToLight != null && message.hasOwnProperty("isSensitiveToLight")) {
                properties._isSensitiveToLight = 1;
                if (typeof message.isSensitiveToLight !== "boolean")
                    return "isSensitiveToLight: boolean expected";
            }
            if (message.safetyNotes != null && message.hasOwnProperty("safetyNotes"))
                if (!$util.isString(message.safetyNotes))
                    return "safetyNotes: string expected";
            if (message.procedureDetails != null && message.hasOwnProperty("procedureDetails"))
                if (!$util.isString(message.procedureDetails))
                    return "procedureDetails: string expected";
            return null;
        };

        /**
         * Creates a ReactionNotes message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.ReactionNotes
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.ReactionNotes} ReactionNotes
         */
        ReactionNotes.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.ReactionNotes)
                return object;
            let message = new $root.ord.ReactionNotes();
            if (object.isHeterogeneous != null)
                message.isHeterogeneous = Boolean(object.isHeterogeneous);
            if (object.formsPrecipitate != null)
                message.formsPrecipitate = Boolean(object.formsPrecipitate);
            if (object.isExothermic != null)
                message.isExothermic = Boolean(object.isExothermic);
            if (object.offgasses != null)
                message.offgasses = Boolean(object.offgasses);
            if (object.isSensitiveToMoisture != null)
                message.isSensitiveToMoisture = Boolean(object.isSensitiveToMoisture);
            if (object.isSensitiveToOxygen != null)
                message.isSensitiveToOxygen = Boolean(object.isSensitiveToOxygen);
            if (object.isSensitiveToLight != null)
                message.isSensitiveToLight = Boolean(object.isSensitiveToLight);
            if (object.safetyNotes != null)
                message.safetyNotes = String(object.safetyNotes);
            if (object.procedureDetails != null)
                message.procedureDetails = String(object.procedureDetails);
            return message;
        };

        /**
         * Creates a plain object from a ReactionNotes message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.ReactionNotes
         * @static
         * @param {ord.ReactionNotes} message ReactionNotes
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReactionNotes.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.safetyNotes = "";
                object.procedureDetails = "";
            }
            if (message.isHeterogeneous != null && message.hasOwnProperty("isHeterogeneous")) {
                object.isHeterogeneous = message.isHeterogeneous;
                if (options.oneofs)
                    object._isHeterogeneous = "isHeterogeneous";
            }
            if (message.formsPrecipitate != null && message.hasOwnProperty("formsPrecipitate")) {
                object.formsPrecipitate = message.formsPrecipitate;
                if (options.oneofs)
                    object._formsPrecipitate = "formsPrecipitate";
            }
            if (message.isExothermic != null && message.hasOwnProperty("isExothermic")) {
                object.isExothermic = message.isExothermic;
                if (options.oneofs)
                    object._isExothermic = "isExothermic";
            }
            if (message.offgasses != null && message.hasOwnProperty("offgasses")) {
                object.offgasses = message.offgasses;
                if (options.oneofs)
                    object._offgasses = "offgasses";
            }
            if (message.isSensitiveToMoisture != null && message.hasOwnProperty("isSensitiveToMoisture")) {
                object.isSensitiveToMoisture = message.isSensitiveToMoisture;
                if (options.oneofs)
                    object._isSensitiveToMoisture = "isSensitiveToMoisture";
            }
            if (message.isSensitiveToOxygen != null && message.hasOwnProperty("isSensitiveToOxygen")) {
                object.isSensitiveToOxygen = message.isSensitiveToOxygen;
                if (options.oneofs)
                    object._isSensitiveToOxygen = "isSensitiveToOxygen";
            }
            if (message.isSensitiveToLight != null && message.hasOwnProperty("isSensitiveToLight")) {
                object.isSensitiveToLight = message.isSensitiveToLight;
                if (options.oneofs)
                    object._isSensitiveToLight = "isSensitiveToLight";
            }
            if (message.safetyNotes != null && message.hasOwnProperty("safetyNotes"))
                object.safetyNotes = message.safetyNotes;
            if (message.procedureDetails != null && message.hasOwnProperty("procedureDetails"))
                object.procedureDetails = message.procedureDetails;
            return object;
        };

        /**
         * Converts this ReactionNotes to JSON.
         * @function toJSON
         * @memberof ord.ReactionNotes
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReactionNotes.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ReactionNotes
         * @function getTypeUrl
         * @memberof ord.ReactionNotes
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ReactionNotes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.ReactionNotes";
        };

        return ReactionNotes;
    })();

    ord.ReactionObservation = (function() {

        /**
         * Properties of a ReactionObservation.
         * @memberof ord
         * @interface IReactionObservation
         * @property {ord.ITime|null} [time] ReactionObservation time
         * @property {string|null} [comment] ReactionObservation comment
         * @property {ord.IData|null} [image] ReactionObservation image
         */

        /**
         * Constructs a new ReactionObservation.
         * @memberof ord
         * @classdesc Represents a ReactionObservation.
         * @implements IReactionObservation
         * @constructor
         * @param {ord.IReactionObservation=} [properties] Properties to set
         */
        function ReactionObservation(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReactionObservation time.
         * @member {ord.ITime|null|undefined} time
         * @memberof ord.ReactionObservation
         * @instance
         */
        ReactionObservation.prototype.time = null;

        /**
         * ReactionObservation comment.
         * @member {string} comment
         * @memberof ord.ReactionObservation
         * @instance
         */
        ReactionObservation.prototype.comment = "";

        /**
         * ReactionObservation image.
         * @member {ord.IData|null|undefined} image
         * @memberof ord.ReactionObservation
         * @instance
         */
        ReactionObservation.prototype.image = null;

        /**
         * Creates a new ReactionObservation instance using the specified properties.
         * @function create
         * @memberof ord.ReactionObservation
         * @static
         * @param {ord.IReactionObservation=} [properties] Properties to set
         * @returns {ord.ReactionObservation} ReactionObservation instance
         */
        ReactionObservation.create = function create(properties) {
            return new ReactionObservation(properties);
        };

        /**
         * Encodes the specified ReactionObservation message. Does not implicitly {@link ord.ReactionObservation.verify|verify} messages.
         * @function encode
         * @memberof ord.ReactionObservation
         * @static
         * @param {ord.IReactionObservation} message ReactionObservation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReactionObservation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                $root.ord.Time.encode(message.time, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.comment != null && Object.hasOwnProperty.call(message, "comment"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.comment);
            if (message.image != null && Object.hasOwnProperty.call(message, "image"))
                $root.ord.Data.encode(message.image, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ReactionObservation message, length delimited. Does not implicitly {@link ord.ReactionObservation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.ReactionObservation
         * @static
         * @param {ord.IReactionObservation} message ReactionObservation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReactionObservation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReactionObservation message from the specified reader or buffer.
         * @function decode
         * @memberof ord.ReactionObservation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.ReactionObservation} ReactionObservation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReactionObservation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.ReactionObservation();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.time = $root.ord.Time.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.comment = reader.string();
                        break;
                    }
                case 3: {
                        message.image = $root.ord.Data.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReactionObservation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.ReactionObservation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.ReactionObservation} ReactionObservation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReactionObservation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReactionObservation message.
         * @function verify
         * @memberof ord.ReactionObservation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReactionObservation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.time != null && message.hasOwnProperty("time")) {
                let error = $root.ord.Time.verify(message.time);
                if (error)
                    return "time." + error;
            }
            if (message.comment != null && message.hasOwnProperty("comment"))
                if (!$util.isString(message.comment))
                    return "comment: string expected";
            if (message.image != null && message.hasOwnProperty("image")) {
                let error = $root.ord.Data.verify(message.image);
                if (error)
                    return "image." + error;
            }
            return null;
        };

        /**
         * Creates a ReactionObservation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.ReactionObservation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.ReactionObservation} ReactionObservation
         */
        ReactionObservation.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.ReactionObservation)
                return object;
            let message = new $root.ord.ReactionObservation();
            if (object.time != null) {
                if (typeof object.time !== "object")
                    throw TypeError(".ord.ReactionObservation.time: object expected");
                message.time = $root.ord.Time.fromObject(object.time);
            }
            if (object.comment != null)
                message.comment = String(object.comment);
            if (object.image != null) {
                if (typeof object.image !== "object")
                    throw TypeError(".ord.ReactionObservation.image: object expected");
                message.image = $root.ord.Data.fromObject(object.image);
            }
            return message;
        };

        /**
         * Creates a plain object from a ReactionObservation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.ReactionObservation
         * @static
         * @param {ord.ReactionObservation} message ReactionObservation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReactionObservation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.time = null;
                object.comment = "";
                object.image = null;
            }
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = $root.ord.Time.toObject(message.time, options);
            if (message.comment != null && message.hasOwnProperty("comment"))
                object.comment = message.comment;
            if (message.image != null && message.hasOwnProperty("image"))
                object.image = $root.ord.Data.toObject(message.image, options);
            return object;
        };

        /**
         * Converts this ReactionObservation to JSON.
         * @function toJSON
         * @memberof ord.ReactionObservation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReactionObservation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ReactionObservation
         * @function getTypeUrl
         * @memberof ord.ReactionObservation
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ReactionObservation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.ReactionObservation";
        };

        return ReactionObservation;
    })();

    ord.ReactionWorkup = (function() {

        /**
         * Properties of a ReactionWorkup.
         * @memberof ord
         * @interface IReactionWorkup
         * @property {ord.ReactionWorkup.ReactionWorkupType|null} [type] ReactionWorkup type
         * @property {string|null} [details] ReactionWorkup details
         * @property {ord.ITime|null} [duration] ReactionWorkup duration
         * @property {ord.IReactionInput|null} [input] ReactionWorkup input
         * @property {ord.IAmount|null} [amount] ReactionWorkup amount
         * @property {ord.ITemperatureConditions|null} [temperature] ReactionWorkup temperature
         * @property {string|null} [keepPhase] ReactionWorkup keepPhase
         * @property {ord.IStirringConditions|null} [stirring] ReactionWorkup stirring
         * @property {number|null} [targetPh] ReactionWorkup targetPh
         * @property {boolean|null} [isAutomated] ReactionWorkup isAutomated
         */

        /**
         * Constructs a new ReactionWorkup.
         * @memberof ord
         * @classdesc Represents a ReactionWorkup.
         * @implements IReactionWorkup
         * @constructor
         * @param {ord.IReactionWorkup=} [properties] Properties to set
         */
        function ReactionWorkup(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReactionWorkup type.
         * @member {ord.ReactionWorkup.ReactionWorkupType} type
         * @memberof ord.ReactionWorkup
         * @instance
         */
        ReactionWorkup.prototype.type = 0;

        /**
         * ReactionWorkup details.
         * @member {string} details
         * @memberof ord.ReactionWorkup
         * @instance
         */
        ReactionWorkup.prototype.details = "";

        /**
         * ReactionWorkup duration.
         * @member {ord.ITime|null|undefined} duration
         * @memberof ord.ReactionWorkup
         * @instance
         */
        ReactionWorkup.prototype.duration = null;

        /**
         * ReactionWorkup input.
         * @member {ord.IReactionInput|null|undefined} input
         * @memberof ord.ReactionWorkup
         * @instance
         */
        ReactionWorkup.prototype.input = null;

        /**
         * ReactionWorkup amount.
         * @member {ord.IAmount|null|undefined} amount
         * @memberof ord.ReactionWorkup
         * @instance
         */
        ReactionWorkup.prototype.amount = null;

        /**
         * ReactionWorkup temperature.
         * @member {ord.ITemperatureConditions|null|undefined} temperature
         * @memberof ord.ReactionWorkup
         * @instance
         */
        ReactionWorkup.prototype.temperature = null;

        /**
         * ReactionWorkup keepPhase.
         * @member {string} keepPhase
         * @memberof ord.ReactionWorkup
         * @instance
         */
        ReactionWorkup.prototype.keepPhase = "";

        /**
         * ReactionWorkup stirring.
         * @member {ord.IStirringConditions|null|undefined} stirring
         * @memberof ord.ReactionWorkup
         * @instance
         */
        ReactionWorkup.prototype.stirring = null;

        /**
         * ReactionWorkup targetPh.
         * @member {number|null|undefined} targetPh
         * @memberof ord.ReactionWorkup
         * @instance
         */
        ReactionWorkup.prototype.targetPh = null;

        /**
         * ReactionWorkup isAutomated.
         * @member {boolean|null|undefined} isAutomated
         * @memberof ord.ReactionWorkup
         * @instance
         */
        ReactionWorkup.prototype.isAutomated = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(ReactionWorkup.prototype, "_targetPh", {
            get: $util.oneOfGetter($oneOfFields = ["targetPh"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(ReactionWorkup.prototype, "_isAutomated", {
            get: $util.oneOfGetter($oneOfFields = ["isAutomated"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ReactionWorkup instance using the specified properties.
         * @function create
         * @memberof ord.ReactionWorkup
         * @static
         * @param {ord.IReactionWorkup=} [properties] Properties to set
         * @returns {ord.ReactionWorkup} ReactionWorkup instance
         */
        ReactionWorkup.create = function create(properties) {
            return new ReactionWorkup(properties);
        };

        /**
         * Encodes the specified ReactionWorkup message. Does not implicitly {@link ord.ReactionWorkup.verify|verify} messages.
         * @function encode
         * @memberof ord.ReactionWorkup
         * @static
         * @param {ord.IReactionWorkup} message ReactionWorkup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReactionWorkup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                $root.ord.Time.encode(message.duration, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.input != null && Object.hasOwnProperty.call(message, "input"))
                $root.ord.ReactionInput.encode(message.input, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                $root.ord.Amount.encode(message.amount, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.temperature != null && Object.hasOwnProperty.call(message, "temperature"))
                $root.ord.TemperatureConditions.encode(message.temperature, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.keepPhase != null && Object.hasOwnProperty.call(message, "keepPhase"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.keepPhase);
            if (message.stirring != null && Object.hasOwnProperty.call(message, "stirring"))
                $root.ord.StirringConditions.encode(message.stirring, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.targetPh != null && Object.hasOwnProperty.call(message, "targetPh"))
                writer.uint32(/* id 9, wireType 5 =*/77).float(message.targetPh);
            if (message.isAutomated != null && Object.hasOwnProperty.call(message, "isAutomated"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.isAutomated);
            return writer;
        };

        /**
         * Encodes the specified ReactionWorkup message, length delimited. Does not implicitly {@link ord.ReactionWorkup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.ReactionWorkup
         * @static
         * @param {ord.IReactionWorkup} message ReactionWorkup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReactionWorkup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReactionWorkup message from the specified reader or buffer.
         * @function decode
         * @memberof ord.ReactionWorkup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.ReactionWorkup} ReactionWorkup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReactionWorkup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.ReactionWorkup();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.details = reader.string();
                        break;
                    }
                case 3: {
                        message.duration = $root.ord.Time.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.input = $root.ord.ReactionInput.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.amount = $root.ord.Amount.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.temperature = $root.ord.TemperatureConditions.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.keepPhase = reader.string();
                        break;
                    }
                case 8: {
                        message.stirring = $root.ord.StirringConditions.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.targetPh = reader.float();
                        break;
                    }
                case 10: {
                        message.isAutomated = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReactionWorkup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.ReactionWorkup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.ReactionWorkup} ReactionWorkup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReactionWorkup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReactionWorkup message.
         * @function verify
         * @memberof ord.ReactionWorkup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReactionWorkup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                    break;
                }
            if (message.details != null && message.hasOwnProperty("details"))
                if (!$util.isString(message.details))
                    return "details: string expected";
            if (message.duration != null && message.hasOwnProperty("duration")) {
                let error = $root.ord.Time.verify(message.duration);
                if (error)
                    return "duration." + error;
            }
            if (message.input != null && message.hasOwnProperty("input")) {
                let error = $root.ord.ReactionInput.verify(message.input);
                if (error)
                    return "input." + error;
            }
            if (message.amount != null && message.hasOwnProperty("amount")) {
                let error = $root.ord.Amount.verify(message.amount);
                if (error)
                    return "amount." + error;
            }
            if (message.temperature != null && message.hasOwnProperty("temperature")) {
                let error = $root.ord.TemperatureConditions.verify(message.temperature);
                if (error)
                    return "temperature." + error;
            }
            if (message.keepPhase != null && message.hasOwnProperty("keepPhase"))
                if (!$util.isString(message.keepPhase))
                    return "keepPhase: string expected";
            if (message.stirring != null && message.hasOwnProperty("stirring")) {
                let error = $root.ord.StirringConditions.verify(message.stirring);
                if (error)
                    return "stirring." + error;
            }
            if (message.targetPh != null && message.hasOwnProperty("targetPh")) {
                properties._targetPh = 1;
                if (typeof message.targetPh !== "number")
                    return "targetPh: number expected";
            }
            if (message.isAutomated != null && message.hasOwnProperty("isAutomated")) {
                properties._isAutomated = 1;
                if (typeof message.isAutomated !== "boolean")
                    return "isAutomated: boolean expected";
            }
            return null;
        };

        /**
         * Creates a ReactionWorkup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.ReactionWorkup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.ReactionWorkup} ReactionWorkup
         */
        ReactionWorkup.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.ReactionWorkup)
                return object;
            let message = new $root.ord.ReactionWorkup();
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.type = 0;
                break;
            case "CUSTOM":
            case 1:
                message.type = 1;
                break;
            case "ADDITION":
            case 2:
                message.type = 2;
                break;
            case "ALIQUOT":
            case 3:
                message.type = 3;
                break;
            case "TEMPERATURE":
            case 4:
                message.type = 4;
                break;
            case "CONCENTRATION":
            case 5:
                message.type = 5;
                break;
            case "EXTRACTION":
            case 6:
                message.type = 6;
                break;
            case "FILTRATION":
            case 7:
                message.type = 7;
                break;
            case "WASH":
            case 8:
                message.type = 8;
                break;
            case "DRY_IN_VACUUM":
            case 9:
                message.type = 9;
                break;
            case "DRY_WITH_MATERIAL":
            case 10:
                message.type = 10;
                break;
            case "FLASH_CHROMATOGRAPHY":
            case 11:
                message.type = 11;
                break;
            case "OTHER_CHROMATOGRAPHY":
            case 12:
                message.type = 12;
                break;
            case "SCAVENGING":
            case 13:
                message.type = 13;
                break;
            case "WAIT":
            case 14:
                message.type = 14;
                break;
            case "STIRRING":
            case 15:
                message.type = 15;
                break;
            case "PH_ADJUST":
            case 16:
                message.type = 16;
                break;
            case "DISSOLUTION":
            case 17:
                message.type = 17;
                break;
            case "DISTILLATION":
            case 18:
                message.type = 18;
                break;
            }
            if (object.details != null)
                message.details = String(object.details);
            if (object.duration != null) {
                if (typeof object.duration !== "object")
                    throw TypeError(".ord.ReactionWorkup.duration: object expected");
                message.duration = $root.ord.Time.fromObject(object.duration);
            }
            if (object.input != null) {
                if (typeof object.input !== "object")
                    throw TypeError(".ord.ReactionWorkup.input: object expected");
                message.input = $root.ord.ReactionInput.fromObject(object.input);
            }
            if (object.amount != null) {
                if (typeof object.amount !== "object")
                    throw TypeError(".ord.ReactionWorkup.amount: object expected");
                message.amount = $root.ord.Amount.fromObject(object.amount);
            }
            if (object.temperature != null) {
                if (typeof object.temperature !== "object")
                    throw TypeError(".ord.ReactionWorkup.temperature: object expected");
                message.temperature = $root.ord.TemperatureConditions.fromObject(object.temperature);
            }
            if (object.keepPhase != null)
                message.keepPhase = String(object.keepPhase);
            if (object.stirring != null) {
                if (typeof object.stirring !== "object")
                    throw TypeError(".ord.ReactionWorkup.stirring: object expected");
                message.stirring = $root.ord.StirringConditions.fromObject(object.stirring);
            }
            if (object.targetPh != null)
                message.targetPh = Number(object.targetPh);
            if (object.isAutomated != null)
                message.isAutomated = Boolean(object.isAutomated);
            return message;
        };

        /**
         * Creates a plain object from a ReactionWorkup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.ReactionWorkup
         * @static
         * @param {ord.ReactionWorkup} message ReactionWorkup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReactionWorkup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "UNSPECIFIED" : 0;
                object.details = "";
                object.duration = null;
                object.input = null;
                object.amount = null;
                object.temperature = null;
                object.keepPhase = "";
                object.stirring = null;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.ord.ReactionWorkup.ReactionWorkupType[message.type] === undefined ? message.type : $root.ord.ReactionWorkup.ReactionWorkupType[message.type] : message.type;
            if (message.details != null && message.hasOwnProperty("details"))
                object.details = message.details;
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = $root.ord.Time.toObject(message.duration, options);
            if (message.input != null && message.hasOwnProperty("input"))
                object.input = $root.ord.ReactionInput.toObject(message.input, options);
            if (message.amount != null && message.hasOwnProperty("amount"))
                object.amount = $root.ord.Amount.toObject(message.amount, options);
            if (message.temperature != null && message.hasOwnProperty("temperature"))
                object.temperature = $root.ord.TemperatureConditions.toObject(message.temperature, options);
            if (message.keepPhase != null && message.hasOwnProperty("keepPhase"))
                object.keepPhase = message.keepPhase;
            if (message.stirring != null && message.hasOwnProperty("stirring"))
                object.stirring = $root.ord.StirringConditions.toObject(message.stirring, options);
            if (message.targetPh != null && message.hasOwnProperty("targetPh")) {
                object.targetPh = options.json && !isFinite(message.targetPh) ? String(message.targetPh) : message.targetPh;
                if (options.oneofs)
                    object._targetPh = "targetPh";
            }
            if (message.isAutomated != null && message.hasOwnProperty("isAutomated")) {
                object.isAutomated = message.isAutomated;
                if (options.oneofs)
                    object._isAutomated = "isAutomated";
            }
            return object;
        };

        /**
         * Converts this ReactionWorkup to JSON.
         * @function toJSON
         * @memberof ord.ReactionWorkup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReactionWorkup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ReactionWorkup
         * @function getTypeUrl
         * @memberof ord.ReactionWorkup
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ReactionWorkup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.ReactionWorkup";
        };

        /**
         * ReactionWorkupType enum.
         * @name ord.ReactionWorkup.ReactionWorkupType
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} CUSTOM=1 CUSTOM value
         * @property {number} ADDITION=2 ADDITION value
         * @property {number} ALIQUOT=3 ALIQUOT value
         * @property {number} TEMPERATURE=4 TEMPERATURE value
         * @property {number} CONCENTRATION=5 CONCENTRATION value
         * @property {number} EXTRACTION=6 EXTRACTION value
         * @property {number} FILTRATION=7 FILTRATION value
         * @property {number} WASH=8 WASH value
         * @property {number} DRY_IN_VACUUM=9 DRY_IN_VACUUM value
         * @property {number} DRY_WITH_MATERIAL=10 DRY_WITH_MATERIAL value
         * @property {number} FLASH_CHROMATOGRAPHY=11 FLASH_CHROMATOGRAPHY value
         * @property {number} OTHER_CHROMATOGRAPHY=12 OTHER_CHROMATOGRAPHY value
         * @property {number} SCAVENGING=13 SCAVENGING value
         * @property {number} WAIT=14 WAIT value
         * @property {number} STIRRING=15 STIRRING value
         * @property {number} PH_ADJUST=16 PH_ADJUST value
         * @property {number} DISSOLUTION=17 DISSOLUTION value
         * @property {number} DISTILLATION=18 DISTILLATION value
         */
        ReactionWorkup.ReactionWorkupType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "CUSTOM"] = 1;
            values[valuesById[2] = "ADDITION"] = 2;
            values[valuesById[3] = "ALIQUOT"] = 3;
            values[valuesById[4] = "TEMPERATURE"] = 4;
            values[valuesById[5] = "CONCENTRATION"] = 5;
            values[valuesById[6] = "EXTRACTION"] = 6;
            values[valuesById[7] = "FILTRATION"] = 7;
            values[valuesById[8] = "WASH"] = 8;
            values[valuesById[9] = "DRY_IN_VACUUM"] = 9;
            values[valuesById[10] = "DRY_WITH_MATERIAL"] = 10;
            values[valuesById[11] = "FLASH_CHROMATOGRAPHY"] = 11;
            values[valuesById[12] = "OTHER_CHROMATOGRAPHY"] = 12;
            values[valuesById[13] = "SCAVENGING"] = 13;
            values[valuesById[14] = "WAIT"] = 14;
            values[valuesById[15] = "STIRRING"] = 15;
            values[valuesById[16] = "PH_ADJUST"] = 16;
            values[valuesById[17] = "DISSOLUTION"] = 17;
            values[valuesById[18] = "DISTILLATION"] = 18;
            return values;
        })();

        return ReactionWorkup;
    })();

    ord.ReactionOutcome = (function() {

        /**
         * Properties of a ReactionOutcome.
         * @memberof ord
         * @interface IReactionOutcome
         * @property {ord.ITime|null} [reactionTime] ReactionOutcome reactionTime
         * @property {ord.IPercentage|null} [conversion] ReactionOutcome conversion
         * @property {Array.<ord.IProductCompound>|null} [products] ReactionOutcome products
         * @property {Object.<string,ord.IAnalysis>|null} [analyses] ReactionOutcome analyses
         */

        /**
         * Constructs a new ReactionOutcome.
         * @memberof ord
         * @classdesc The outcomes of a reaction describe the conversion, yield, and/or other
         * analyses of the resulting product mixture after workup step(s). Each
         * outcome is associated with a reaction/residence time. To allow for
         * one Reaction message to contain the results of a full kinetic profiling
         * experiment, this is a repeated field of the Reaction message.
         * 
         * It is the parent message for product characterization and any analytical
         * data.
         * @implements IReactionOutcome
         * @constructor
         * @param {ord.IReactionOutcome=} [properties] Properties to set
         */
        function ReactionOutcome(properties) {
            this.products = [];
            this.analyses = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReactionOutcome reactionTime.
         * @member {ord.ITime|null|undefined} reactionTime
         * @memberof ord.ReactionOutcome
         * @instance
         */
        ReactionOutcome.prototype.reactionTime = null;

        /**
         * ReactionOutcome conversion.
         * @member {ord.IPercentage|null|undefined} conversion
         * @memberof ord.ReactionOutcome
         * @instance
         */
        ReactionOutcome.prototype.conversion = null;

        /**
         * ReactionOutcome products.
         * @member {Array.<ord.IProductCompound>} products
         * @memberof ord.ReactionOutcome
         * @instance
         */
        ReactionOutcome.prototype.products = $util.emptyArray;

        /**
         * ReactionOutcome analyses.
         * @member {Object.<string,ord.IAnalysis>} analyses
         * @memberof ord.ReactionOutcome
         * @instance
         */
        ReactionOutcome.prototype.analyses = $util.emptyObject;

        /**
         * Creates a new ReactionOutcome instance using the specified properties.
         * @function create
         * @memberof ord.ReactionOutcome
         * @static
         * @param {ord.IReactionOutcome=} [properties] Properties to set
         * @returns {ord.ReactionOutcome} ReactionOutcome instance
         */
        ReactionOutcome.create = function create(properties) {
            return new ReactionOutcome(properties);
        };

        /**
         * Encodes the specified ReactionOutcome message. Does not implicitly {@link ord.ReactionOutcome.verify|verify} messages.
         * @function encode
         * @memberof ord.ReactionOutcome
         * @static
         * @param {ord.IReactionOutcome} message ReactionOutcome message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReactionOutcome.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reactionTime != null && Object.hasOwnProperty.call(message, "reactionTime"))
                $root.ord.Time.encode(message.reactionTime, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.conversion != null && Object.hasOwnProperty.call(message, "conversion"))
                $root.ord.Percentage.encode(message.conversion, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.products != null && message.products.length)
                for (let i = 0; i < message.products.length; ++i)
                    $root.ord.ProductCompound.encode(message.products[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.analyses != null && Object.hasOwnProperty.call(message, "analyses"))
                for (let keys = Object.keys(message.analyses), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.ord.Analysis.encode(message.analyses[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified ReactionOutcome message, length delimited. Does not implicitly {@link ord.ReactionOutcome.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.ReactionOutcome
         * @static
         * @param {ord.IReactionOutcome} message ReactionOutcome message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReactionOutcome.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReactionOutcome message from the specified reader or buffer.
         * @function decode
         * @memberof ord.ReactionOutcome
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.ReactionOutcome} ReactionOutcome
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReactionOutcome.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.ReactionOutcome(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.reactionTime = $root.ord.Time.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.conversion = $root.ord.Percentage.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        if (!(message.products && message.products.length))
                            message.products = [];
                        message.products.push($root.ord.ProductCompound.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        if (message.analyses === $util.emptyObject)
                            message.analyses = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.ord.Analysis.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.analyses[key] = value;
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReactionOutcome message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.ReactionOutcome
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.ReactionOutcome} ReactionOutcome
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReactionOutcome.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReactionOutcome message.
         * @function verify
         * @memberof ord.ReactionOutcome
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReactionOutcome.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reactionTime != null && message.hasOwnProperty("reactionTime")) {
                let error = $root.ord.Time.verify(message.reactionTime);
                if (error)
                    return "reactionTime." + error;
            }
            if (message.conversion != null && message.hasOwnProperty("conversion")) {
                let error = $root.ord.Percentage.verify(message.conversion);
                if (error)
                    return "conversion." + error;
            }
            if (message.products != null && message.hasOwnProperty("products")) {
                if (!Array.isArray(message.products))
                    return "products: array expected";
                for (let i = 0; i < message.products.length; ++i) {
                    let error = $root.ord.ProductCompound.verify(message.products[i]);
                    if (error)
                        return "products." + error;
                }
            }
            if (message.analyses != null && message.hasOwnProperty("analyses")) {
                if (!$util.isObject(message.analyses))
                    return "analyses: object expected";
                let key = Object.keys(message.analyses);
                for (let i = 0; i < key.length; ++i) {
                    let error = $root.ord.Analysis.verify(message.analyses[key[i]]);
                    if (error)
                        return "analyses." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ReactionOutcome message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.ReactionOutcome
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.ReactionOutcome} ReactionOutcome
         */
        ReactionOutcome.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.ReactionOutcome)
                return object;
            let message = new $root.ord.ReactionOutcome();
            if (object.reactionTime != null) {
                if (typeof object.reactionTime !== "object")
                    throw TypeError(".ord.ReactionOutcome.reactionTime: object expected");
                message.reactionTime = $root.ord.Time.fromObject(object.reactionTime);
            }
            if (object.conversion != null) {
                if (typeof object.conversion !== "object")
                    throw TypeError(".ord.ReactionOutcome.conversion: object expected");
                message.conversion = $root.ord.Percentage.fromObject(object.conversion);
            }
            if (object.products) {
                if (!Array.isArray(object.products))
                    throw TypeError(".ord.ReactionOutcome.products: array expected");
                message.products = [];
                for (let i = 0; i < object.products.length; ++i) {
                    if (typeof object.products[i] !== "object")
                        throw TypeError(".ord.ReactionOutcome.products: object expected");
                    message.products[i] = $root.ord.ProductCompound.fromObject(object.products[i]);
                }
            }
            if (object.analyses) {
                if (typeof object.analyses !== "object")
                    throw TypeError(".ord.ReactionOutcome.analyses: object expected");
                message.analyses = {};
                for (let keys = Object.keys(object.analyses), i = 0; i < keys.length; ++i) {
                    if (typeof object.analyses[keys[i]] !== "object")
                        throw TypeError(".ord.ReactionOutcome.analyses: object expected");
                    message.analyses[keys[i]] = $root.ord.Analysis.fromObject(object.analyses[keys[i]]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ReactionOutcome message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.ReactionOutcome
         * @static
         * @param {ord.ReactionOutcome} message ReactionOutcome
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReactionOutcome.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.products = [];
            if (options.objects || options.defaults)
                object.analyses = {};
            if (options.defaults) {
                object.reactionTime = null;
                object.conversion = null;
            }
            if (message.reactionTime != null && message.hasOwnProperty("reactionTime"))
                object.reactionTime = $root.ord.Time.toObject(message.reactionTime, options);
            if (message.conversion != null && message.hasOwnProperty("conversion"))
                object.conversion = $root.ord.Percentage.toObject(message.conversion, options);
            if (message.products && message.products.length) {
                object.products = [];
                for (let j = 0; j < message.products.length; ++j)
                    object.products[j] = $root.ord.ProductCompound.toObject(message.products[j], options);
            }
            let keys2;
            if (message.analyses && (keys2 = Object.keys(message.analyses)).length) {
                object.analyses = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.analyses[keys2[j]] = $root.ord.Analysis.toObject(message.analyses[keys2[j]], options);
            }
            return object;
        };

        /**
         * Converts this ReactionOutcome to JSON.
         * @function toJSON
         * @memberof ord.ReactionOutcome
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReactionOutcome.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ReactionOutcome
         * @function getTypeUrl
         * @memberof ord.ReactionOutcome
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ReactionOutcome.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.ReactionOutcome";
        };

        return ReactionOutcome;
    })();

    ord.ProductCompound = (function() {

        /**
         * Properties of a ProductCompound.
         * @memberof ord
         * @interface IProductCompound
         * @property {Array.<ord.ICompoundIdentifier>|null} [identifiers] ProductCompound identifiers
         * @property {boolean|null} [isDesiredProduct] ProductCompound isDesiredProduct
         * @property {Array.<ord.IProductMeasurement>|null} [measurements] ProductCompound measurements
         * @property {string|null} [isolatedColor] ProductCompound isolatedColor
         * @property {ord.ITexture|null} [texture] ProductCompound texture
         * @property {Object.<string,ord.IData>|null} [features] ProductCompound features
         * @property {ord.ReactionRole.ReactionRoleType|null} [reactionRole] ProductCompound reactionRole
         */

        /**
         * Constructs a new ProductCompound.
         * @memberof ord
         * @classdesc Represents a ProductCompound.
         * @implements IProductCompound
         * @constructor
         * @param {ord.IProductCompound=} [properties] Properties to set
         */
        function ProductCompound(properties) {
            this.identifiers = [];
            this.measurements = [];
            this.features = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProductCompound identifiers.
         * @member {Array.<ord.ICompoundIdentifier>} identifiers
         * @memberof ord.ProductCompound
         * @instance
         */
        ProductCompound.prototype.identifiers = $util.emptyArray;

        /**
         * ProductCompound isDesiredProduct.
         * @member {boolean|null|undefined} isDesiredProduct
         * @memberof ord.ProductCompound
         * @instance
         */
        ProductCompound.prototype.isDesiredProduct = null;

        /**
         * ProductCompound measurements.
         * @member {Array.<ord.IProductMeasurement>} measurements
         * @memberof ord.ProductCompound
         * @instance
         */
        ProductCompound.prototype.measurements = $util.emptyArray;

        /**
         * ProductCompound isolatedColor.
         * @member {string} isolatedColor
         * @memberof ord.ProductCompound
         * @instance
         */
        ProductCompound.prototype.isolatedColor = "";

        /**
         * ProductCompound texture.
         * @member {ord.ITexture|null|undefined} texture
         * @memberof ord.ProductCompound
         * @instance
         */
        ProductCompound.prototype.texture = null;

        /**
         * ProductCompound features.
         * @member {Object.<string,ord.IData>} features
         * @memberof ord.ProductCompound
         * @instance
         */
        ProductCompound.prototype.features = $util.emptyObject;

        /**
         * ProductCompound reactionRole.
         * @member {ord.ReactionRole.ReactionRoleType} reactionRole
         * @memberof ord.ProductCompound
         * @instance
         */
        ProductCompound.prototype.reactionRole = 0;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(ProductCompound.prototype, "_isDesiredProduct", {
            get: $util.oneOfGetter($oneOfFields = ["isDesiredProduct"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ProductCompound instance using the specified properties.
         * @function create
         * @memberof ord.ProductCompound
         * @static
         * @param {ord.IProductCompound=} [properties] Properties to set
         * @returns {ord.ProductCompound} ProductCompound instance
         */
        ProductCompound.create = function create(properties) {
            return new ProductCompound(properties);
        };

        /**
         * Encodes the specified ProductCompound message. Does not implicitly {@link ord.ProductCompound.verify|verify} messages.
         * @function encode
         * @memberof ord.ProductCompound
         * @static
         * @param {ord.IProductCompound} message ProductCompound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProductCompound.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.identifiers != null && message.identifiers.length)
                for (let i = 0; i < message.identifiers.length; ++i)
                    $root.ord.CompoundIdentifier.encode(message.identifiers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.isDesiredProduct != null && Object.hasOwnProperty.call(message, "isDesiredProduct"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isDesiredProduct);
            if (message.measurements != null && message.measurements.length)
                for (let i = 0; i < message.measurements.length; ++i)
                    $root.ord.ProductMeasurement.encode(message.measurements[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.isolatedColor != null && Object.hasOwnProperty.call(message, "isolatedColor"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.isolatedColor);
            if (message.texture != null && Object.hasOwnProperty.call(message, "texture"))
                $root.ord.Texture.encode(message.texture, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.features != null && Object.hasOwnProperty.call(message, "features"))
                for (let keys = Object.keys(message.features), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 6, wireType 2 =*/50).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.ord.Data.encode(message.features[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.reactionRole != null && Object.hasOwnProperty.call(message, "reactionRole"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.reactionRole);
            return writer;
        };

        /**
         * Encodes the specified ProductCompound message, length delimited. Does not implicitly {@link ord.ProductCompound.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.ProductCompound
         * @static
         * @param {ord.IProductCompound} message ProductCompound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProductCompound.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProductCompound message from the specified reader or buffer.
         * @function decode
         * @memberof ord.ProductCompound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.ProductCompound} ProductCompound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProductCompound.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.ProductCompound(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.identifiers && message.identifiers.length))
                            message.identifiers = [];
                        message.identifiers.push($root.ord.CompoundIdentifier.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.isDesiredProduct = reader.bool();
                        break;
                    }
                case 3: {
                        if (!(message.measurements && message.measurements.length))
                            message.measurements = [];
                        message.measurements.push($root.ord.ProductMeasurement.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        message.isolatedColor = reader.string();
                        break;
                    }
                case 5: {
                        message.texture = $root.ord.Texture.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        if (message.features === $util.emptyObject)
                            message.features = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.ord.Data.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.features[key] = value;
                        break;
                    }
                case 7: {
                        message.reactionRole = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProductCompound message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.ProductCompound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.ProductCompound} ProductCompound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProductCompound.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProductCompound message.
         * @function verify
         * @memberof ord.ProductCompound
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProductCompound.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.identifiers != null && message.hasOwnProperty("identifiers")) {
                if (!Array.isArray(message.identifiers))
                    return "identifiers: array expected";
                for (let i = 0; i < message.identifiers.length; ++i) {
                    let error = $root.ord.CompoundIdentifier.verify(message.identifiers[i]);
                    if (error)
                        return "identifiers." + error;
                }
            }
            if (message.isDesiredProduct != null && message.hasOwnProperty("isDesiredProduct")) {
                properties._isDesiredProduct = 1;
                if (typeof message.isDesiredProduct !== "boolean")
                    return "isDesiredProduct: boolean expected";
            }
            if (message.measurements != null && message.hasOwnProperty("measurements")) {
                if (!Array.isArray(message.measurements))
                    return "measurements: array expected";
                for (let i = 0; i < message.measurements.length; ++i) {
                    let error = $root.ord.ProductMeasurement.verify(message.measurements[i]);
                    if (error)
                        return "measurements." + error;
                }
            }
            if (message.isolatedColor != null && message.hasOwnProperty("isolatedColor"))
                if (!$util.isString(message.isolatedColor))
                    return "isolatedColor: string expected";
            if (message.texture != null && message.hasOwnProperty("texture")) {
                let error = $root.ord.Texture.verify(message.texture);
                if (error)
                    return "texture." + error;
            }
            if (message.features != null && message.hasOwnProperty("features")) {
                if (!$util.isObject(message.features))
                    return "features: object expected";
                let key = Object.keys(message.features);
                for (let i = 0; i < key.length; ++i) {
                    let error = $root.ord.Data.verify(message.features[key[i]]);
                    if (error)
                        return "features." + error;
                }
            }
            if (message.reactionRole != null && message.hasOwnProperty("reactionRole"))
                switch (message.reactionRole) {
                default:
                    return "reactionRole: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                    break;
                }
            return null;
        };

        /**
         * Creates a ProductCompound message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.ProductCompound
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.ProductCompound} ProductCompound
         */
        ProductCompound.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.ProductCompound)
                return object;
            let message = new $root.ord.ProductCompound();
            if (object.identifiers) {
                if (!Array.isArray(object.identifiers))
                    throw TypeError(".ord.ProductCompound.identifiers: array expected");
                message.identifiers = [];
                for (let i = 0; i < object.identifiers.length; ++i) {
                    if (typeof object.identifiers[i] !== "object")
                        throw TypeError(".ord.ProductCompound.identifiers: object expected");
                    message.identifiers[i] = $root.ord.CompoundIdentifier.fromObject(object.identifiers[i]);
                }
            }
            if (object.isDesiredProduct != null)
                message.isDesiredProduct = Boolean(object.isDesiredProduct);
            if (object.measurements) {
                if (!Array.isArray(object.measurements))
                    throw TypeError(".ord.ProductCompound.measurements: array expected");
                message.measurements = [];
                for (let i = 0; i < object.measurements.length; ++i) {
                    if (typeof object.measurements[i] !== "object")
                        throw TypeError(".ord.ProductCompound.measurements: object expected");
                    message.measurements[i] = $root.ord.ProductMeasurement.fromObject(object.measurements[i]);
                }
            }
            if (object.isolatedColor != null)
                message.isolatedColor = String(object.isolatedColor);
            if (object.texture != null) {
                if (typeof object.texture !== "object")
                    throw TypeError(".ord.ProductCompound.texture: object expected");
                message.texture = $root.ord.Texture.fromObject(object.texture);
            }
            if (object.features) {
                if (typeof object.features !== "object")
                    throw TypeError(".ord.ProductCompound.features: object expected");
                message.features = {};
                for (let keys = Object.keys(object.features), i = 0; i < keys.length; ++i) {
                    if (typeof object.features[keys[i]] !== "object")
                        throw TypeError(".ord.ProductCompound.features: object expected");
                    message.features[keys[i]] = $root.ord.Data.fromObject(object.features[keys[i]]);
                }
            }
            switch (object.reactionRole) {
            default:
                if (typeof object.reactionRole === "number") {
                    message.reactionRole = object.reactionRole;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.reactionRole = 0;
                break;
            case "REACTANT":
            case 1:
                message.reactionRole = 1;
                break;
            case "REAGENT":
            case 2:
                message.reactionRole = 2;
                break;
            case "SOLVENT":
            case 3:
                message.reactionRole = 3;
                break;
            case "CATALYST":
            case 4:
                message.reactionRole = 4;
                break;
            case "WORKUP":
            case 5:
                message.reactionRole = 5;
                break;
            case "INTERNAL_STANDARD":
            case 6:
                message.reactionRole = 6;
                break;
            case "AUTHENTIC_STANDARD":
            case 7:
                message.reactionRole = 7;
                break;
            case "PRODUCT":
            case 8:
                message.reactionRole = 8;
                break;
            case "BYPRODUCT":
            case 9:
                message.reactionRole = 9;
                break;
            case "SIDE_PRODUCT":
            case 10:
                message.reactionRole = 10;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a ProductCompound message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.ProductCompound
         * @static
         * @param {ord.ProductCompound} message ProductCompound
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProductCompound.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.identifiers = [];
                object.measurements = [];
            }
            if (options.objects || options.defaults)
                object.features = {};
            if (options.defaults) {
                object.isolatedColor = "";
                object.texture = null;
                object.reactionRole = options.enums === String ? "UNSPECIFIED" : 0;
            }
            if (message.identifiers && message.identifiers.length) {
                object.identifiers = [];
                for (let j = 0; j < message.identifiers.length; ++j)
                    object.identifiers[j] = $root.ord.CompoundIdentifier.toObject(message.identifiers[j], options);
            }
            if (message.isDesiredProduct != null && message.hasOwnProperty("isDesiredProduct")) {
                object.isDesiredProduct = message.isDesiredProduct;
                if (options.oneofs)
                    object._isDesiredProduct = "isDesiredProduct";
            }
            if (message.measurements && message.measurements.length) {
                object.measurements = [];
                for (let j = 0; j < message.measurements.length; ++j)
                    object.measurements[j] = $root.ord.ProductMeasurement.toObject(message.measurements[j], options);
            }
            if (message.isolatedColor != null && message.hasOwnProperty("isolatedColor"))
                object.isolatedColor = message.isolatedColor;
            if (message.texture != null && message.hasOwnProperty("texture"))
                object.texture = $root.ord.Texture.toObject(message.texture, options);
            let keys2;
            if (message.features && (keys2 = Object.keys(message.features)).length) {
                object.features = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.features[keys2[j]] = $root.ord.Data.toObject(message.features[keys2[j]], options);
            }
            if (message.reactionRole != null && message.hasOwnProperty("reactionRole"))
                object.reactionRole = options.enums === String ? $root.ord.ReactionRole.ReactionRoleType[message.reactionRole] === undefined ? message.reactionRole : $root.ord.ReactionRole.ReactionRoleType[message.reactionRole] : message.reactionRole;
            return object;
        };

        /**
         * Converts this ProductCompound to JSON.
         * @function toJSON
         * @memberof ord.ProductCompound
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProductCompound.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ProductCompound
         * @function getTypeUrl
         * @memberof ord.ProductCompound
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ProductCompound.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.ProductCompound";
        };

        return ProductCompound;
    })();

    ord.ProductMeasurement = (function() {

        /**
         * Properties of a ProductMeasurement.
         * @memberof ord
         * @interface IProductMeasurement
         * @property {string|null} [analysisKey] ProductMeasurement analysisKey
         * @property {ord.ProductMeasurement.ProductMeasurementType|null} [type] ProductMeasurement type
         * @property {string|null} [details] ProductMeasurement details
         * @property {boolean|null} [usesInternalStandard] ProductMeasurement usesInternalStandard
         * @property {boolean|null} [isNormalized] ProductMeasurement isNormalized
         * @property {boolean|null} [usesAuthenticStandard] ProductMeasurement usesAuthenticStandard
         * @property {ord.ICompound|null} [authenticStandard] ProductMeasurement authenticStandard
         * @property {ord.IPercentage|null} [percentage] ProductMeasurement percentage
         * @property {ord.IFloatValue|null} [floatValue] ProductMeasurement floatValue
         * @property {string|null} [stringValue] ProductMeasurement stringValue
         * @property {ord.IAmount|null} [amount] ProductMeasurement amount
         * @property {ord.ITime|null} [retentionTime] ProductMeasurement retentionTime
         * @property {ord.ProductMeasurement.IMassSpecMeasurementDetails|null} [massSpecDetails] ProductMeasurement massSpecDetails
         * @property {ord.ProductMeasurement.ISelectivity|null} [selectivity] ProductMeasurement selectivity
         * @property {ord.IWavelength|null} [wavelength] ProductMeasurement wavelength
         */

        /**
         * Constructs a new ProductMeasurement.
         * @memberof ord
         * @classdesc Represents a ProductMeasurement.
         * @implements IProductMeasurement
         * @constructor
         * @param {ord.IProductMeasurement=} [properties] Properties to set
         */
        function ProductMeasurement(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProductMeasurement analysisKey.
         * @member {string} analysisKey
         * @memberof ord.ProductMeasurement
         * @instance
         */
        ProductMeasurement.prototype.analysisKey = "";

        /**
         * ProductMeasurement type.
         * @member {ord.ProductMeasurement.ProductMeasurementType} type
         * @memberof ord.ProductMeasurement
         * @instance
         */
        ProductMeasurement.prototype.type = 0;

        /**
         * ProductMeasurement details.
         * @member {string} details
         * @memberof ord.ProductMeasurement
         * @instance
         */
        ProductMeasurement.prototype.details = "";

        /**
         * ProductMeasurement usesInternalStandard.
         * @member {boolean|null|undefined} usesInternalStandard
         * @memberof ord.ProductMeasurement
         * @instance
         */
        ProductMeasurement.prototype.usesInternalStandard = null;

        /**
         * ProductMeasurement isNormalized.
         * @member {boolean|null|undefined} isNormalized
         * @memberof ord.ProductMeasurement
         * @instance
         */
        ProductMeasurement.prototype.isNormalized = null;

        /**
         * ProductMeasurement usesAuthenticStandard.
         * @member {boolean|null|undefined} usesAuthenticStandard
         * @memberof ord.ProductMeasurement
         * @instance
         */
        ProductMeasurement.prototype.usesAuthenticStandard = null;

        /**
         * ProductMeasurement authenticStandard.
         * @member {ord.ICompound|null|undefined} authenticStandard
         * @memberof ord.ProductMeasurement
         * @instance
         */
        ProductMeasurement.prototype.authenticStandard = null;

        /**
         * ProductMeasurement percentage.
         * @member {ord.IPercentage|null|undefined} percentage
         * @memberof ord.ProductMeasurement
         * @instance
         */
        ProductMeasurement.prototype.percentage = null;

        /**
         * ProductMeasurement floatValue.
         * @member {ord.IFloatValue|null|undefined} floatValue
         * @memberof ord.ProductMeasurement
         * @instance
         */
        ProductMeasurement.prototype.floatValue = null;

        /**
         * ProductMeasurement stringValue.
         * @member {string|null|undefined} stringValue
         * @memberof ord.ProductMeasurement
         * @instance
         */
        ProductMeasurement.prototype.stringValue = null;

        /**
         * ProductMeasurement amount.
         * @member {ord.IAmount|null|undefined} amount
         * @memberof ord.ProductMeasurement
         * @instance
         */
        ProductMeasurement.prototype.amount = null;

        /**
         * ProductMeasurement retentionTime.
         * @member {ord.ITime|null|undefined} retentionTime
         * @memberof ord.ProductMeasurement
         * @instance
         */
        ProductMeasurement.prototype.retentionTime = null;

        /**
         * ProductMeasurement massSpecDetails.
         * @member {ord.ProductMeasurement.IMassSpecMeasurementDetails|null|undefined} massSpecDetails
         * @memberof ord.ProductMeasurement
         * @instance
         */
        ProductMeasurement.prototype.massSpecDetails = null;

        /**
         * ProductMeasurement selectivity.
         * @member {ord.ProductMeasurement.ISelectivity|null|undefined} selectivity
         * @memberof ord.ProductMeasurement
         * @instance
         */
        ProductMeasurement.prototype.selectivity = null;

        /**
         * ProductMeasurement wavelength.
         * @member {ord.IWavelength|null|undefined} wavelength
         * @memberof ord.ProductMeasurement
         * @instance
         */
        ProductMeasurement.prototype.wavelength = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(ProductMeasurement.prototype, "_usesInternalStandard", {
            get: $util.oneOfGetter($oneOfFields = ["usesInternalStandard"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(ProductMeasurement.prototype, "_isNormalized", {
            get: $util.oneOfGetter($oneOfFields = ["isNormalized"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(ProductMeasurement.prototype, "_usesAuthenticStandard", {
            get: $util.oneOfGetter($oneOfFields = ["usesAuthenticStandard"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * ProductMeasurement value.
         * @member {"percentage"|"floatValue"|"stringValue"|"amount"|undefined} value
         * @memberof ord.ProductMeasurement
         * @instance
         */
        Object.defineProperty(ProductMeasurement.prototype, "value", {
            get: $util.oneOfGetter($oneOfFields = ["percentage", "floatValue", "stringValue", "amount"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ProductMeasurement instance using the specified properties.
         * @function create
         * @memberof ord.ProductMeasurement
         * @static
         * @param {ord.IProductMeasurement=} [properties] Properties to set
         * @returns {ord.ProductMeasurement} ProductMeasurement instance
         */
        ProductMeasurement.create = function create(properties) {
            return new ProductMeasurement(properties);
        };

        /**
         * Encodes the specified ProductMeasurement message. Does not implicitly {@link ord.ProductMeasurement.verify|verify} messages.
         * @function encode
         * @memberof ord.ProductMeasurement
         * @static
         * @param {ord.IProductMeasurement} message ProductMeasurement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProductMeasurement.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.analysisKey != null && Object.hasOwnProperty.call(message, "analysisKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.analysisKey);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.details);
            if (message.usesInternalStandard != null && Object.hasOwnProperty.call(message, "usesInternalStandard"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.usesInternalStandard);
            if (message.isNormalized != null && Object.hasOwnProperty.call(message, "isNormalized"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.isNormalized);
            if (message.usesAuthenticStandard != null && Object.hasOwnProperty.call(message, "usesAuthenticStandard"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.usesAuthenticStandard);
            if (message.authenticStandard != null && Object.hasOwnProperty.call(message, "authenticStandard"))
                $root.ord.Compound.encode(message.authenticStandard, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.percentage != null && Object.hasOwnProperty.call(message, "percentage"))
                $root.ord.Percentage.encode(message.percentage, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.floatValue != null && Object.hasOwnProperty.call(message, "floatValue"))
                $root.ord.FloatValue.encode(message.floatValue, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.stringValue);
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                $root.ord.Amount.encode(message.amount, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.retentionTime != null && Object.hasOwnProperty.call(message, "retentionTime"))
                $root.ord.Time.encode(message.retentionTime, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.massSpecDetails != null && Object.hasOwnProperty.call(message, "massSpecDetails"))
                $root.ord.ProductMeasurement.MassSpecMeasurementDetails.encode(message.massSpecDetails, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.selectivity != null && Object.hasOwnProperty.call(message, "selectivity"))
                $root.ord.ProductMeasurement.Selectivity.encode(message.selectivity, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.wavelength != null && Object.hasOwnProperty.call(message, "wavelength"))
                $root.ord.Wavelength.encode(message.wavelength, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ProductMeasurement message, length delimited. Does not implicitly {@link ord.ProductMeasurement.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.ProductMeasurement
         * @static
         * @param {ord.IProductMeasurement} message ProductMeasurement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProductMeasurement.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProductMeasurement message from the specified reader or buffer.
         * @function decode
         * @memberof ord.ProductMeasurement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.ProductMeasurement} ProductMeasurement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProductMeasurement.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.ProductMeasurement();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.analysisKey = reader.string();
                        break;
                    }
                case 2: {
                        message.type = reader.int32();
                        break;
                    }
                case 3: {
                        message.details = reader.string();
                        break;
                    }
                case 4: {
                        message.usesInternalStandard = reader.bool();
                        break;
                    }
                case 5: {
                        message.isNormalized = reader.bool();
                        break;
                    }
                case 6: {
                        message.usesAuthenticStandard = reader.bool();
                        break;
                    }
                case 7: {
                        message.authenticStandard = $root.ord.Compound.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.percentage = $root.ord.Percentage.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.floatValue = $root.ord.FloatValue.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.stringValue = reader.string();
                        break;
                    }
                case 11: {
                        message.amount = $root.ord.Amount.decode(reader, reader.uint32());
                        break;
                    }
                case 12: {
                        message.retentionTime = $root.ord.Time.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.massSpecDetails = $root.ord.ProductMeasurement.MassSpecMeasurementDetails.decode(reader, reader.uint32());
                        break;
                    }
                case 14: {
                        message.selectivity = $root.ord.ProductMeasurement.Selectivity.decode(reader, reader.uint32());
                        break;
                    }
                case 15: {
                        message.wavelength = $root.ord.Wavelength.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProductMeasurement message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.ProductMeasurement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.ProductMeasurement} ProductMeasurement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProductMeasurement.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProductMeasurement message.
         * @function verify
         * @memberof ord.ProductMeasurement
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProductMeasurement.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.analysisKey != null && message.hasOwnProperty("analysisKey"))
                if (!$util.isString(message.analysisKey))
                    return "analysisKey: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                    break;
                }
            if (message.details != null && message.hasOwnProperty("details"))
                if (!$util.isString(message.details))
                    return "details: string expected";
            if (message.usesInternalStandard != null && message.hasOwnProperty("usesInternalStandard")) {
                properties._usesInternalStandard = 1;
                if (typeof message.usesInternalStandard !== "boolean")
                    return "usesInternalStandard: boolean expected";
            }
            if (message.isNormalized != null && message.hasOwnProperty("isNormalized")) {
                properties._isNormalized = 1;
                if (typeof message.isNormalized !== "boolean")
                    return "isNormalized: boolean expected";
            }
            if (message.usesAuthenticStandard != null && message.hasOwnProperty("usesAuthenticStandard")) {
                properties._usesAuthenticStandard = 1;
                if (typeof message.usesAuthenticStandard !== "boolean")
                    return "usesAuthenticStandard: boolean expected";
            }
            if (message.authenticStandard != null && message.hasOwnProperty("authenticStandard")) {
                let error = $root.ord.Compound.verify(message.authenticStandard);
                if (error)
                    return "authenticStandard." + error;
            }
            if (message.percentage != null && message.hasOwnProperty("percentage")) {
                properties.value = 1;
                {
                    let error = $root.ord.Percentage.verify(message.percentage);
                    if (error)
                        return "percentage." + error;
                }
            }
            if (message.floatValue != null && message.hasOwnProperty("floatValue")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                {
                    let error = $root.ord.FloatValue.verify(message.floatValue);
                    if (error)
                        return "floatValue." + error;
                }
            }
            if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (!$util.isString(message.stringValue))
                    return "stringValue: string expected";
            }
            if (message.amount != null && message.hasOwnProperty("amount")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                {
                    let error = $root.ord.Amount.verify(message.amount);
                    if (error)
                        return "amount." + error;
                }
            }
            if (message.retentionTime != null && message.hasOwnProperty("retentionTime")) {
                let error = $root.ord.Time.verify(message.retentionTime);
                if (error)
                    return "retentionTime." + error;
            }
            if (message.massSpecDetails != null && message.hasOwnProperty("massSpecDetails")) {
                let error = $root.ord.ProductMeasurement.MassSpecMeasurementDetails.verify(message.massSpecDetails);
                if (error)
                    return "massSpecDetails." + error;
            }
            if (message.selectivity != null && message.hasOwnProperty("selectivity")) {
                let error = $root.ord.ProductMeasurement.Selectivity.verify(message.selectivity);
                if (error)
                    return "selectivity." + error;
            }
            if (message.wavelength != null && message.hasOwnProperty("wavelength")) {
                let error = $root.ord.Wavelength.verify(message.wavelength);
                if (error)
                    return "wavelength." + error;
            }
            return null;
        };

        /**
         * Creates a ProductMeasurement message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.ProductMeasurement
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.ProductMeasurement} ProductMeasurement
         */
        ProductMeasurement.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.ProductMeasurement)
                return object;
            let message = new $root.ord.ProductMeasurement();
            if (object.analysisKey != null)
                message.analysisKey = String(object.analysisKey);
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.type = 0;
                break;
            case "CUSTOM":
            case 1:
                message.type = 1;
                break;
            case "IDENTITY":
            case 2:
                message.type = 2;
                break;
            case "YIELD":
            case 3:
                message.type = 3;
                break;
            case "SELECTIVITY":
            case 4:
                message.type = 4;
                break;
            case "PURITY":
            case 5:
                message.type = 5;
                break;
            case "AREA":
            case 6:
                message.type = 6;
                break;
            case "COUNTS":
            case 7:
                message.type = 7;
                break;
            case "INTENSITY":
            case 8:
                message.type = 8;
                break;
            case "AMOUNT":
            case 9:
                message.type = 9;
                break;
            }
            if (object.details != null)
                message.details = String(object.details);
            if (object.usesInternalStandard != null)
                message.usesInternalStandard = Boolean(object.usesInternalStandard);
            if (object.isNormalized != null)
                message.isNormalized = Boolean(object.isNormalized);
            if (object.usesAuthenticStandard != null)
                message.usesAuthenticStandard = Boolean(object.usesAuthenticStandard);
            if (object.authenticStandard != null) {
                if (typeof object.authenticStandard !== "object")
                    throw TypeError(".ord.ProductMeasurement.authenticStandard: object expected");
                message.authenticStandard = $root.ord.Compound.fromObject(object.authenticStandard);
            }
            if (object.percentage != null) {
                if (typeof object.percentage !== "object")
                    throw TypeError(".ord.ProductMeasurement.percentage: object expected");
                message.percentage = $root.ord.Percentage.fromObject(object.percentage);
            }
            if (object.floatValue != null) {
                if (typeof object.floatValue !== "object")
                    throw TypeError(".ord.ProductMeasurement.floatValue: object expected");
                message.floatValue = $root.ord.FloatValue.fromObject(object.floatValue);
            }
            if (object.stringValue != null)
                message.stringValue = String(object.stringValue);
            if (object.amount != null) {
                if (typeof object.amount !== "object")
                    throw TypeError(".ord.ProductMeasurement.amount: object expected");
                message.amount = $root.ord.Amount.fromObject(object.amount);
            }
            if (object.retentionTime != null) {
                if (typeof object.retentionTime !== "object")
                    throw TypeError(".ord.ProductMeasurement.retentionTime: object expected");
                message.retentionTime = $root.ord.Time.fromObject(object.retentionTime);
            }
            if (object.massSpecDetails != null) {
                if (typeof object.massSpecDetails !== "object")
                    throw TypeError(".ord.ProductMeasurement.massSpecDetails: object expected");
                message.massSpecDetails = $root.ord.ProductMeasurement.MassSpecMeasurementDetails.fromObject(object.massSpecDetails);
            }
            if (object.selectivity != null) {
                if (typeof object.selectivity !== "object")
                    throw TypeError(".ord.ProductMeasurement.selectivity: object expected");
                message.selectivity = $root.ord.ProductMeasurement.Selectivity.fromObject(object.selectivity);
            }
            if (object.wavelength != null) {
                if (typeof object.wavelength !== "object")
                    throw TypeError(".ord.ProductMeasurement.wavelength: object expected");
                message.wavelength = $root.ord.Wavelength.fromObject(object.wavelength);
            }
            return message;
        };

        /**
         * Creates a plain object from a ProductMeasurement message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.ProductMeasurement
         * @static
         * @param {ord.ProductMeasurement} message ProductMeasurement
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProductMeasurement.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.analysisKey = "";
                object.type = options.enums === String ? "UNSPECIFIED" : 0;
                object.details = "";
                object.authenticStandard = null;
                object.retentionTime = null;
                object.massSpecDetails = null;
                object.selectivity = null;
                object.wavelength = null;
            }
            if (message.analysisKey != null && message.hasOwnProperty("analysisKey"))
                object.analysisKey = message.analysisKey;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.ord.ProductMeasurement.ProductMeasurementType[message.type] === undefined ? message.type : $root.ord.ProductMeasurement.ProductMeasurementType[message.type] : message.type;
            if (message.details != null && message.hasOwnProperty("details"))
                object.details = message.details;
            if (message.usesInternalStandard != null && message.hasOwnProperty("usesInternalStandard")) {
                object.usesInternalStandard = message.usesInternalStandard;
                if (options.oneofs)
                    object._usesInternalStandard = "usesInternalStandard";
            }
            if (message.isNormalized != null && message.hasOwnProperty("isNormalized")) {
                object.isNormalized = message.isNormalized;
                if (options.oneofs)
                    object._isNormalized = "isNormalized";
            }
            if (message.usesAuthenticStandard != null && message.hasOwnProperty("usesAuthenticStandard")) {
                object.usesAuthenticStandard = message.usesAuthenticStandard;
                if (options.oneofs)
                    object._usesAuthenticStandard = "usesAuthenticStandard";
            }
            if (message.authenticStandard != null && message.hasOwnProperty("authenticStandard"))
                object.authenticStandard = $root.ord.Compound.toObject(message.authenticStandard, options);
            if (message.percentage != null && message.hasOwnProperty("percentage")) {
                object.percentage = $root.ord.Percentage.toObject(message.percentage, options);
                if (options.oneofs)
                    object.value = "percentage";
            }
            if (message.floatValue != null && message.hasOwnProperty("floatValue")) {
                object.floatValue = $root.ord.FloatValue.toObject(message.floatValue, options);
                if (options.oneofs)
                    object.value = "floatValue";
            }
            if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                object.stringValue = message.stringValue;
                if (options.oneofs)
                    object.value = "stringValue";
            }
            if (message.amount != null && message.hasOwnProperty("amount")) {
                object.amount = $root.ord.Amount.toObject(message.amount, options);
                if (options.oneofs)
                    object.value = "amount";
            }
            if (message.retentionTime != null && message.hasOwnProperty("retentionTime"))
                object.retentionTime = $root.ord.Time.toObject(message.retentionTime, options);
            if (message.massSpecDetails != null && message.hasOwnProperty("massSpecDetails"))
                object.massSpecDetails = $root.ord.ProductMeasurement.MassSpecMeasurementDetails.toObject(message.massSpecDetails, options);
            if (message.selectivity != null && message.hasOwnProperty("selectivity"))
                object.selectivity = $root.ord.ProductMeasurement.Selectivity.toObject(message.selectivity, options);
            if (message.wavelength != null && message.hasOwnProperty("wavelength"))
                object.wavelength = $root.ord.Wavelength.toObject(message.wavelength, options);
            return object;
        };

        /**
         * Converts this ProductMeasurement to JSON.
         * @function toJSON
         * @memberof ord.ProductMeasurement
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProductMeasurement.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ProductMeasurement
         * @function getTypeUrl
         * @memberof ord.ProductMeasurement
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ProductMeasurement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.ProductMeasurement";
        };

        /**
         * ProductMeasurementType enum.
         * @name ord.ProductMeasurement.ProductMeasurementType
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} CUSTOM=1 CUSTOM value
         * @property {number} IDENTITY=2 IDENTITY value
         * @property {number} YIELD=3 YIELD value
         * @property {number} SELECTIVITY=4 SELECTIVITY value
         * @property {number} PURITY=5 PURITY value
         * @property {number} AREA=6 AREA value
         * @property {number} COUNTS=7 COUNTS value
         * @property {number} INTENSITY=8 INTENSITY value
         * @property {number} AMOUNT=9 AMOUNT value
         */
        ProductMeasurement.ProductMeasurementType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "CUSTOM"] = 1;
            values[valuesById[2] = "IDENTITY"] = 2;
            values[valuesById[3] = "YIELD"] = 3;
            values[valuesById[4] = "SELECTIVITY"] = 4;
            values[valuesById[5] = "PURITY"] = 5;
            values[valuesById[6] = "AREA"] = 6;
            values[valuesById[7] = "COUNTS"] = 7;
            values[valuesById[8] = "INTENSITY"] = 8;
            values[valuesById[9] = "AMOUNT"] = 9;
            return values;
        })();

        ProductMeasurement.MassSpecMeasurementDetails = (function() {

            /**
             * Properties of a MassSpecMeasurementDetails.
             * @memberof ord.ProductMeasurement
             * @interface IMassSpecMeasurementDetails
             * @property {ord.ProductMeasurement.MassSpecMeasurementDetails.MassSpecMeasurementType|null} [type] MassSpecMeasurementDetails type
             * @property {string|null} [details] MassSpecMeasurementDetails details
             * @property {number|null} [ticMinimumMz] MassSpecMeasurementDetails ticMinimumMz
             * @property {number|null} [ticMaximumMz] MassSpecMeasurementDetails ticMaximumMz
             * @property {Array.<number>|null} [eicMasses] MassSpecMeasurementDetails eicMasses
             */

            /**
             * Constructs a new MassSpecMeasurementDetails.
             * @memberof ord.ProductMeasurement
             * @classdesc Represents a MassSpecMeasurementDetails.
             * @implements IMassSpecMeasurementDetails
             * @constructor
             * @param {ord.ProductMeasurement.IMassSpecMeasurementDetails=} [properties] Properties to set
             */
            function MassSpecMeasurementDetails(properties) {
                this.eicMasses = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MassSpecMeasurementDetails type.
             * @member {ord.ProductMeasurement.MassSpecMeasurementDetails.MassSpecMeasurementType} type
             * @memberof ord.ProductMeasurement.MassSpecMeasurementDetails
             * @instance
             */
            MassSpecMeasurementDetails.prototype.type = 0;

            /**
             * MassSpecMeasurementDetails details.
             * @member {string} details
             * @memberof ord.ProductMeasurement.MassSpecMeasurementDetails
             * @instance
             */
            MassSpecMeasurementDetails.prototype.details = "";

            /**
             * MassSpecMeasurementDetails ticMinimumMz.
             * @member {number|null|undefined} ticMinimumMz
             * @memberof ord.ProductMeasurement.MassSpecMeasurementDetails
             * @instance
             */
            MassSpecMeasurementDetails.prototype.ticMinimumMz = null;

            /**
             * MassSpecMeasurementDetails ticMaximumMz.
             * @member {number|null|undefined} ticMaximumMz
             * @memberof ord.ProductMeasurement.MassSpecMeasurementDetails
             * @instance
             */
            MassSpecMeasurementDetails.prototype.ticMaximumMz = null;

            /**
             * MassSpecMeasurementDetails eicMasses.
             * @member {Array.<number>} eicMasses
             * @memberof ord.ProductMeasurement.MassSpecMeasurementDetails
             * @instance
             */
            MassSpecMeasurementDetails.prototype.eicMasses = $util.emptyArray;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            // Virtual OneOf for proto3 optional field
            Object.defineProperty(MassSpecMeasurementDetails.prototype, "_ticMinimumMz", {
                get: $util.oneOfGetter($oneOfFields = ["ticMinimumMz"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            // Virtual OneOf for proto3 optional field
            Object.defineProperty(MassSpecMeasurementDetails.prototype, "_ticMaximumMz", {
                get: $util.oneOfGetter($oneOfFields = ["ticMaximumMz"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new MassSpecMeasurementDetails instance using the specified properties.
             * @function create
             * @memberof ord.ProductMeasurement.MassSpecMeasurementDetails
             * @static
             * @param {ord.ProductMeasurement.IMassSpecMeasurementDetails=} [properties] Properties to set
             * @returns {ord.ProductMeasurement.MassSpecMeasurementDetails} MassSpecMeasurementDetails instance
             */
            MassSpecMeasurementDetails.create = function create(properties) {
                return new MassSpecMeasurementDetails(properties);
            };

            /**
             * Encodes the specified MassSpecMeasurementDetails message. Does not implicitly {@link ord.ProductMeasurement.MassSpecMeasurementDetails.verify|verify} messages.
             * @function encode
             * @memberof ord.ProductMeasurement.MassSpecMeasurementDetails
             * @static
             * @param {ord.ProductMeasurement.IMassSpecMeasurementDetails} message MassSpecMeasurementDetails message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MassSpecMeasurementDetails.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
                if (message.ticMinimumMz != null && Object.hasOwnProperty.call(message, "ticMinimumMz"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.ticMinimumMz);
                if (message.ticMaximumMz != null && Object.hasOwnProperty.call(message, "ticMaximumMz"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.ticMaximumMz);
                if (message.eicMasses != null && message.eicMasses.length) {
                    writer.uint32(/* id 5, wireType 2 =*/42).fork();
                    for (let i = 0; i < message.eicMasses.length; ++i)
                        writer.float(message.eicMasses[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified MassSpecMeasurementDetails message, length delimited. Does not implicitly {@link ord.ProductMeasurement.MassSpecMeasurementDetails.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ord.ProductMeasurement.MassSpecMeasurementDetails
             * @static
             * @param {ord.ProductMeasurement.IMassSpecMeasurementDetails} message MassSpecMeasurementDetails message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MassSpecMeasurementDetails.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MassSpecMeasurementDetails message from the specified reader or buffer.
             * @function decode
             * @memberof ord.ProductMeasurement.MassSpecMeasurementDetails
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ord.ProductMeasurement.MassSpecMeasurementDetails} MassSpecMeasurementDetails
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MassSpecMeasurementDetails.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.ProductMeasurement.MassSpecMeasurementDetails();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.details = reader.string();
                            break;
                        }
                    case 3: {
                            message.ticMinimumMz = reader.float();
                            break;
                        }
                    case 4: {
                            message.ticMaximumMz = reader.float();
                            break;
                        }
                    case 5: {
                            if (!(message.eicMasses && message.eicMasses.length))
                                message.eicMasses = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.eicMasses.push(reader.float());
                            } else
                                message.eicMasses.push(reader.float());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MassSpecMeasurementDetails message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ord.ProductMeasurement.MassSpecMeasurementDetails
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ord.ProductMeasurement.MassSpecMeasurementDetails} MassSpecMeasurementDetails
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MassSpecMeasurementDetails.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MassSpecMeasurementDetails message.
             * @function verify
             * @memberof ord.ProductMeasurement.MassSpecMeasurementDetails
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MassSpecMeasurementDetails.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                if (message.details != null && message.hasOwnProperty("details"))
                    if (!$util.isString(message.details))
                        return "details: string expected";
                if (message.ticMinimumMz != null && message.hasOwnProperty("ticMinimumMz")) {
                    properties._ticMinimumMz = 1;
                    if (typeof message.ticMinimumMz !== "number")
                        return "ticMinimumMz: number expected";
                }
                if (message.ticMaximumMz != null && message.hasOwnProperty("ticMaximumMz")) {
                    properties._ticMaximumMz = 1;
                    if (typeof message.ticMaximumMz !== "number")
                        return "ticMaximumMz: number expected";
                }
                if (message.eicMasses != null && message.hasOwnProperty("eicMasses")) {
                    if (!Array.isArray(message.eicMasses))
                        return "eicMasses: array expected";
                    for (let i = 0; i < message.eicMasses.length; ++i)
                        if (typeof message.eicMasses[i] !== "number")
                            return "eicMasses: number[] expected";
                }
                return null;
            };

            /**
             * Creates a MassSpecMeasurementDetails message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ord.ProductMeasurement.MassSpecMeasurementDetails
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ord.ProductMeasurement.MassSpecMeasurementDetails} MassSpecMeasurementDetails
             */
            MassSpecMeasurementDetails.fromObject = function fromObject(object) {
                if (object instanceof $root.ord.ProductMeasurement.MassSpecMeasurementDetails)
                    return object;
                let message = new $root.ord.ProductMeasurement.MassSpecMeasurementDetails();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "UNSPECIFIED":
                case 0:
                    message.type = 0;
                    break;
                case "CUSTOM":
                case 1:
                    message.type = 1;
                    break;
                case "TIC":
                case 2:
                    message.type = 2;
                    break;
                case "TIC_POSITIVE":
                case 3:
                    message.type = 3;
                    break;
                case "TIC_NEGATIVE":
                case 4:
                    message.type = 4;
                    break;
                case "EIC":
                case 5:
                    message.type = 5;
                    break;
                }
                if (object.details != null)
                    message.details = String(object.details);
                if (object.ticMinimumMz != null)
                    message.ticMinimumMz = Number(object.ticMinimumMz);
                if (object.ticMaximumMz != null)
                    message.ticMaximumMz = Number(object.ticMaximumMz);
                if (object.eicMasses) {
                    if (!Array.isArray(object.eicMasses))
                        throw TypeError(".ord.ProductMeasurement.MassSpecMeasurementDetails.eicMasses: array expected");
                    message.eicMasses = [];
                    for (let i = 0; i < object.eicMasses.length; ++i)
                        message.eicMasses[i] = Number(object.eicMasses[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a MassSpecMeasurementDetails message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ord.ProductMeasurement.MassSpecMeasurementDetails
             * @static
             * @param {ord.ProductMeasurement.MassSpecMeasurementDetails} message MassSpecMeasurementDetails
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MassSpecMeasurementDetails.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.eicMasses = [];
                if (options.defaults) {
                    object.type = options.enums === String ? "UNSPECIFIED" : 0;
                    object.details = "";
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.ord.ProductMeasurement.MassSpecMeasurementDetails.MassSpecMeasurementType[message.type] === undefined ? message.type : $root.ord.ProductMeasurement.MassSpecMeasurementDetails.MassSpecMeasurementType[message.type] : message.type;
                if (message.details != null && message.hasOwnProperty("details"))
                    object.details = message.details;
                if (message.ticMinimumMz != null && message.hasOwnProperty("ticMinimumMz")) {
                    object.ticMinimumMz = options.json && !isFinite(message.ticMinimumMz) ? String(message.ticMinimumMz) : message.ticMinimumMz;
                    if (options.oneofs)
                        object._ticMinimumMz = "ticMinimumMz";
                }
                if (message.ticMaximumMz != null && message.hasOwnProperty("ticMaximumMz")) {
                    object.ticMaximumMz = options.json && !isFinite(message.ticMaximumMz) ? String(message.ticMaximumMz) : message.ticMaximumMz;
                    if (options.oneofs)
                        object._ticMaximumMz = "ticMaximumMz";
                }
                if (message.eicMasses && message.eicMasses.length) {
                    object.eicMasses = [];
                    for (let j = 0; j < message.eicMasses.length; ++j)
                        object.eicMasses[j] = options.json && !isFinite(message.eicMasses[j]) ? String(message.eicMasses[j]) : message.eicMasses[j];
                }
                return object;
            };

            /**
             * Converts this MassSpecMeasurementDetails to JSON.
             * @function toJSON
             * @memberof ord.ProductMeasurement.MassSpecMeasurementDetails
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MassSpecMeasurementDetails.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MassSpecMeasurementDetails
             * @function getTypeUrl
             * @memberof ord.ProductMeasurement.MassSpecMeasurementDetails
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MassSpecMeasurementDetails.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/ord.ProductMeasurement.MassSpecMeasurementDetails";
            };

            /**
             * MassSpecMeasurementType enum.
             * @name ord.ProductMeasurement.MassSpecMeasurementDetails.MassSpecMeasurementType
             * @enum {number}
             * @property {number} UNSPECIFIED=0 UNSPECIFIED value
             * @property {number} CUSTOM=1 CUSTOM value
             * @property {number} TIC=2 TIC value
             * @property {number} TIC_POSITIVE=3 TIC_POSITIVE value
             * @property {number} TIC_NEGATIVE=4 TIC_NEGATIVE value
             * @property {number} EIC=5 EIC value
             */
            MassSpecMeasurementDetails.MassSpecMeasurementType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSPECIFIED"] = 0;
                values[valuesById[1] = "CUSTOM"] = 1;
                values[valuesById[2] = "TIC"] = 2;
                values[valuesById[3] = "TIC_POSITIVE"] = 3;
                values[valuesById[4] = "TIC_NEGATIVE"] = 4;
                values[valuesById[5] = "EIC"] = 5;
                return values;
            })();

            return MassSpecMeasurementDetails;
        })();

        ProductMeasurement.Selectivity = (function() {

            /**
             * Properties of a Selectivity.
             * @memberof ord.ProductMeasurement
             * @interface ISelectivity
             * @property {ord.ProductMeasurement.Selectivity.SelectivityType|null} [type] Selectivity type
             * @property {string|null} [details] Selectivity details
             */

            /**
             * Constructs a new Selectivity.
             * @memberof ord.ProductMeasurement
             * @classdesc Represents a Selectivity.
             * @implements ISelectivity
             * @constructor
             * @param {ord.ProductMeasurement.ISelectivity=} [properties] Properties to set
             */
            function Selectivity(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Selectivity type.
             * @member {ord.ProductMeasurement.Selectivity.SelectivityType} type
             * @memberof ord.ProductMeasurement.Selectivity
             * @instance
             */
            Selectivity.prototype.type = 0;

            /**
             * Selectivity details.
             * @member {string} details
             * @memberof ord.ProductMeasurement.Selectivity
             * @instance
             */
            Selectivity.prototype.details = "";

            /**
             * Creates a new Selectivity instance using the specified properties.
             * @function create
             * @memberof ord.ProductMeasurement.Selectivity
             * @static
             * @param {ord.ProductMeasurement.ISelectivity=} [properties] Properties to set
             * @returns {ord.ProductMeasurement.Selectivity} Selectivity instance
             */
            Selectivity.create = function create(properties) {
                return new Selectivity(properties);
            };

            /**
             * Encodes the specified Selectivity message. Does not implicitly {@link ord.ProductMeasurement.Selectivity.verify|verify} messages.
             * @function encode
             * @memberof ord.ProductMeasurement.Selectivity
             * @static
             * @param {ord.ProductMeasurement.ISelectivity} message Selectivity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Selectivity.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
                return writer;
            };

            /**
             * Encodes the specified Selectivity message, length delimited. Does not implicitly {@link ord.ProductMeasurement.Selectivity.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ord.ProductMeasurement.Selectivity
             * @static
             * @param {ord.ProductMeasurement.ISelectivity} message Selectivity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Selectivity.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Selectivity message from the specified reader or buffer.
             * @function decode
             * @memberof ord.ProductMeasurement.Selectivity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ord.ProductMeasurement.Selectivity} Selectivity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Selectivity.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.ProductMeasurement.Selectivity();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.details = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Selectivity message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ord.ProductMeasurement.Selectivity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ord.ProductMeasurement.Selectivity} Selectivity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Selectivity.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Selectivity message.
             * @function verify
             * @memberof ord.ProductMeasurement.Selectivity
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Selectivity.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.details != null && message.hasOwnProperty("details"))
                    if (!$util.isString(message.details))
                        return "details: string expected";
                return null;
            };

            /**
             * Creates a Selectivity message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ord.ProductMeasurement.Selectivity
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ord.ProductMeasurement.Selectivity} Selectivity
             */
            Selectivity.fromObject = function fromObject(object) {
                if (object instanceof $root.ord.ProductMeasurement.Selectivity)
                    return object;
                let message = new $root.ord.ProductMeasurement.Selectivity();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "UNSPECIFIED":
                case 0:
                    message.type = 0;
                    break;
                case "CUSTOM":
                case 1:
                    message.type = 1;
                    break;
                case "EE":
                case 2:
                    message.type = 2;
                    break;
                case "ER":
                case 3:
                    message.type = 3;
                    break;
                case "DR":
                case 4:
                    message.type = 4;
                    break;
                case "EZ":
                case 5:
                    message.type = 5;
                    break;
                case "ZE":
                case 6:
                    message.type = 6;
                    break;
                }
                if (object.details != null)
                    message.details = String(object.details);
                return message;
            };

            /**
             * Creates a plain object from a Selectivity message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ord.ProductMeasurement.Selectivity
             * @static
             * @param {ord.ProductMeasurement.Selectivity} message Selectivity
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Selectivity.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "UNSPECIFIED" : 0;
                    object.details = "";
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.ord.ProductMeasurement.Selectivity.SelectivityType[message.type] === undefined ? message.type : $root.ord.ProductMeasurement.Selectivity.SelectivityType[message.type] : message.type;
                if (message.details != null && message.hasOwnProperty("details"))
                    object.details = message.details;
                return object;
            };

            /**
             * Converts this Selectivity to JSON.
             * @function toJSON
             * @memberof ord.ProductMeasurement.Selectivity
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Selectivity.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Selectivity
             * @function getTypeUrl
             * @memberof ord.ProductMeasurement.Selectivity
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Selectivity.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/ord.ProductMeasurement.Selectivity";
            };

            /**
             * SelectivityType enum.
             * @name ord.ProductMeasurement.Selectivity.SelectivityType
             * @enum {number}
             * @property {number} UNSPECIFIED=0 UNSPECIFIED value
             * @property {number} CUSTOM=1 CUSTOM value
             * @property {number} EE=2 EE value
             * @property {number} ER=3 ER value
             * @property {number} DR=4 DR value
             * @property {number} EZ=5 EZ value
             * @property {number} ZE=6 ZE value
             */
            Selectivity.SelectivityType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSPECIFIED"] = 0;
                values[valuesById[1] = "CUSTOM"] = 1;
                values[valuesById[2] = "EE"] = 2;
                values[valuesById[3] = "ER"] = 3;
                values[valuesById[4] = "DR"] = 4;
                values[valuesById[5] = "EZ"] = 5;
                values[valuesById[6] = "ZE"] = 6;
                return values;
            })();

            return Selectivity;
        })();

        return ProductMeasurement;
    })();

    ord.DateTime = (function() {

        /**
         * Properties of a DateTime.
         * @memberof ord
         * @interface IDateTime
         * @property {string|null} [value] DateTime value
         */

        /**
         * Constructs a new DateTime.
         * @memberof ord
         * @classdesc Represents a DateTime.
         * @implements IDateTime
         * @constructor
         * @param {ord.IDateTime=} [properties] Properties to set
         */
        function DateTime(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DateTime value.
         * @member {string} value
         * @memberof ord.DateTime
         * @instance
         */
        DateTime.prototype.value = "";

        /**
         * Creates a new DateTime instance using the specified properties.
         * @function create
         * @memberof ord.DateTime
         * @static
         * @param {ord.IDateTime=} [properties] Properties to set
         * @returns {ord.DateTime} DateTime instance
         */
        DateTime.create = function create(properties) {
            return new DateTime(properties);
        };

        /**
         * Encodes the specified DateTime message. Does not implicitly {@link ord.DateTime.verify|verify} messages.
         * @function encode
         * @memberof ord.DateTime
         * @static
         * @param {ord.IDateTime} message DateTime message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DateTime.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified DateTime message, length delimited. Does not implicitly {@link ord.DateTime.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.DateTime
         * @static
         * @param {ord.IDateTime} message DateTime message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DateTime.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DateTime message from the specified reader or buffer.
         * @function decode
         * @memberof ord.DateTime
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.DateTime} DateTime
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DateTime.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.DateTime();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.value = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DateTime message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.DateTime
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.DateTime} DateTime
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DateTime.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DateTime message.
         * @function verify
         * @memberof ord.DateTime
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DateTime.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };

        /**
         * Creates a DateTime message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.DateTime
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.DateTime} DateTime
         */
        DateTime.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.DateTime)
                return object;
            let message = new $root.ord.DateTime();
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a DateTime message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.DateTime
         * @static
         * @param {ord.DateTime} message DateTime
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DateTime.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.value = "";
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this DateTime to JSON.
         * @function toJSON
         * @memberof ord.DateTime
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DateTime.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for DateTime
         * @function getTypeUrl
         * @memberof ord.DateTime
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        DateTime.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.DateTime";
        };

        return DateTime;
    })();

    ord.Analysis = (function() {

        /**
         * Properties of an Analysis.
         * @memberof ord
         * @interface IAnalysis
         * @property {ord.Analysis.AnalysisType|null} [type] Analysis type
         * @property {string|null} [details] Analysis details
         * @property {number|null} [chmoId] Analysis chmoId
         * @property {boolean|null} [isOfIsolatedSpecies] Analysis isOfIsolatedSpecies
         * @property {Object.<string,ord.IData>|null} [data] Analysis data
         * @property {string|null} [instrumentManufacturer] Analysis instrumentManufacturer
         * @property {ord.IDateTime|null} [instrumentLastCalibrated] Analysis instrumentLastCalibrated
         */

        /**
         * Constructs a new Analysis.
         * @memberof ord
         * @classdesc Represents an Analysis.
         * @implements IAnalysis
         * @constructor
         * @param {ord.IAnalysis=} [properties] Properties to set
         */
        function Analysis(properties) {
            this.data = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Analysis type.
         * @member {ord.Analysis.AnalysisType} type
         * @memberof ord.Analysis
         * @instance
         */
        Analysis.prototype.type = 0;

        /**
         * Analysis details.
         * @member {string} details
         * @memberof ord.Analysis
         * @instance
         */
        Analysis.prototype.details = "";

        /**
         * Analysis chmoId.
         * @member {number} chmoId
         * @memberof ord.Analysis
         * @instance
         */
        Analysis.prototype.chmoId = 0;

        /**
         * Analysis isOfIsolatedSpecies.
         * @member {boolean|null|undefined} isOfIsolatedSpecies
         * @memberof ord.Analysis
         * @instance
         */
        Analysis.prototype.isOfIsolatedSpecies = null;

        /**
         * Analysis data.
         * @member {Object.<string,ord.IData>} data
         * @memberof ord.Analysis
         * @instance
         */
        Analysis.prototype.data = $util.emptyObject;

        /**
         * Analysis instrumentManufacturer.
         * @member {string} instrumentManufacturer
         * @memberof ord.Analysis
         * @instance
         */
        Analysis.prototype.instrumentManufacturer = "";

        /**
         * Analysis instrumentLastCalibrated.
         * @member {ord.IDateTime|null|undefined} instrumentLastCalibrated
         * @memberof ord.Analysis
         * @instance
         */
        Analysis.prototype.instrumentLastCalibrated = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Analysis.prototype, "_isOfIsolatedSpecies", {
            get: $util.oneOfGetter($oneOfFields = ["isOfIsolatedSpecies"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Analysis instance using the specified properties.
         * @function create
         * @memberof ord.Analysis
         * @static
         * @param {ord.IAnalysis=} [properties] Properties to set
         * @returns {ord.Analysis} Analysis instance
         */
        Analysis.create = function create(properties) {
            return new Analysis(properties);
        };

        /**
         * Encodes the specified Analysis message. Does not implicitly {@link ord.Analysis.verify|verify} messages.
         * @function encode
         * @memberof ord.Analysis
         * @static
         * @param {ord.IAnalysis} message Analysis message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Analysis.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
            if (message.chmoId != null && Object.hasOwnProperty.call(message, "chmoId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.chmoId);
            if (message.isOfIsolatedSpecies != null && Object.hasOwnProperty.call(message, "isOfIsolatedSpecies"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isOfIsolatedSpecies);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                for (let keys = Object.keys(message.data), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 5, wireType 2 =*/42).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.ord.Data.encode(message.data[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.instrumentManufacturer != null && Object.hasOwnProperty.call(message, "instrumentManufacturer"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.instrumentManufacturer);
            if (message.instrumentLastCalibrated != null && Object.hasOwnProperty.call(message, "instrumentLastCalibrated"))
                $root.ord.DateTime.encode(message.instrumentLastCalibrated, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Analysis message, length delimited. Does not implicitly {@link ord.Analysis.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.Analysis
         * @static
         * @param {ord.IAnalysis} message Analysis message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Analysis.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Analysis message from the specified reader or buffer.
         * @function decode
         * @memberof ord.Analysis
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.Analysis} Analysis
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Analysis.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.Analysis(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.details = reader.string();
                        break;
                    }
                case 3: {
                        message.chmoId = reader.int32();
                        break;
                    }
                case 4: {
                        message.isOfIsolatedSpecies = reader.bool();
                        break;
                    }
                case 5: {
                        if (message.data === $util.emptyObject)
                            message.data = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.ord.Data.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.data[key] = value;
                        break;
                    }
                case 6: {
                        message.instrumentManufacturer = reader.string();
                        break;
                    }
                case 7: {
                        message.instrumentLastCalibrated = $root.ord.DateTime.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Analysis message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.Analysis
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.Analysis} Analysis
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Analysis.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Analysis message.
         * @function verify
         * @memberof ord.Analysis
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Analysis.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                    break;
                }
            if (message.details != null && message.hasOwnProperty("details"))
                if (!$util.isString(message.details))
                    return "details: string expected";
            if (message.chmoId != null && message.hasOwnProperty("chmoId"))
                if (!$util.isInteger(message.chmoId))
                    return "chmoId: integer expected";
            if (message.isOfIsolatedSpecies != null && message.hasOwnProperty("isOfIsolatedSpecies")) {
                properties._isOfIsolatedSpecies = 1;
                if (typeof message.isOfIsolatedSpecies !== "boolean")
                    return "isOfIsolatedSpecies: boolean expected";
            }
            if (message.data != null && message.hasOwnProperty("data")) {
                if (!$util.isObject(message.data))
                    return "data: object expected";
                let key = Object.keys(message.data);
                for (let i = 0; i < key.length; ++i) {
                    let error = $root.ord.Data.verify(message.data[key[i]]);
                    if (error)
                        return "data." + error;
                }
            }
            if (message.instrumentManufacturer != null && message.hasOwnProperty("instrumentManufacturer"))
                if (!$util.isString(message.instrumentManufacturer))
                    return "instrumentManufacturer: string expected";
            if (message.instrumentLastCalibrated != null && message.hasOwnProperty("instrumentLastCalibrated")) {
                let error = $root.ord.DateTime.verify(message.instrumentLastCalibrated);
                if (error)
                    return "instrumentLastCalibrated." + error;
            }
            return null;
        };

        /**
         * Creates an Analysis message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.Analysis
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.Analysis} Analysis
         */
        Analysis.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.Analysis)
                return object;
            let message = new $root.ord.Analysis();
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.type = 0;
                break;
            case "CUSTOM":
            case 1:
                message.type = 1;
                break;
            case "LC":
            case 2:
                message.type = 2;
                break;
            case "GC":
            case 3:
                message.type = 3;
                break;
            case "IR":
            case 4:
                message.type = 4;
                break;
            case "NMR_1H":
            case 5:
                message.type = 5;
                break;
            case "NMR_13C":
            case 6:
                message.type = 6;
                break;
            case "NMR_OTHER":
            case 7:
                message.type = 7;
                break;
            case "MP":
            case 8:
                message.type = 8;
                break;
            case "UV":
            case 9:
                message.type = 9;
                break;
            case "TLC":
            case 10:
                message.type = 10;
                break;
            case "MS":
            case 11:
                message.type = 11;
                break;
            case "HRMS":
            case 12:
                message.type = 12;
                break;
            case "MSMS":
            case 13:
                message.type = 13;
                break;
            case "WEIGHT":
            case 14:
                message.type = 14;
                break;
            case "LCMS":
            case 15:
                message.type = 15;
                break;
            case "GCMS":
            case 16:
                message.type = 16;
                break;
            case "ELSD":
            case 17:
                message.type = 17;
                break;
            case "CD":
            case 18:
                message.type = 18;
                break;
            case "SFC":
            case 19:
                message.type = 19;
                break;
            case "EPR":
            case 20:
                message.type = 20;
                break;
            case "XRD":
            case 21:
                message.type = 21;
                break;
            case "RAMAN":
            case 22:
                message.type = 22;
                break;
            case "ED":
            case 23:
                message.type = 23;
                break;
            case "OPTICAL_ROTATION":
            case 24:
                message.type = 24;
                break;
            case "CAD":
            case 25:
                message.type = 25;
                break;
            }
            if (object.details != null)
                message.details = String(object.details);
            if (object.chmoId != null)
                message.chmoId = object.chmoId | 0;
            if (object.isOfIsolatedSpecies != null)
                message.isOfIsolatedSpecies = Boolean(object.isOfIsolatedSpecies);
            if (object.data) {
                if (typeof object.data !== "object")
                    throw TypeError(".ord.Analysis.data: object expected");
                message.data = {};
                for (let keys = Object.keys(object.data), i = 0; i < keys.length; ++i) {
                    if (typeof object.data[keys[i]] !== "object")
                        throw TypeError(".ord.Analysis.data: object expected");
                    message.data[keys[i]] = $root.ord.Data.fromObject(object.data[keys[i]]);
                }
            }
            if (object.instrumentManufacturer != null)
                message.instrumentManufacturer = String(object.instrumentManufacturer);
            if (object.instrumentLastCalibrated != null) {
                if (typeof object.instrumentLastCalibrated !== "object")
                    throw TypeError(".ord.Analysis.instrumentLastCalibrated: object expected");
                message.instrumentLastCalibrated = $root.ord.DateTime.fromObject(object.instrumentLastCalibrated);
            }
            return message;
        };

        /**
         * Creates a plain object from an Analysis message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.Analysis
         * @static
         * @param {ord.Analysis} message Analysis
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Analysis.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.objects || options.defaults)
                object.data = {};
            if (options.defaults) {
                object.type = options.enums === String ? "UNSPECIFIED" : 0;
                object.details = "";
                object.chmoId = 0;
                object.instrumentManufacturer = "";
                object.instrumentLastCalibrated = null;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.ord.Analysis.AnalysisType[message.type] === undefined ? message.type : $root.ord.Analysis.AnalysisType[message.type] : message.type;
            if (message.details != null && message.hasOwnProperty("details"))
                object.details = message.details;
            if (message.chmoId != null && message.hasOwnProperty("chmoId"))
                object.chmoId = message.chmoId;
            if (message.isOfIsolatedSpecies != null && message.hasOwnProperty("isOfIsolatedSpecies")) {
                object.isOfIsolatedSpecies = message.isOfIsolatedSpecies;
                if (options.oneofs)
                    object._isOfIsolatedSpecies = "isOfIsolatedSpecies";
            }
            let keys2;
            if (message.data && (keys2 = Object.keys(message.data)).length) {
                object.data = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.data[keys2[j]] = $root.ord.Data.toObject(message.data[keys2[j]], options);
            }
            if (message.instrumentManufacturer != null && message.hasOwnProperty("instrumentManufacturer"))
                object.instrumentManufacturer = message.instrumentManufacturer;
            if (message.instrumentLastCalibrated != null && message.hasOwnProperty("instrumentLastCalibrated"))
                object.instrumentLastCalibrated = $root.ord.DateTime.toObject(message.instrumentLastCalibrated, options);
            return object;
        };

        /**
         * Converts this Analysis to JSON.
         * @function toJSON
         * @memberof ord.Analysis
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Analysis.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Analysis
         * @function getTypeUrl
         * @memberof ord.Analysis
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Analysis.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.Analysis";
        };

        /**
         * AnalysisType enum.
         * @name ord.Analysis.AnalysisType
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} CUSTOM=1 CUSTOM value
         * @property {number} LC=2 LC value
         * @property {number} GC=3 GC value
         * @property {number} IR=4 IR value
         * @property {number} NMR_1H=5 NMR_1H value
         * @property {number} NMR_13C=6 NMR_13C value
         * @property {number} NMR_OTHER=7 NMR_OTHER value
         * @property {number} MP=8 MP value
         * @property {number} UV=9 UV value
         * @property {number} TLC=10 TLC value
         * @property {number} MS=11 MS value
         * @property {number} HRMS=12 HRMS value
         * @property {number} MSMS=13 MSMS value
         * @property {number} WEIGHT=14 WEIGHT value
         * @property {number} LCMS=15 LCMS value
         * @property {number} GCMS=16 GCMS value
         * @property {number} ELSD=17 ELSD value
         * @property {number} CD=18 CD value
         * @property {number} SFC=19 SFC value
         * @property {number} EPR=20 EPR value
         * @property {number} XRD=21 XRD value
         * @property {number} RAMAN=22 RAMAN value
         * @property {number} ED=23 ED value
         * @property {number} OPTICAL_ROTATION=24 OPTICAL_ROTATION value
         * @property {number} CAD=25 CAD value
         */
        Analysis.AnalysisType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "CUSTOM"] = 1;
            values[valuesById[2] = "LC"] = 2;
            values[valuesById[3] = "GC"] = 3;
            values[valuesById[4] = "IR"] = 4;
            values[valuesById[5] = "NMR_1H"] = 5;
            values[valuesById[6] = "NMR_13C"] = 6;
            values[valuesById[7] = "NMR_OTHER"] = 7;
            values[valuesById[8] = "MP"] = 8;
            values[valuesById[9] = "UV"] = 9;
            values[valuesById[10] = "TLC"] = 10;
            values[valuesById[11] = "MS"] = 11;
            values[valuesById[12] = "HRMS"] = 12;
            values[valuesById[13] = "MSMS"] = 13;
            values[valuesById[14] = "WEIGHT"] = 14;
            values[valuesById[15] = "LCMS"] = 15;
            values[valuesById[16] = "GCMS"] = 16;
            values[valuesById[17] = "ELSD"] = 17;
            values[valuesById[18] = "CD"] = 18;
            values[valuesById[19] = "SFC"] = 19;
            values[valuesById[20] = "EPR"] = 20;
            values[valuesById[21] = "XRD"] = 21;
            values[valuesById[22] = "RAMAN"] = 22;
            values[valuesById[23] = "ED"] = 23;
            values[valuesById[24] = "OPTICAL_ROTATION"] = 24;
            values[valuesById[25] = "CAD"] = 25;
            return values;
        })();

        return Analysis;
    })();

    ord.ReactionProvenance = (function() {

        /**
         * Properties of a ReactionProvenance.
         * @memberof ord
         * @interface IReactionProvenance
         * @property {ord.IPerson|null} [experimenter] ReactionProvenance experimenter
         * @property {string|null} [city] ReactionProvenance city
         * @property {ord.IDateTime|null} [experimentStart] ReactionProvenance experimentStart
         * @property {string|null} [doi] ReactionProvenance doi
         * @property {string|null} [patent] ReactionProvenance patent
         * @property {string|null} [publicationUrl] ReactionProvenance publicationUrl
         * @property {ord.IRecordEvent|null} [recordCreated] ReactionProvenance recordCreated
         * @property {Array.<ord.IRecordEvent>|null} [recordModified] ReactionProvenance recordModified
         * @property {Object.<string,ord.IData>|null} [reactionMetadata] ReactionProvenance reactionMetadata
         * @property {boolean|null} [isMined] ReactionProvenance isMined
         */

        /**
         * Constructs a new ReactionProvenance.
         * @memberof ord
         * @classdesc Represents a ReactionProvenance.
         * @implements IReactionProvenance
         * @constructor
         * @param {ord.IReactionProvenance=} [properties] Properties to set
         */
        function ReactionProvenance(properties) {
            this.recordModified = [];
            this.reactionMetadata = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReactionProvenance experimenter.
         * @member {ord.IPerson|null|undefined} experimenter
         * @memberof ord.ReactionProvenance
         * @instance
         */
        ReactionProvenance.prototype.experimenter = null;

        /**
         * ReactionProvenance city.
         * @member {string} city
         * @memberof ord.ReactionProvenance
         * @instance
         */
        ReactionProvenance.prototype.city = "";

        /**
         * ReactionProvenance experimentStart.
         * @member {ord.IDateTime|null|undefined} experimentStart
         * @memberof ord.ReactionProvenance
         * @instance
         */
        ReactionProvenance.prototype.experimentStart = null;

        /**
         * ReactionProvenance doi.
         * @member {string} doi
         * @memberof ord.ReactionProvenance
         * @instance
         */
        ReactionProvenance.prototype.doi = "";

        /**
         * ReactionProvenance patent.
         * @member {string} patent
         * @memberof ord.ReactionProvenance
         * @instance
         */
        ReactionProvenance.prototype.patent = "";

        /**
         * ReactionProvenance publicationUrl.
         * @member {string} publicationUrl
         * @memberof ord.ReactionProvenance
         * @instance
         */
        ReactionProvenance.prototype.publicationUrl = "";

        /**
         * ReactionProvenance recordCreated.
         * @member {ord.IRecordEvent|null|undefined} recordCreated
         * @memberof ord.ReactionProvenance
         * @instance
         */
        ReactionProvenance.prototype.recordCreated = null;

        /**
         * ReactionProvenance recordModified.
         * @member {Array.<ord.IRecordEvent>} recordModified
         * @memberof ord.ReactionProvenance
         * @instance
         */
        ReactionProvenance.prototype.recordModified = $util.emptyArray;

        /**
         * ReactionProvenance reactionMetadata.
         * @member {Object.<string,ord.IData>} reactionMetadata
         * @memberof ord.ReactionProvenance
         * @instance
         */
        ReactionProvenance.prototype.reactionMetadata = $util.emptyObject;

        /**
         * ReactionProvenance isMined.
         * @member {boolean|null|undefined} isMined
         * @memberof ord.ReactionProvenance
         * @instance
         */
        ReactionProvenance.prototype.isMined = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(ReactionProvenance.prototype, "_isMined", {
            get: $util.oneOfGetter($oneOfFields = ["isMined"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ReactionProvenance instance using the specified properties.
         * @function create
         * @memberof ord.ReactionProvenance
         * @static
         * @param {ord.IReactionProvenance=} [properties] Properties to set
         * @returns {ord.ReactionProvenance} ReactionProvenance instance
         */
        ReactionProvenance.create = function create(properties) {
            return new ReactionProvenance(properties);
        };

        /**
         * Encodes the specified ReactionProvenance message. Does not implicitly {@link ord.ReactionProvenance.verify|verify} messages.
         * @function encode
         * @memberof ord.ReactionProvenance
         * @static
         * @param {ord.IReactionProvenance} message ReactionProvenance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReactionProvenance.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.experimenter != null && Object.hasOwnProperty.call(message, "experimenter"))
                $root.ord.Person.encode(message.experimenter, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.city != null && Object.hasOwnProperty.call(message, "city"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.city);
            if (message.experimentStart != null && Object.hasOwnProperty.call(message, "experimentStart"))
                $root.ord.DateTime.encode(message.experimentStart, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.doi != null && Object.hasOwnProperty.call(message, "doi"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.doi);
            if (message.patent != null && Object.hasOwnProperty.call(message, "patent"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.patent);
            if (message.publicationUrl != null && Object.hasOwnProperty.call(message, "publicationUrl"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.publicationUrl);
            if (message.recordCreated != null && Object.hasOwnProperty.call(message, "recordCreated"))
                $root.ord.RecordEvent.encode(message.recordCreated, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.recordModified != null && message.recordModified.length)
                for (let i = 0; i < message.recordModified.length; ++i)
                    $root.ord.RecordEvent.encode(message.recordModified[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.reactionMetadata != null && Object.hasOwnProperty.call(message, "reactionMetadata"))
                for (let keys = Object.keys(message.reactionMetadata), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 9, wireType 2 =*/74).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.ord.Data.encode(message.reactionMetadata[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.isMined != null && Object.hasOwnProperty.call(message, "isMined"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.isMined);
            return writer;
        };

        /**
         * Encodes the specified ReactionProvenance message, length delimited. Does not implicitly {@link ord.ReactionProvenance.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.ReactionProvenance
         * @static
         * @param {ord.IReactionProvenance} message ReactionProvenance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReactionProvenance.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReactionProvenance message from the specified reader or buffer.
         * @function decode
         * @memberof ord.ReactionProvenance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.ReactionProvenance} ReactionProvenance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReactionProvenance.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.ReactionProvenance(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.experimenter = $root.ord.Person.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.city = reader.string();
                        break;
                    }
                case 3: {
                        message.experimentStart = $root.ord.DateTime.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.doi = reader.string();
                        break;
                    }
                case 5: {
                        message.patent = reader.string();
                        break;
                    }
                case 6: {
                        message.publicationUrl = reader.string();
                        break;
                    }
                case 7: {
                        message.recordCreated = $root.ord.RecordEvent.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        if (!(message.recordModified && message.recordModified.length))
                            message.recordModified = [];
                        message.recordModified.push($root.ord.RecordEvent.decode(reader, reader.uint32()));
                        break;
                    }
                case 9: {
                        if (message.reactionMetadata === $util.emptyObject)
                            message.reactionMetadata = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.ord.Data.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.reactionMetadata[key] = value;
                        break;
                    }
                case 10: {
                        message.isMined = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReactionProvenance message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.ReactionProvenance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.ReactionProvenance} ReactionProvenance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReactionProvenance.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReactionProvenance message.
         * @function verify
         * @memberof ord.ReactionProvenance
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReactionProvenance.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.experimenter != null && message.hasOwnProperty("experimenter")) {
                let error = $root.ord.Person.verify(message.experimenter);
                if (error)
                    return "experimenter." + error;
            }
            if (message.city != null && message.hasOwnProperty("city"))
                if (!$util.isString(message.city))
                    return "city: string expected";
            if (message.experimentStart != null && message.hasOwnProperty("experimentStart")) {
                let error = $root.ord.DateTime.verify(message.experimentStart);
                if (error)
                    return "experimentStart." + error;
            }
            if (message.doi != null && message.hasOwnProperty("doi"))
                if (!$util.isString(message.doi))
                    return "doi: string expected";
            if (message.patent != null && message.hasOwnProperty("patent"))
                if (!$util.isString(message.patent))
                    return "patent: string expected";
            if (message.publicationUrl != null && message.hasOwnProperty("publicationUrl"))
                if (!$util.isString(message.publicationUrl))
                    return "publicationUrl: string expected";
            if (message.recordCreated != null && message.hasOwnProperty("recordCreated")) {
                let error = $root.ord.RecordEvent.verify(message.recordCreated);
                if (error)
                    return "recordCreated." + error;
            }
            if (message.recordModified != null && message.hasOwnProperty("recordModified")) {
                if (!Array.isArray(message.recordModified))
                    return "recordModified: array expected";
                for (let i = 0; i < message.recordModified.length; ++i) {
                    let error = $root.ord.RecordEvent.verify(message.recordModified[i]);
                    if (error)
                        return "recordModified." + error;
                }
            }
            if (message.reactionMetadata != null && message.hasOwnProperty("reactionMetadata")) {
                if (!$util.isObject(message.reactionMetadata))
                    return "reactionMetadata: object expected";
                let key = Object.keys(message.reactionMetadata);
                for (let i = 0; i < key.length; ++i) {
                    let error = $root.ord.Data.verify(message.reactionMetadata[key[i]]);
                    if (error)
                        return "reactionMetadata." + error;
                }
            }
            if (message.isMined != null && message.hasOwnProperty("isMined")) {
                properties._isMined = 1;
                if (typeof message.isMined !== "boolean")
                    return "isMined: boolean expected";
            }
            return null;
        };

        /**
         * Creates a ReactionProvenance message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.ReactionProvenance
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.ReactionProvenance} ReactionProvenance
         */
        ReactionProvenance.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.ReactionProvenance)
                return object;
            let message = new $root.ord.ReactionProvenance();
            if (object.experimenter != null) {
                if (typeof object.experimenter !== "object")
                    throw TypeError(".ord.ReactionProvenance.experimenter: object expected");
                message.experimenter = $root.ord.Person.fromObject(object.experimenter);
            }
            if (object.city != null)
                message.city = String(object.city);
            if (object.experimentStart != null) {
                if (typeof object.experimentStart !== "object")
                    throw TypeError(".ord.ReactionProvenance.experimentStart: object expected");
                message.experimentStart = $root.ord.DateTime.fromObject(object.experimentStart);
            }
            if (object.doi != null)
                message.doi = String(object.doi);
            if (object.patent != null)
                message.patent = String(object.patent);
            if (object.publicationUrl != null)
                message.publicationUrl = String(object.publicationUrl);
            if (object.recordCreated != null) {
                if (typeof object.recordCreated !== "object")
                    throw TypeError(".ord.ReactionProvenance.recordCreated: object expected");
                message.recordCreated = $root.ord.RecordEvent.fromObject(object.recordCreated);
            }
            if (object.recordModified) {
                if (!Array.isArray(object.recordModified))
                    throw TypeError(".ord.ReactionProvenance.recordModified: array expected");
                message.recordModified = [];
                for (let i = 0; i < object.recordModified.length; ++i) {
                    if (typeof object.recordModified[i] !== "object")
                        throw TypeError(".ord.ReactionProvenance.recordModified: object expected");
                    message.recordModified[i] = $root.ord.RecordEvent.fromObject(object.recordModified[i]);
                }
            }
            if (object.reactionMetadata) {
                if (typeof object.reactionMetadata !== "object")
                    throw TypeError(".ord.ReactionProvenance.reactionMetadata: object expected");
                message.reactionMetadata = {};
                for (let keys = Object.keys(object.reactionMetadata), i = 0; i < keys.length; ++i) {
                    if (typeof object.reactionMetadata[keys[i]] !== "object")
                        throw TypeError(".ord.ReactionProvenance.reactionMetadata: object expected");
                    message.reactionMetadata[keys[i]] = $root.ord.Data.fromObject(object.reactionMetadata[keys[i]]);
                }
            }
            if (object.isMined != null)
                message.isMined = Boolean(object.isMined);
            return message;
        };

        /**
         * Creates a plain object from a ReactionProvenance message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.ReactionProvenance
         * @static
         * @param {ord.ReactionProvenance} message ReactionProvenance
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReactionProvenance.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.recordModified = [];
            if (options.objects || options.defaults)
                object.reactionMetadata = {};
            if (options.defaults) {
                object.experimenter = null;
                object.city = "";
                object.experimentStart = null;
                object.doi = "";
                object.patent = "";
                object.publicationUrl = "";
                object.recordCreated = null;
            }
            if (message.experimenter != null && message.hasOwnProperty("experimenter"))
                object.experimenter = $root.ord.Person.toObject(message.experimenter, options);
            if (message.city != null && message.hasOwnProperty("city"))
                object.city = message.city;
            if (message.experimentStart != null && message.hasOwnProperty("experimentStart"))
                object.experimentStart = $root.ord.DateTime.toObject(message.experimentStart, options);
            if (message.doi != null && message.hasOwnProperty("doi"))
                object.doi = message.doi;
            if (message.patent != null && message.hasOwnProperty("patent"))
                object.patent = message.patent;
            if (message.publicationUrl != null && message.hasOwnProperty("publicationUrl"))
                object.publicationUrl = message.publicationUrl;
            if (message.recordCreated != null && message.hasOwnProperty("recordCreated"))
                object.recordCreated = $root.ord.RecordEvent.toObject(message.recordCreated, options);
            if (message.recordModified && message.recordModified.length) {
                object.recordModified = [];
                for (let j = 0; j < message.recordModified.length; ++j)
                    object.recordModified[j] = $root.ord.RecordEvent.toObject(message.recordModified[j], options);
            }
            let keys2;
            if (message.reactionMetadata && (keys2 = Object.keys(message.reactionMetadata)).length) {
                object.reactionMetadata = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.reactionMetadata[keys2[j]] = $root.ord.Data.toObject(message.reactionMetadata[keys2[j]], options);
            }
            if (message.isMined != null && message.hasOwnProperty("isMined")) {
                object.isMined = message.isMined;
                if (options.oneofs)
                    object._isMined = "isMined";
            }
            return object;
        };

        /**
         * Converts this ReactionProvenance to JSON.
         * @function toJSON
         * @memberof ord.ReactionProvenance
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReactionProvenance.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ReactionProvenance
         * @function getTypeUrl
         * @memberof ord.ReactionProvenance
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ReactionProvenance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.ReactionProvenance";
        };

        return ReactionProvenance;
    })();

    ord.Person = (function() {

        /**
         * Properties of a Person.
         * @memberof ord
         * @interface IPerson
         * @property {string|null} [username] Person username
         * @property {string|null} [name] Person name
         * @property {string|null} [orcid] Person orcid
         * @property {string|null} [organization] Person organization
         * @property {string|null} [email] Person email
         */

        /**
         * Constructs a new Person.
         * @memberof ord
         * @classdesc Represents a Person.
         * @implements IPerson
         * @constructor
         * @param {ord.IPerson=} [properties] Properties to set
         */
        function Person(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Person username.
         * @member {string} username
         * @memberof ord.Person
         * @instance
         */
        Person.prototype.username = "";

        /**
         * Person name.
         * @member {string} name
         * @memberof ord.Person
         * @instance
         */
        Person.prototype.name = "";

        /**
         * Person orcid.
         * @member {string} orcid
         * @memberof ord.Person
         * @instance
         */
        Person.prototype.orcid = "";

        /**
         * Person organization.
         * @member {string} organization
         * @memberof ord.Person
         * @instance
         */
        Person.prototype.organization = "";

        /**
         * Person email.
         * @member {string} email
         * @memberof ord.Person
         * @instance
         */
        Person.prototype.email = "";

        /**
         * Creates a new Person instance using the specified properties.
         * @function create
         * @memberof ord.Person
         * @static
         * @param {ord.IPerson=} [properties] Properties to set
         * @returns {ord.Person} Person instance
         */
        Person.create = function create(properties) {
            return new Person(properties);
        };

        /**
         * Encodes the specified Person message. Does not implicitly {@link ord.Person.verify|verify} messages.
         * @function encode
         * @memberof ord.Person
         * @static
         * @param {ord.IPerson} message Person message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Person.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.username);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.orcid != null && Object.hasOwnProperty.call(message, "orcid"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.orcid);
            if (message.organization != null && Object.hasOwnProperty.call(message, "organization"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.organization);
            if (message.email != null && Object.hasOwnProperty.call(message, "email"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.email);
            return writer;
        };

        /**
         * Encodes the specified Person message, length delimited. Does not implicitly {@link ord.Person.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.Person
         * @static
         * @param {ord.IPerson} message Person message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Person.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Person message from the specified reader or buffer.
         * @function decode
         * @memberof ord.Person
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.Person} Person
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Person.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.Person();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.username = reader.string();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                case 3: {
                        message.orcid = reader.string();
                        break;
                    }
                case 4: {
                        message.organization = reader.string();
                        break;
                    }
                case 5: {
                        message.email = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Person message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.Person
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.Person} Person
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Person.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Person message.
         * @function verify
         * @memberof ord.Person
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Person.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.orcid != null && message.hasOwnProperty("orcid"))
                if (!$util.isString(message.orcid))
                    return "orcid: string expected";
            if (message.organization != null && message.hasOwnProperty("organization"))
                if (!$util.isString(message.organization))
                    return "organization: string expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            return null;
        };

        /**
         * Creates a Person message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.Person
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.Person} Person
         */
        Person.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.Person)
                return object;
            let message = new $root.ord.Person();
            if (object.username != null)
                message.username = String(object.username);
            if (object.name != null)
                message.name = String(object.name);
            if (object.orcid != null)
                message.orcid = String(object.orcid);
            if (object.organization != null)
                message.organization = String(object.organization);
            if (object.email != null)
                message.email = String(object.email);
            return message;
        };

        /**
         * Creates a plain object from a Person message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.Person
         * @static
         * @param {ord.Person} message Person
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Person.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.username = "";
                object.name = "";
                object.orcid = "";
                object.organization = "";
                object.email = "";
            }
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.orcid != null && message.hasOwnProperty("orcid"))
                object.orcid = message.orcid;
            if (message.organization != null && message.hasOwnProperty("organization"))
                object.organization = message.organization;
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            return object;
        };

        /**
         * Converts this Person to JSON.
         * @function toJSON
         * @memberof ord.Person
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Person.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Person
         * @function getTypeUrl
         * @memberof ord.Person
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Person.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.Person";
        };

        return Person;
    })();

    ord.RecordEvent = (function() {

        /**
         * Properties of a RecordEvent.
         * @memberof ord
         * @interface IRecordEvent
         * @property {ord.IDateTime|null} [time] RecordEvent time
         * @property {ord.IPerson|null} [person] RecordEvent person
         * @property {string|null} [details] RecordEvent details
         */

        /**
         * Constructs a new RecordEvent.
         * @memberof ord
         * @classdesc Represents a RecordEvent.
         * @implements IRecordEvent
         * @constructor
         * @param {ord.IRecordEvent=} [properties] Properties to set
         */
        function RecordEvent(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RecordEvent time.
         * @member {ord.IDateTime|null|undefined} time
         * @memberof ord.RecordEvent
         * @instance
         */
        RecordEvent.prototype.time = null;

        /**
         * RecordEvent person.
         * @member {ord.IPerson|null|undefined} person
         * @memberof ord.RecordEvent
         * @instance
         */
        RecordEvent.prototype.person = null;

        /**
         * RecordEvent details.
         * @member {string} details
         * @memberof ord.RecordEvent
         * @instance
         */
        RecordEvent.prototype.details = "";

        /**
         * Creates a new RecordEvent instance using the specified properties.
         * @function create
         * @memberof ord.RecordEvent
         * @static
         * @param {ord.IRecordEvent=} [properties] Properties to set
         * @returns {ord.RecordEvent} RecordEvent instance
         */
        RecordEvent.create = function create(properties) {
            return new RecordEvent(properties);
        };

        /**
         * Encodes the specified RecordEvent message. Does not implicitly {@link ord.RecordEvent.verify|verify} messages.
         * @function encode
         * @memberof ord.RecordEvent
         * @static
         * @param {ord.IRecordEvent} message RecordEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                $root.ord.DateTime.encode(message.time, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.person != null && Object.hasOwnProperty.call(message, "person"))
                $root.ord.Person.encode(message.person, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.details);
            return writer;
        };

        /**
         * Encodes the specified RecordEvent message, length delimited. Does not implicitly {@link ord.RecordEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.RecordEvent
         * @static
         * @param {ord.IRecordEvent} message RecordEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RecordEvent message from the specified reader or buffer.
         * @function decode
         * @memberof ord.RecordEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.RecordEvent} RecordEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.RecordEvent();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.time = $root.ord.DateTime.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.person = $root.ord.Person.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.details = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RecordEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.RecordEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.RecordEvent} RecordEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RecordEvent message.
         * @function verify
         * @memberof ord.RecordEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RecordEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.time != null && message.hasOwnProperty("time")) {
                let error = $root.ord.DateTime.verify(message.time);
                if (error)
                    return "time." + error;
            }
            if (message.person != null && message.hasOwnProperty("person")) {
                let error = $root.ord.Person.verify(message.person);
                if (error)
                    return "person." + error;
            }
            if (message.details != null && message.hasOwnProperty("details"))
                if (!$util.isString(message.details))
                    return "details: string expected";
            return null;
        };

        /**
         * Creates a RecordEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.RecordEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.RecordEvent} RecordEvent
         */
        RecordEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.RecordEvent)
                return object;
            let message = new $root.ord.RecordEvent();
            if (object.time != null) {
                if (typeof object.time !== "object")
                    throw TypeError(".ord.RecordEvent.time: object expected");
                message.time = $root.ord.DateTime.fromObject(object.time);
            }
            if (object.person != null) {
                if (typeof object.person !== "object")
                    throw TypeError(".ord.RecordEvent.person: object expected");
                message.person = $root.ord.Person.fromObject(object.person);
            }
            if (object.details != null)
                message.details = String(object.details);
            return message;
        };

        /**
         * Creates a plain object from a RecordEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.RecordEvent
         * @static
         * @param {ord.RecordEvent} message RecordEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RecordEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.time = null;
                object.person = null;
                object.details = "";
            }
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = $root.ord.DateTime.toObject(message.time, options);
            if (message.person != null && message.hasOwnProperty("person"))
                object.person = $root.ord.Person.toObject(message.person, options);
            if (message.details != null && message.hasOwnProperty("details"))
                object.details = message.details;
            return object;
        };

        /**
         * Converts this RecordEvent to JSON.
         * @function toJSON
         * @memberof ord.RecordEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RecordEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RecordEvent
         * @function getTypeUrl
         * @memberof ord.RecordEvent
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RecordEvent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.RecordEvent";
        };

        return RecordEvent;
    })();

    ord.Time = (function() {

        /**
         * Properties of a Time.
         * @memberof ord
         * @interface ITime
         * @property {number|null} [value] Time value
         * @property {number|null} [precision] Time precision
         * @property {ord.Time.TimeUnit|null} [units] Time units
         */

        /**
         * Constructs a new Time.
         * @memberof ord
         * @classdesc To allow users to describe synthetic processes in whatever units they find
         * most natural, we define a fixed list of allowable units for each measurement
         * type. Upon submission to a centralized database, or using a validation and
         * canonicalization script, we will convert all values to the default units
         * (the first nonzero item in each enum).
         * 
         * Each message also contains a `precision` field, which specifies the precision
         * of the measurement in the same units as the measurement itself. Often the
         * precision will be the standard deviation from an instrument calibration.
         * @implements ITime
         * @constructor
         * @param {ord.ITime=} [properties] Properties to set
         */
        function Time(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Time value.
         * @member {number|null|undefined} value
         * @memberof ord.Time
         * @instance
         */
        Time.prototype.value = null;

        /**
         * Time precision.
         * @member {number|null|undefined} precision
         * @memberof ord.Time
         * @instance
         */
        Time.prototype.precision = null;

        /**
         * Time units.
         * @member {ord.Time.TimeUnit} units
         * @memberof ord.Time
         * @instance
         */
        Time.prototype.units = 0;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Time.prototype, "_value", {
            get: $util.oneOfGetter($oneOfFields = ["value"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Time.prototype, "_precision", {
            get: $util.oneOfGetter($oneOfFields = ["precision"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Time instance using the specified properties.
         * @function create
         * @memberof ord.Time
         * @static
         * @param {ord.ITime=} [properties] Properties to set
         * @returns {ord.Time} Time instance
         */
        Time.create = function create(properties) {
            return new Time(properties);
        };

        /**
         * Encodes the specified Time message. Does not implicitly {@link ord.Time.verify|verify} messages.
         * @function encode
         * @memberof ord.Time
         * @static
         * @param {ord.ITime} message Time message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Time.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.value);
            if (message.precision != null && Object.hasOwnProperty.call(message, "precision"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.precision);
            if (message.units != null && Object.hasOwnProperty.call(message, "units"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.units);
            return writer;
        };

        /**
         * Encodes the specified Time message, length delimited. Does not implicitly {@link ord.Time.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.Time
         * @static
         * @param {ord.ITime} message Time message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Time.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Time message from the specified reader or buffer.
         * @function decode
         * @memberof ord.Time
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.Time} Time
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Time.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.Time();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.value = reader.float();
                        break;
                    }
                case 2: {
                        message.precision = reader.float();
                        break;
                    }
                case 3: {
                        message.units = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Time message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.Time
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.Time} Time
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Time.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Time message.
         * @function verify
         * @memberof ord.Time
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Time.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.value != null && message.hasOwnProperty("value")) {
                properties._value = 1;
                if (typeof message.value !== "number")
                    return "value: number expected";
            }
            if (message.precision != null && message.hasOwnProperty("precision")) {
                properties._precision = 1;
                if (typeof message.precision !== "number")
                    return "precision: number expected";
            }
            if (message.units != null && message.hasOwnProperty("units"))
                switch (message.units) {
                default:
                    return "units: enum value expected";
                case 0:
                case 4:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a Time message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.Time
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.Time} Time
         */
        Time.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.Time)
                return object;
            let message = new $root.ord.Time();
            if (object.value != null)
                message.value = Number(object.value);
            if (object.precision != null)
                message.precision = Number(object.precision);
            switch (object.units) {
            default:
                if (typeof object.units === "number") {
                    message.units = object.units;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.units = 0;
                break;
            case "DAY":
            case 4:
                message.units = 4;
                break;
            case "HOUR":
            case 1:
                message.units = 1;
                break;
            case "MINUTE":
            case 2:
                message.units = 2;
                break;
            case "SECOND":
            case 3:
                message.units = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Time message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.Time
         * @static
         * @param {ord.Time} message Time
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Time.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.units = options.enums === String ? "UNSPECIFIED" : 0;
            if (message.value != null && message.hasOwnProperty("value")) {
                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                if (options.oneofs)
                    object._value = "value";
            }
            if (message.precision != null && message.hasOwnProperty("precision")) {
                object.precision = options.json && !isFinite(message.precision) ? String(message.precision) : message.precision;
                if (options.oneofs)
                    object._precision = "precision";
            }
            if (message.units != null && message.hasOwnProperty("units"))
                object.units = options.enums === String ? $root.ord.Time.TimeUnit[message.units] === undefined ? message.units : $root.ord.Time.TimeUnit[message.units] : message.units;
            return object;
        };

        /**
         * Converts this Time to JSON.
         * @function toJSON
         * @memberof ord.Time
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Time.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Time
         * @function getTypeUrl
         * @memberof ord.Time
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Time.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.Time";
        };

        /**
         * TimeUnit enum.
         * @name ord.Time.TimeUnit
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} DAY=4 DAY value
         * @property {number} HOUR=1 HOUR value
         * @property {number} MINUTE=2 MINUTE value
         * @property {number} SECOND=3 SECOND value
         */
        Time.TimeUnit = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[4] = "DAY"] = 4;
            values[valuesById[1] = "HOUR"] = 1;
            values[valuesById[2] = "MINUTE"] = 2;
            values[valuesById[3] = "SECOND"] = 3;
            return values;
        })();

        return Time;
    })();

    ord.Mass = (function() {

        /**
         * Properties of a Mass.
         * @memberof ord
         * @interface IMass
         * @property {number|null} [value] Mass value
         * @property {number|null} [precision] Mass precision
         * @property {ord.Mass.MassUnit|null} [units] Mass units
         */

        /**
         * Constructs a new Mass.
         * @memberof ord
         * @classdesc Represents a Mass.
         * @implements IMass
         * @constructor
         * @param {ord.IMass=} [properties] Properties to set
         */
        function Mass(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Mass value.
         * @member {number|null|undefined} value
         * @memberof ord.Mass
         * @instance
         */
        Mass.prototype.value = null;

        /**
         * Mass precision.
         * @member {number|null|undefined} precision
         * @memberof ord.Mass
         * @instance
         */
        Mass.prototype.precision = null;

        /**
         * Mass units.
         * @member {ord.Mass.MassUnit} units
         * @memberof ord.Mass
         * @instance
         */
        Mass.prototype.units = 0;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Mass.prototype, "_value", {
            get: $util.oneOfGetter($oneOfFields = ["value"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Mass.prototype, "_precision", {
            get: $util.oneOfGetter($oneOfFields = ["precision"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Mass instance using the specified properties.
         * @function create
         * @memberof ord.Mass
         * @static
         * @param {ord.IMass=} [properties] Properties to set
         * @returns {ord.Mass} Mass instance
         */
        Mass.create = function create(properties) {
            return new Mass(properties);
        };

        /**
         * Encodes the specified Mass message. Does not implicitly {@link ord.Mass.verify|verify} messages.
         * @function encode
         * @memberof ord.Mass
         * @static
         * @param {ord.IMass} message Mass message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Mass.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.value);
            if (message.precision != null && Object.hasOwnProperty.call(message, "precision"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.precision);
            if (message.units != null && Object.hasOwnProperty.call(message, "units"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.units);
            return writer;
        };

        /**
         * Encodes the specified Mass message, length delimited. Does not implicitly {@link ord.Mass.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.Mass
         * @static
         * @param {ord.IMass} message Mass message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Mass.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Mass message from the specified reader or buffer.
         * @function decode
         * @memberof ord.Mass
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.Mass} Mass
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Mass.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.Mass();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.value = reader.float();
                        break;
                    }
                case 2: {
                        message.precision = reader.float();
                        break;
                    }
                case 3: {
                        message.units = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Mass message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.Mass
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.Mass} Mass
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Mass.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Mass message.
         * @function verify
         * @memberof ord.Mass
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Mass.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.value != null && message.hasOwnProperty("value")) {
                properties._value = 1;
                if (typeof message.value !== "number")
                    return "value: number expected";
            }
            if (message.precision != null && message.hasOwnProperty("precision")) {
                properties._precision = 1;
                if (typeof message.precision !== "number")
                    return "precision: number expected";
            }
            if (message.units != null && message.hasOwnProperty("units"))
                switch (message.units) {
                default:
                    return "units: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            return null;
        };

        /**
         * Creates a Mass message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.Mass
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.Mass} Mass
         */
        Mass.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.Mass)
                return object;
            let message = new $root.ord.Mass();
            if (object.value != null)
                message.value = Number(object.value);
            if (object.precision != null)
                message.precision = Number(object.precision);
            switch (object.units) {
            default:
                if (typeof object.units === "number") {
                    message.units = object.units;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.units = 0;
                break;
            case "KILOGRAM":
            case 1:
                message.units = 1;
                break;
            case "GRAM":
            case 2:
                message.units = 2;
                break;
            case "MILLIGRAM":
            case 3:
                message.units = 3;
                break;
            case "MICROGRAM":
            case 4:
                message.units = 4;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Mass message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.Mass
         * @static
         * @param {ord.Mass} message Mass
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Mass.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.units = options.enums === String ? "UNSPECIFIED" : 0;
            if (message.value != null && message.hasOwnProperty("value")) {
                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                if (options.oneofs)
                    object._value = "value";
            }
            if (message.precision != null && message.hasOwnProperty("precision")) {
                object.precision = options.json && !isFinite(message.precision) ? String(message.precision) : message.precision;
                if (options.oneofs)
                    object._precision = "precision";
            }
            if (message.units != null && message.hasOwnProperty("units"))
                object.units = options.enums === String ? $root.ord.Mass.MassUnit[message.units] === undefined ? message.units : $root.ord.Mass.MassUnit[message.units] : message.units;
            return object;
        };

        /**
         * Converts this Mass to JSON.
         * @function toJSON
         * @memberof ord.Mass
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Mass.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Mass
         * @function getTypeUrl
         * @memberof ord.Mass
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Mass.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.Mass";
        };

        /**
         * MassUnit enum.
         * @name ord.Mass.MassUnit
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} KILOGRAM=1 KILOGRAM value
         * @property {number} GRAM=2 GRAM value
         * @property {number} MILLIGRAM=3 MILLIGRAM value
         * @property {number} MICROGRAM=4 MICROGRAM value
         */
        Mass.MassUnit = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "KILOGRAM"] = 1;
            values[valuesById[2] = "GRAM"] = 2;
            values[valuesById[3] = "MILLIGRAM"] = 3;
            values[valuesById[4] = "MICROGRAM"] = 4;
            return values;
        })();

        return Mass;
    })();

    ord.Moles = (function() {

        /**
         * Properties of a Moles.
         * @memberof ord
         * @interface IMoles
         * @property {number|null} [value] Moles value
         * @property {number|null} [precision] Moles precision
         * @property {ord.Moles.MolesUnit|null} [units] Moles units
         */

        /**
         * Constructs a new Moles.
         * @memberof ord
         * @classdesc Represents a Moles.
         * @implements IMoles
         * @constructor
         * @param {ord.IMoles=} [properties] Properties to set
         */
        function Moles(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Moles value.
         * @member {number|null|undefined} value
         * @memberof ord.Moles
         * @instance
         */
        Moles.prototype.value = null;

        /**
         * Moles precision.
         * @member {number|null|undefined} precision
         * @memberof ord.Moles
         * @instance
         */
        Moles.prototype.precision = null;

        /**
         * Moles units.
         * @member {ord.Moles.MolesUnit} units
         * @memberof ord.Moles
         * @instance
         */
        Moles.prototype.units = 0;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Moles.prototype, "_value", {
            get: $util.oneOfGetter($oneOfFields = ["value"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Moles.prototype, "_precision", {
            get: $util.oneOfGetter($oneOfFields = ["precision"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Moles instance using the specified properties.
         * @function create
         * @memberof ord.Moles
         * @static
         * @param {ord.IMoles=} [properties] Properties to set
         * @returns {ord.Moles} Moles instance
         */
        Moles.create = function create(properties) {
            return new Moles(properties);
        };

        /**
         * Encodes the specified Moles message. Does not implicitly {@link ord.Moles.verify|verify} messages.
         * @function encode
         * @memberof ord.Moles
         * @static
         * @param {ord.IMoles} message Moles message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Moles.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.value);
            if (message.precision != null && Object.hasOwnProperty.call(message, "precision"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.precision);
            if (message.units != null && Object.hasOwnProperty.call(message, "units"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.units);
            return writer;
        };

        /**
         * Encodes the specified Moles message, length delimited. Does not implicitly {@link ord.Moles.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.Moles
         * @static
         * @param {ord.IMoles} message Moles message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Moles.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Moles message from the specified reader or buffer.
         * @function decode
         * @memberof ord.Moles
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.Moles} Moles
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Moles.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.Moles();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.value = reader.float();
                        break;
                    }
                case 2: {
                        message.precision = reader.float();
                        break;
                    }
                case 3: {
                        message.units = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Moles message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.Moles
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.Moles} Moles
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Moles.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Moles message.
         * @function verify
         * @memberof ord.Moles
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Moles.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.value != null && message.hasOwnProperty("value")) {
                properties._value = 1;
                if (typeof message.value !== "number")
                    return "value: number expected";
            }
            if (message.precision != null && message.hasOwnProperty("precision")) {
                properties._precision = 1;
                if (typeof message.precision !== "number")
                    return "precision: number expected";
            }
            if (message.units != null && message.hasOwnProperty("units"))
                switch (message.units) {
                default:
                    return "units: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            return null;
        };

        /**
         * Creates a Moles message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.Moles
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.Moles} Moles
         */
        Moles.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.Moles)
                return object;
            let message = new $root.ord.Moles();
            if (object.value != null)
                message.value = Number(object.value);
            if (object.precision != null)
                message.precision = Number(object.precision);
            switch (object.units) {
            default:
                if (typeof object.units === "number") {
                    message.units = object.units;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.units = 0;
                break;
            case "MOLE":
            case 1:
                message.units = 1;
                break;
            case "MILLIMOLE":
            case 2:
                message.units = 2;
                break;
            case "MICROMOLE":
            case 3:
                message.units = 3;
                break;
            case "NANOMOLE":
            case 4:
                message.units = 4;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Moles message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.Moles
         * @static
         * @param {ord.Moles} message Moles
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Moles.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.units = options.enums === String ? "UNSPECIFIED" : 0;
            if (message.value != null && message.hasOwnProperty("value")) {
                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                if (options.oneofs)
                    object._value = "value";
            }
            if (message.precision != null && message.hasOwnProperty("precision")) {
                object.precision = options.json && !isFinite(message.precision) ? String(message.precision) : message.precision;
                if (options.oneofs)
                    object._precision = "precision";
            }
            if (message.units != null && message.hasOwnProperty("units"))
                object.units = options.enums === String ? $root.ord.Moles.MolesUnit[message.units] === undefined ? message.units : $root.ord.Moles.MolesUnit[message.units] : message.units;
            return object;
        };

        /**
         * Converts this Moles to JSON.
         * @function toJSON
         * @memberof ord.Moles
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Moles.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Moles
         * @function getTypeUrl
         * @memberof ord.Moles
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Moles.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.Moles";
        };

        /**
         * MolesUnit enum.
         * @name ord.Moles.MolesUnit
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} MOLE=1 MOLE value
         * @property {number} MILLIMOLE=2 MILLIMOLE value
         * @property {number} MICROMOLE=3 MICROMOLE value
         * @property {number} NANOMOLE=4 NANOMOLE value
         */
        Moles.MolesUnit = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "MOLE"] = 1;
            values[valuesById[2] = "MILLIMOLE"] = 2;
            values[valuesById[3] = "MICROMOLE"] = 3;
            values[valuesById[4] = "NANOMOLE"] = 4;
            return values;
        })();

        return Moles;
    })();

    ord.Volume = (function() {

        /**
         * Properties of a Volume.
         * @memberof ord
         * @interface IVolume
         * @property {number|null} [value] Volume value
         * @property {number|null} [precision] Volume precision
         * @property {ord.Volume.VolumeUnit|null} [units] Volume units
         */

        /**
         * Constructs a new Volume.
         * @memberof ord
         * @classdesc Represents a Volume.
         * @implements IVolume
         * @constructor
         * @param {ord.IVolume=} [properties] Properties to set
         */
        function Volume(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Volume value.
         * @member {number|null|undefined} value
         * @memberof ord.Volume
         * @instance
         */
        Volume.prototype.value = null;

        /**
         * Volume precision.
         * @member {number|null|undefined} precision
         * @memberof ord.Volume
         * @instance
         */
        Volume.prototype.precision = null;

        /**
         * Volume units.
         * @member {ord.Volume.VolumeUnit} units
         * @memberof ord.Volume
         * @instance
         */
        Volume.prototype.units = 0;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Volume.prototype, "_value", {
            get: $util.oneOfGetter($oneOfFields = ["value"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Volume.prototype, "_precision", {
            get: $util.oneOfGetter($oneOfFields = ["precision"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Volume instance using the specified properties.
         * @function create
         * @memberof ord.Volume
         * @static
         * @param {ord.IVolume=} [properties] Properties to set
         * @returns {ord.Volume} Volume instance
         */
        Volume.create = function create(properties) {
            return new Volume(properties);
        };

        /**
         * Encodes the specified Volume message. Does not implicitly {@link ord.Volume.verify|verify} messages.
         * @function encode
         * @memberof ord.Volume
         * @static
         * @param {ord.IVolume} message Volume message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Volume.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.value);
            if (message.precision != null && Object.hasOwnProperty.call(message, "precision"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.precision);
            if (message.units != null && Object.hasOwnProperty.call(message, "units"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.units);
            return writer;
        };

        /**
         * Encodes the specified Volume message, length delimited. Does not implicitly {@link ord.Volume.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.Volume
         * @static
         * @param {ord.IVolume} message Volume message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Volume.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Volume message from the specified reader or buffer.
         * @function decode
         * @memberof ord.Volume
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.Volume} Volume
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Volume.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.Volume();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.value = reader.float();
                        break;
                    }
                case 2: {
                        message.precision = reader.float();
                        break;
                    }
                case 3: {
                        message.units = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Volume message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.Volume
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.Volume} Volume
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Volume.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Volume message.
         * @function verify
         * @memberof ord.Volume
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Volume.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.value != null && message.hasOwnProperty("value")) {
                properties._value = 1;
                if (typeof message.value !== "number")
                    return "value: number expected";
            }
            if (message.precision != null && message.hasOwnProperty("precision")) {
                properties._precision = 1;
                if (typeof message.precision !== "number")
                    return "precision: number expected";
            }
            if (message.units != null && message.hasOwnProperty("units"))
                switch (message.units) {
                default:
                    return "units: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            return null;
        };

        /**
         * Creates a Volume message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.Volume
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.Volume} Volume
         */
        Volume.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.Volume)
                return object;
            let message = new $root.ord.Volume();
            if (object.value != null)
                message.value = Number(object.value);
            if (object.precision != null)
                message.precision = Number(object.precision);
            switch (object.units) {
            default:
                if (typeof object.units === "number") {
                    message.units = object.units;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.units = 0;
                break;
            case "LITER":
            case 1:
                message.units = 1;
                break;
            case "MILLILITER":
            case 2:
                message.units = 2;
                break;
            case "MICROLITER":
            case 3:
                message.units = 3;
                break;
            case "NANOLITER":
            case 4:
                message.units = 4;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Volume message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.Volume
         * @static
         * @param {ord.Volume} message Volume
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Volume.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.units = options.enums === String ? "UNSPECIFIED" : 0;
            if (message.value != null && message.hasOwnProperty("value")) {
                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                if (options.oneofs)
                    object._value = "value";
            }
            if (message.precision != null && message.hasOwnProperty("precision")) {
                object.precision = options.json && !isFinite(message.precision) ? String(message.precision) : message.precision;
                if (options.oneofs)
                    object._precision = "precision";
            }
            if (message.units != null && message.hasOwnProperty("units"))
                object.units = options.enums === String ? $root.ord.Volume.VolumeUnit[message.units] === undefined ? message.units : $root.ord.Volume.VolumeUnit[message.units] : message.units;
            return object;
        };

        /**
         * Converts this Volume to JSON.
         * @function toJSON
         * @memberof ord.Volume
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Volume.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Volume
         * @function getTypeUrl
         * @memberof ord.Volume
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Volume.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.Volume";
        };

        /**
         * VolumeUnit enum.
         * @name ord.Volume.VolumeUnit
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} LITER=1 LITER value
         * @property {number} MILLILITER=2 MILLILITER value
         * @property {number} MICROLITER=3 MICROLITER value
         * @property {number} NANOLITER=4 NANOLITER value
         */
        Volume.VolumeUnit = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "LITER"] = 1;
            values[valuesById[2] = "MILLILITER"] = 2;
            values[valuesById[3] = "MICROLITER"] = 3;
            values[valuesById[4] = "NANOLITER"] = 4;
            return values;
        })();

        return Volume;
    })();

    ord.Concentration = (function() {

        /**
         * Properties of a Concentration.
         * @memberof ord
         * @interface IConcentration
         * @property {number|null} [value] Concentration value
         * @property {number|null} [precision] Concentration precision
         * @property {ord.Concentration.ConcentrationUnit|null} [units] Concentration units
         */

        /**
         * Constructs a new Concentration.
         * @memberof ord
         * @classdesc Represents a Concentration.
         * @implements IConcentration
         * @constructor
         * @param {ord.IConcentration=} [properties] Properties to set
         */
        function Concentration(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Concentration value.
         * @member {number|null|undefined} value
         * @memberof ord.Concentration
         * @instance
         */
        Concentration.prototype.value = null;

        /**
         * Concentration precision.
         * @member {number|null|undefined} precision
         * @memberof ord.Concentration
         * @instance
         */
        Concentration.prototype.precision = null;

        /**
         * Concentration units.
         * @member {ord.Concentration.ConcentrationUnit} units
         * @memberof ord.Concentration
         * @instance
         */
        Concentration.prototype.units = 0;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Concentration.prototype, "_value", {
            get: $util.oneOfGetter($oneOfFields = ["value"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Concentration.prototype, "_precision", {
            get: $util.oneOfGetter($oneOfFields = ["precision"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Concentration instance using the specified properties.
         * @function create
         * @memberof ord.Concentration
         * @static
         * @param {ord.IConcentration=} [properties] Properties to set
         * @returns {ord.Concentration} Concentration instance
         */
        Concentration.create = function create(properties) {
            return new Concentration(properties);
        };

        /**
         * Encodes the specified Concentration message. Does not implicitly {@link ord.Concentration.verify|verify} messages.
         * @function encode
         * @memberof ord.Concentration
         * @static
         * @param {ord.IConcentration} message Concentration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Concentration.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.value);
            if (message.precision != null && Object.hasOwnProperty.call(message, "precision"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.precision);
            if (message.units != null && Object.hasOwnProperty.call(message, "units"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.units);
            return writer;
        };

        /**
         * Encodes the specified Concentration message, length delimited. Does not implicitly {@link ord.Concentration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.Concentration
         * @static
         * @param {ord.IConcentration} message Concentration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Concentration.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Concentration message from the specified reader or buffer.
         * @function decode
         * @memberof ord.Concentration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.Concentration} Concentration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Concentration.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.Concentration();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.value = reader.float();
                        break;
                    }
                case 2: {
                        message.precision = reader.float();
                        break;
                    }
                case 3: {
                        message.units = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Concentration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.Concentration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.Concentration} Concentration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Concentration.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Concentration message.
         * @function verify
         * @memberof ord.Concentration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Concentration.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.value != null && message.hasOwnProperty("value")) {
                properties._value = 1;
                if (typeof message.value !== "number")
                    return "value: number expected";
            }
            if (message.precision != null && message.hasOwnProperty("precision")) {
                properties._precision = 1;
                if (typeof message.precision !== "number")
                    return "precision: number expected";
            }
            if (message.units != null && message.hasOwnProperty("units"))
                switch (message.units) {
                default:
                    return "units: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a Concentration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.Concentration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.Concentration} Concentration
         */
        Concentration.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.Concentration)
                return object;
            let message = new $root.ord.Concentration();
            if (object.value != null)
                message.value = Number(object.value);
            if (object.precision != null)
                message.precision = Number(object.precision);
            switch (object.units) {
            default:
                if (typeof object.units === "number") {
                    message.units = object.units;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.units = 0;
                break;
            case "MOLAR":
            case 1:
                message.units = 1;
                break;
            case "MILLIMOLAR":
            case 2:
                message.units = 2;
                break;
            case "MICROMOLAR":
            case 3:
                message.units = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Concentration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.Concentration
         * @static
         * @param {ord.Concentration} message Concentration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Concentration.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.units = options.enums === String ? "UNSPECIFIED" : 0;
            if (message.value != null && message.hasOwnProperty("value")) {
                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                if (options.oneofs)
                    object._value = "value";
            }
            if (message.precision != null && message.hasOwnProperty("precision")) {
                object.precision = options.json && !isFinite(message.precision) ? String(message.precision) : message.precision;
                if (options.oneofs)
                    object._precision = "precision";
            }
            if (message.units != null && message.hasOwnProperty("units"))
                object.units = options.enums === String ? $root.ord.Concentration.ConcentrationUnit[message.units] === undefined ? message.units : $root.ord.Concentration.ConcentrationUnit[message.units] : message.units;
            return object;
        };

        /**
         * Converts this Concentration to JSON.
         * @function toJSON
         * @memberof ord.Concentration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Concentration.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Concentration
         * @function getTypeUrl
         * @memberof ord.Concentration
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Concentration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.Concentration";
        };

        /**
         * ConcentrationUnit enum.
         * @name ord.Concentration.ConcentrationUnit
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} MOLAR=1 MOLAR value
         * @property {number} MILLIMOLAR=2 MILLIMOLAR value
         * @property {number} MICROMOLAR=3 MICROMOLAR value
         */
        Concentration.ConcentrationUnit = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "MOLAR"] = 1;
            values[valuesById[2] = "MILLIMOLAR"] = 2;
            values[valuesById[3] = "MICROMOLAR"] = 3;
            return values;
        })();

        return Concentration;
    })();

    ord.Pressure = (function() {

        /**
         * Properties of a Pressure.
         * @memberof ord
         * @interface IPressure
         * @property {number|null} [value] Pressure value
         * @property {number|null} [precision] Pressure precision
         * @property {ord.Pressure.PressureUnit|null} [units] Pressure units
         */

        /**
         * Constructs a new Pressure.
         * @memberof ord
         * @classdesc Represents a Pressure.
         * @implements IPressure
         * @constructor
         * @param {ord.IPressure=} [properties] Properties to set
         */
        function Pressure(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Pressure value.
         * @member {number|null|undefined} value
         * @memberof ord.Pressure
         * @instance
         */
        Pressure.prototype.value = null;

        /**
         * Pressure precision.
         * @member {number|null|undefined} precision
         * @memberof ord.Pressure
         * @instance
         */
        Pressure.prototype.precision = null;

        /**
         * Pressure units.
         * @member {ord.Pressure.PressureUnit} units
         * @memberof ord.Pressure
         * @instance
         */
        Pressure.prototype.units = 0;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Pressure.prototype, "_value", {
            get: $util.oneOfGetter($oneOfFields = ["value"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Pressure.prototype, "_precision", {
            get: $util.oneOfGetter($oneOfFields = ["precision"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Pressure instance using the specified properties.
         * @function create
         * @memberof ord.Pressure
         * @static
         * @param {ord.IPressure=} [properties] Properties to set
         * @returns {ord.Pressure} Pressure instance
         */
        Pressure.create = function create(properties) {
            return new Pressure(properties);
        };

        /**
         * Encodes the specified Pressure message. Does not implicitly {@link ord.Pressure.verify|verify} messages.
         * @function encode
         * @memberof ord.Pressure
         * @static
         * @param {ord.IPressure} message Pressure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Pressure.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.value);
            if (message.precision != null && Object.hasOwnProperty.call(message, "precision"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.precision);
            if (message.units != null && Object.hasOwnProperty.call(message, "units"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.units);
            return writer;
        };

        /**
         * Encodes the specified Pressure message, length delimited. Does not implicitly {@link ord.Pressure.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.Pressure
         * @static
         * @param {ord.IPressure} message Pressure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Pressure.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Pressure message from the specified reader or buffer.
         * @function decode
         * @memberof ord.Pressure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.Pressure} Pressure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Pressure.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.Pressure();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.value = reader.float();
                        break;
                    }
                case 2: {
                        message.precision = reader.float();
                        break;
                    }
                case 3: {
                        message.units = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Pressure message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.Pressure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.Pressure} Pressure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Pressure.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Pressure message.
         * @function verify
         * @memberof ord.Pressure
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Pressure.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.value != null && message.hasOwnProperty("value")) {
                properties._value = 1;
                if (typeof message.value !== "number")
                    return "value: number expected";
            }
            if (message.precision != null && message.hasOwnProperty("precision")) {
                properties._precision = 1;
                if (typeof message.precision !== "number")
                    return "precision: number expected";
            }
            if (message.units != null && message.hasOwnProperty("units"))
                switch (message.units) {
                default:
                    return "units: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            return null;
        };

        /**
         * Creates a Pressure message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.Pressure
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.Pressure} Pressure
         */
        Pressure.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.Pressure)
                return object;
            let message = new $root.ord.Pressure();
            if (object.value != null)
                message.value = Number(object.value);
            if (object.precision != null)
                message.precision = Number(object.precision);
            switch (object.units) {
            default:
                if (typeof object.units === "number") {
                    message.units = object.units;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.units = 0;
                break;
            case "BAR":
            case 1:
                message.units = 1;
                break;
            case "ATMOSPHERE":
            case 2:
                message.units = 2;
                break;
            case "PSI":
            case 3:
                message.units = 3;
                break;
            case "KPSI":
            case 4:
                message.units = 4;
                break;
            case "PASCAL":
            case 5:
                message.units = 5;
                break;
            case "KILOPASCAL":
            case 6:
                message.units = 6;
                break;
            case "TORR":
            case 7:
                message.units = 7;
                break;
            case "MM_HG":
            case 8:
                message.units = 8;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Pressure message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.Pressure
         * @static
         * @param {ord.Pressure} message Pressure
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Pressure.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.units = options.enums === String ? "UNSPECIFIED" : 0;
            if (message.value != null && message.hasOwnProperty("value")) {
                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                if (options.oneofs)
                    object._value = "value";
            }
            if (message.precision != null && message.hasOwnProperty("precision")) {
                object.precision = options.json && !isFinite(message.precision) ? String(message.precision) : message.precision;
                if (options.oneofs)
                    object._precision = "precision";
            }
            if (message.units != null && message.hasOwnProperty("units"))
                object.units = options.enums === String ? $root.ord.Pressure.PressureUnit[message.units] === undefined ? message.units : $root.ord.Pressure.PressureUnit[message.units] : message.units;
            return object;
        };

        /**
         * Converts this Pressure to JSON.
         * @function toJSON
         * @memberof ord.Pressure
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Pressure.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Pressure
         * @function getTypeUrl
         * @memberof ord.Pressure
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Pressure.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.Pressure";
        };

        /**
         * PressureUnit enum.
         * @name ord.Pressure.PressureUnit
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} BAR=1 BAR value
         * @property {number} ATMOSPHERE=2 ATMOSPHERE value
         * @property {number} PSI=3 PSI value
         * @property {number} KPSI=4 KPSI value
         * @property {number} PASCAL=5 PASCAL value
         * @property {number} KILOPASCAL=6 KILOPASCAL value
         * @property {number} TORR=7 TORR value
         * @property {number} MM_HG=8 MM_HG value
         */
        Pressure.PressureUnit = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "BAR"] = 1;
            values[valuesById[2] = "ATMOSPHERE"] = 2;
            values[valuesById[3] = "PSI"] = 3;
            values[valuesById[4] = "KPSI"] = 4;
            values[valuesById[5] = "PASCAL"] = 5;
            values[valuesById[6] = "KILOPASCAL"] = 6;
            values[valuesById[7] = "TORR"] = 7;
            values[valuesById[8] = "MM_HG"] = 8;
            return values;
        })();

        return Pressure;
    })();

    ord.Temperature = (function() {

        /**
         * Properties of a Temperature.
         * @memberof ord
         * @interface ITemperature
         * @property {number|null} [value] Temperature value
         * @property {number|null} [precision] Temperature precision
         * @property {ord.Temperature.TemperatureUnit|null} [units] Temperature units
         */

        /**
         * Constructs a new Temperature.
         * @memberof ord
         * @classdesc Represents a Temperature.
         * @implements ITemperature
         * @constructor
         * @param {ord.ITemperature=} [properties] Properties to set
         */
        function Temperature(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Temperature value.
         * @member {number|null|undefined} value
         * @memberof ord.Temperature
         * @instance
         */
        Temperature.prototype.value = null;

        /**
         * Temperature precision.
         * @member {number|null|undefined} precision
         * @memberof ord.Temperature
         * @instance
         */
        Temperature.prototype.precision = null;

        /**
         * Temperature units.
         * @member {ord.Temperature.TemperatureUnit} units
         * @memberof ord.Temperature
         * @instance
         */
        Temperature.prototype.units = 0;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Temperature.prototype, "_value", {
            get: $util.oneOfGetter($oneOfFields = ["value"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Temperature.prototype, "_precision", {
            get: $util.oneOfGetter($oneOfFields = ["precision"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Temperature instance using the specified properties.
         * @function create
         * @memberof ord.Temperature
         * @static
         * @param {ord.ITemperature=} [properties] Properties to set
         * @returns {ord.Temperature} Temperature instance
         */
        Temperature.create = function create(properties) {
            return new Temperature(properties);
        };

        /**
         * Encodes the specified Temperature message. Does not implicitly {@link ord.Temperature.verify|verify} messages.
         * @function encode
         * @memberof ord.Temperature
         * @static
         * @param {ord.ITemperature} message Temperature message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Temperature.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.value);
            if (message.precision != null && Object.hasOwnProperty.call(message, "precision"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.precision);
            if (message.units != null && Object.hasOwnProperty.call(message, "units"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.units);
            return writer;
        };

        /**
         * Encodes the specified Temperature message, length delimited. Does not implicitly {@link ord.Temperature.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.Temperature
         * @static
         * @param {ord.ITemperature} message Temperature message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Temperature.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Temperature message from the specified reader or buffer.
         * @function decode
         * @memberof ord.Temperature
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.Temperature} Temperature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Temperature.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.Temperature();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.value = reader.float();
                        break;
                    }
                case 2: {
                        message.precision = reader.float();
                        break;
                    }
                case 3: {
                        message.units = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Temperature message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.Temperature
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.Temperature} Temperature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Temperature.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Temperature message.
         * @function verify
         * @memberof ord.Temperature
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Temperature.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.value != null && message.hasOwnProperty("value")) {
                properties._value = 1;
                if (typeof message.value !== "number")
                    return "value: number expected";
            }
            if (message.precision != null && message.hasOwnProperty("precision")) {
                properties._precision = 1;
                if (typeof message.precision !== "number")
                    return "precision: number expected";
            }
            if (message.units != null && message.hasOwnProperty("units"))
                switch (message.units) {
                default:
                    return "units: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a Temperature message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.Temperature
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.Temperature} Temperature
         */
        Temperature.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.Temperature)
                return object;
            let message = new $root.ord.Temperature();
            if (object.value != null)
                message.value = Number(object.value);
            if (object.precision != null)
                message.precision = Number(object.precision);
            switch (object.units) {
            default:
                if (typeof object.units === "number") {
                    message.units = object.units;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.units = 0;
                break;
            case "CELSIUS":
            case 1:
                message.units = 1;
                break;
            case "FAHRENHEIT":
            case 2:
                message.units = 2;
                break;
            case "KELVIN":
            case 3:
                message.units = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Temperature message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.Temperature
         * @static
         * @param {ord.Temperature} message Temperature
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Temperature.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.units = options.enums === String ? "UNSPECIFIED" : 0;
            if (message.value != null && message.hasOwnProperty("value")) {
                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                if (options.oneofs)
                    object._value = "value";
            }
            if (message.precision != null && message.hasOwnProperty("precision")) {
                object.precision = options.json && !isFinite(message.precision) ? String(message.precision) : message.precision;
                if (options.oneofs)
                    object._precision = "precision";
            }
            if (message.units != null && message.hasOwnProperty("units"))
                object.units = options.enums === String ? $root.ord.Temperature.TemperatureUnit[message.units] === undefined ? message.units : $root.ord.Temperature.TemperatureUnit[message.units] : message.units;
            return object;
        };

        /**
         * Converts this Temperature to JSON.
         * @function toJSON
         * @memberof ord.Temperature
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Temperature.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Temperature
         * @function getTypeUrl
         * @memberof ord.Temperature
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Temperature.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.Temperature";
        };

        /**
         * TemperatureUnit enum.
         * @name ord.Temperature.TemperatureUnit
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} CELSIUS=1 CELSIUS value
         * @property {number} FAHRENHEIT=2 FAHRENHEIT value
         * @property {number} KELVIN=3 KELVIN value
         */
        Temperature.TemperatureUnit = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "CELSIUS"] = 1;
            values[valuesById[2] = "FAHRENHEIT"] = 2;
            values[valuesById[3] = "KELVIN"] = 3;
            return values;
        })();

        return Temperature;
    })();

    ord.Current = (function() {

        /**
         * Properties of a Current.
         * @memberof ord
         * @interface ICurrent
         * @property {number|null} [value] Current value
         * @property {number|null} [precision] Current precision
         * @property {ord.Current.CurrentUnit|null} [units] Current units
         */

        /**
         * Constructs a new Current.
         * @memberof ord
         * @classdesc Represents a Current.
         * @implements ICurrent
         * @constructor
         * @param {ord.ICurrent=} [properties] Properties to set
         */
        function Current(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Current value.
         * @member {number|null|undefined} value
         * @memberof ord.Current
         * @instance
         */
        Current.prototype.value = null;

        /**
         * Current precision.
         * @member {number|null|undefined} precision
         * @memberof ord.Current
         * @instance
         */
        Current.prototype.precision = null;

        /**
         * Current units.
         * @member {ord.Current.CurrentUnit} units
         * @memberof ord.Current
         * @instance
         */
        Current.prototype.units = 0;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Current.prototype, "_value", {
            get: $util.oneOfGetter($oneOfFields = ["value"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Current.prototype, "_precision", {
            get: $util.oneOfGetter($oneOfFields = ["precision"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Current instance using the specified properties.
         * @function create
         * @memberof ord.Current
         * @static
         * @param {ord.ICurrent=} [properties] Properties to set
         * @returns {ord.Current} Current instance
         */
        Current.create = function create(properties) {
            return new Current(properties);
        };

        /**
         * Encodes the specified Current message. Does not implicitly {@link ord.Current.verify|verify} messages.
         * @function encode
         * @memberof ord.Current
         * @static
         * @param {ord.ICurrent} message Current message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Current.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.value);
            if (message.precision != null && Object.hasOwnProperty.call(message, "precision"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.precision);
            if (message.units != null && Object.hasOwnProperty.call(message, "units"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.units);
            return writer;
        };

        /**
         * Encodes the specified Current message, length delimited. Does not implicitly {@link ord.Current.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.Current
         * @static
         * @param {ord.ICurrent} message Current message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Current.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Current message from the specified reader or buffer.
         * @function decode
         * @memberof ord.Current
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.Current} Current
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Current.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.Current();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.value = reader.float();
                        break;
                    }
                case 2: {
                        message.precision = reader.float();
                        break;
                    }
                case 3: {
                        message.units = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Current message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.Current
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.Current} Current
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Current.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Current message.
         * @function verify
         * @memberof ord.Current
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Current.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.value != null && message.hasOwnProperty("value")) {
                properties._value = 1;
                if (typeof message.value !== "number")
                    return "value: number expected";
            }
            if (message.precision != null && message.hasOwnProperty("precision")) {
                properties._precision = 1;
                if (typeof message.precision !== "number")
                    return "precision: number expected";
            }
            if (message.units != null && message.hasOwnProperty("units"))
                switch (message.units) {
                default:
                    return "units: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a Current message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.Current
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.Current} Current
         */
        Current.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.Current)
                return object;
            let message = new $root.ord.Current();
            if (object.value != null)
                message.value = Number(object.value);
            if (object.precision != null)
                message.precision = Number(object.precision);
            switch (object.units) {
            default:
                if (typeof object.units === "number") {
                    message.units = object.units;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.units = 0;
                break;
            case "AMPERE":
            case 1:
                message.units = 1;
                break;
            case "MILLIAMPERE":
            case 2:
                message.units = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Current message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.Current
         * @static
         * @param {ord.Current} message Current
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Current.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.units = options.enums === String ? "UNSPECIFIED" : 0;
            if (message.value != null && message.hasOwnProperty("value")) {
                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                if (options.oneofs)
                    object._value = "value";
            }
            if (message.precision != null && message.hasOwnProperty("precision")) {
                object.precision = options.json && !isFinite(message.precision) ? String(message.precision) : message.precision;
                if (options.oneofs)
                    object._precision = "precision";
            }
            if (message.units != null && message.hasOwnProperty("units"))
                object.units = options.enums === String ? $root.ord.Current.CurrentUnit[message.units] === undefined ? message.units : $root.ord.Current.CurrentUnit[message.units] : message.units;
            return object;
        };

        /**
         * Converts this Current to JSON.
         * @function toJSON
         * @memberof ord.Current
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Current.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Current
         * @function getTypeUrl
         * @memberof ord.Current
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Current.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.Current";
        };

        /**
         * CurrentUnit enum.
         * @name ord.Current.CurrentUnit
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} AMPERE=1 AMPERE value
         * @property {number} MILLIAMPERE=2 MILLIAMPERE value
         */
        Current.CurrentUnit = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "AMPERE"] = 1;
            values[valuesById[2] = "MILLIAMPERE"] = 2;
            return values;
        })();

        return Current;
    })();

    ord.Voltage = (function() {

        /**
         * Properties of a Voltage.
         * @memberof ord
         * @interface IVoltage
         * @property {number|null} [value] Voltage value
         * @property {number|null} [precision] Voltage precision
         * @property {ord.Voltage.VoltageUnit|null} [units] Voltage units
         */

        /**
         * Constructs a new Voltage.
         * @memberof ord
         * @classdesc Represents a Voltage.
         * @implements IVoltage
         * @constructor
         * @param {ord.IVoltage=} [properties] Properties to set
         */
        function Voltage(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Voltage value.
         * @member {number|null|undefined} value
         * @memberof ord.Voltage
         * @instance
         */
        Voltage.prototype.value = null;

        /**
         * Voltage precision.
         * @member {number|null|undefined} precision
         * @memberof ord.Voltage
         * @instance
         */
        Voltage.prototype.precision = null;

        /**
         * Voltage units.
         * @member {ord.Voltage.VoltageUnit} units
         * @memberof ord.Voltage
         * @instance
         */
        Voltage.prototype.units = 0;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Voltage.prototype, "_value", {
            get: $util.oneOfGetter($oneOfFields = ["value"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Voltage.prototype, "_precision", {
            get: $util.oneOfGetter($oneOfFields = ["precision"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Voltage instance using the specified properties.
         * @function create
         * @memberof ord.Voltage
         * @static
         * @param {ord.IVoltage=} [properties] Properties to set
         * @returns {ord.Voltage} Voltage instance
         */
        Voltage.create = function create(properties) {
            return new Voltage(properties);
        };

        /**
         * Encodes the specified Voltage message. Does not implicitly {@link ord.Voltage.verify|verify} messages.
         * @function encode
         * @memberof ord.Voltage
         * @static
         * @param {ord.IVoltage} message Voltage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Voltage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.value);
            if (message.precision != null && Object.hasOwnProperty.call(message, "precision"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.precision);
            if (message.units != null && Object.hasOwnProperty.call(message, "units"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.units);
            return writer;
        };

        /**
         * Encodes the specified Voltage message, length delimited. Does not implicitly {@link ord.Voltage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.Voltage
         * @static
         * @param {ord.IVoltage} message Voltage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Voltage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Voltage message from the specified reader or buffer.
         * @function decode
         * @memberof ord.Voltage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.Voltage} Voltage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Voltage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.Voltage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.value = reader.float();
                        break;
                    }
                case 2: {
                        message.precision = reader.float();
                        break;
                    }
                case 3: {
                        message.units = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Voltage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.Voltage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.Voltage} Voltage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Voltage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Voltage message.
         * @function verify
         * @memberof ord.Voltage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Voltage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.value != null && message.hasOwnProperty("value")) {
                properties._value = 1;
                if (typeof message.value !== "number")
                    return "value: number expected";
            }
            if (message.precision != null && message.hasOwnProperty("precision")) {
                properties._precision = 1;
                if (typeof message.precision !== "number")
                    return "precision: number expected";
            }
            if (message.units != null && message.hasOwnProperty("units"))
                switch (message.units) {
                default:
                    return "units: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a Voltage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.Voltage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.Voltage} Voltage
         */
        Voltage.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.Voltage)
                return object;
            let message = new $root.ord.Voltage();
            if (object.value != null)
                message.value = Number(object.value);
            if (object.precision != null)
                message.precision = Number(object.precision);
            switch (object.units) {
            default:
                if (typeof object.units === "number") {
                    message.units = object.units;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.units = 0;
                break;
            case "VOLT":
            case 1:
                message.units = 1;
                break;
            case "MILLIVOLT":
            case 2:
                message.units = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Voltage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.Voltage
         * @static
         * @param {ord.Voltage} message Voltage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Voltage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.units = options.enums === String ? "UNSPECIFIED" : 0;
            if (message.value != null && message.hasOwnProperty("value")) {
                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                if (options.oneofs)
                    object._value = "value";
            }
            if (message.precision != null && message.hasOwnProperty("precision")) {
                object.precision = options.json && !isFinite(message.precision) ? String(message.precision) : message.precision;
                if (options.oneofs)
                    object._precision = "precision";
            }
            if (message.units != null && message.hasOwnProperty("units"))
                object.units = options.enums === String ? $root.ord.Voltage.VoltageUnit[message.units] === undefined ? message.units : $root.ord.Voltage.VoltageUnit[message.units] : message.units;
            return object;
        };

        /**
         * Converts this Voltage to JSON.
         * @function toJSON
         * @memberof ord.Voltage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Voltage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Voltage
         * @function getTypeUrl
         * @memberof ord.Voltage
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Voltage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.Voltage";
        };

        /**
         * VoltageUnit enum.
         * @name ord.Voltage.VoltageUnit
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} VOLT=1 VOLT value
         * @property {number} MILLIVOLT=2 MILLIVOLT value
         */
        Voltage.VoltageUnit = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "VOLT"] = 1;
            values[valuesById[2] = "MILLIVOLT"] = 2;
            return values;
        })();

        return Voltage;
    })();

    ord.Length = (function() {

        /**
         * Properties of a Length.
         * @memberof ord
         * @interface ILength
         * @property {number|null} [value] Length value
         * @property {number|null} [precision] Length precision
         * @property {ord.Length.LengthUnit|null} [units] Length units
         */

        /**
         * Constructs a new Length.
         * @memberof ord
         * @classdesc Represents a Length.
         * @implements ILength
         * @constructor
         * @param {ord.ILength=} [properties] Properties to set
         */
        function Length(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Length value.
         * @member {number|null|undefined} value
         * @memberof ord.Length
         * @instance
         */
        Length.prototype.value = null;

        /**
         * Length precision.
         * @member {number|null|undefined} precision
         * @memberof ord.Length
         * @instance
         */
        Length.prototype.precision = null;

        /**
         * Length units.
         * @member {ord.Length.LengthUnit} units
         * @memberof ord.Length
         * @instance
         */
        Length.prototype.units = 0;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Length.prototype, "_value", {
            get: $util.oneOfGetter($oneOfFields = ["value"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Length.prototype, "_precision", {
            get: $util.oneOfGetter($oneOfFields = ["precision"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Length instance using the specified properties.
         * @function create
         * @memberof ord.Length
         * @static
         * @param {ord.ILength=} [properties] Properties to set
         * @returns {ord.Length} Length instance
         */
        Length.create = function create(properties) {
            return new Length(properties);
        };

        /**
         * Encodes the specified Length message. Does not implicitly {@link ord.Length.verify|verify} messages.
         * @function encode
         * @memberof ord.Length
         * @static
         * @param {ord.ILength} message Length message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Length.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.value);
            if (message.precision != null && Object.hasOwnProperty.call(message, "precision"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.precision);
            if (message.units != null && Object.hasOwnProperty.call(message, "units"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.units);
            return writer;
        };

        /**
         * Encodes the specified Length message, length delimited. Does not implicitly {@link ord.Length.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.Length
         * @static
         * @param {ord.ILength} message Length message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Length.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Length message from the specified reader or buffer.
         * @function decode
         * @memberof ord.Length
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.Length} Length
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Length.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.Length();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.value = reader.float();
                        break;
                    }
                case 2: {
                        message.precision = reader.float();
                        break;
                    }
                case 3: {
                        message.units = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Length message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.Length
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.Length} Length
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Length.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Length message.
         * @function verify
         * @memberof ord.Length
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Length.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.value != null && message.hasOwnProperty("value")) {
                properties._value = 1;
                if (typeof message.value !== "number")
                    return "value: number expected";
            }
            if (message.precision != null && message.hasOwnProperty("precision")) {
                properties._precision = 1;
                if (typeof message.precision !== "number")
                    return "precision: number expected";
            }
            if (message.units != null && message.hasOwnProperty("units"))
                switch (message.units) {
                default:
                    return "units: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            return null;
        };

        /**
         * Creates a Length message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.Length
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.Length} Length
         */
        Length.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.Length)
                return object;
            let message = new $root.ord.Length();
            if (object.value != null)
                message.value = Number(object.value);
            if (object.precision != null)
                message.precision = Number(object.precision);
            switch (object.units) {
            default:
                if (typeof object.units === "number") {
                    message.units = object.units;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.units = 0;
                break;
            case "CENTIMETER":
            case 1:
                message.units = 1;
                break;
            case "MILLIMETER":
            case 2:
                message.units = 2;
                break;
            case "METER":
            case 3:
                message.units = 3;
                break;
            case "INCH":
            case 4:
                message.units = 4;
                break;
            case "FOOT":
            case 5:
                message.units = 5;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Length message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.Length
         * @static
         * @param {ord.Length} message Length
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Length.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.units = options.enums === String ? "UNSPECIFIED" : 0;
            if (message.value != null && message.hasOwnProperty("value")) {
                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                if (options.oneofs)
                    object._value = "value";
            }
            if (message.precision != null && message.hasOwnProperty("precision")) {
                object.precision = options.json && !isFinite(message.precision) ? String(message.precision) : message.precision;
                if (options.oneofs)
                    object._precision = "precision";
            }
            if (message.units != null && message.hasOwnProperty("units"))
                object.units = options.enums === String ? $root.ord.Length.LengthUnit[message.units] === undefined ? message.units : $root.ord.Length.LengthUnit[message.units] : message.units;
            return object;
        };

        /**
         * Converts this Length to JSON.
         * @function toJSON
         * @memberof ord.Length
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Length.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Length
         * @function getTypeUrl
         * @memberof ord.Length
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Length.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.Length";
        };

        /**
         * LengthUnit enum.
         * @name ord.Length.LengthUnit
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} CENTIMETER=1 CENTIMETER value
         * @property {number} MILLIMETER=2 MILLIMETER value
         * @property {number} METER=3 METER value
         * @property {number} INCH=4 INCH value
         * @property {number} FOOT=5 FOOT value
         */
        Length.LengthUnit = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "CENTIMETER"] = 1;
            values[valuesById[2] = "MILLIMETER"] = 2;
            values[valuesById[3] = "METER"] = 3;
            values[valuesById[4] = "INCH"] = 4;
            values[valuesById[5] = "FOOT"] = 5;
            return values;
        })();

        return Length;
    })();

    ord.Wavelength = (function() {

        /**
         * Properties of a Wavelength.
         * @memberof ord
         * @interface IWavelength
         * @property {number|null} [value] Wavelength value
         * @property {number|null} [precision] Wavelength precision
         * @property {ord.Wavelength.WavelengthUnit|null} [units] Wavelength units
         */

        /**
         * Constructs a new Wavelength.
         * @memberof ord
         * @classdesc Represents a Wavelength.
         * @implements IWavelength
         * @constructor
         * @param {ord.IWavelength=} [properties] Properties to set
         */
        function Wavelength(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Wavelength value.
         * @member {number|null|undefined} value
         * @memberof ord.Wavelength
         * @instance
         */
        Wavelength.prototype.value = null;

        /**
         * Wavelength precision.
         * @member {number|null|undefined} precision
         * @memberof ord.Wavelength
         * @instance
         */
        Wavelength.prototype.precision = null;

        /**
         * Wavelength units.
         * @member {ord.Wavelength.WavelengthUnit} units
         * @memberof ord.Wavelength
         * @instance
         */
        Wavelength.prototype.units = 0;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Wavelength.prototype, "_value", {
            get: $util.oneOfGetter($oneOfFields = ["value"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Wavelength.prototype, "_precision", {
            get: $util.oneOfGetter($oneOfFields = ["precision"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Wavelength instance using the specified properties.
         * @function create
         * @memberof ord.Wavelength
         * @static
         * @param {ord.IWavelength=} [properties] Properties to set
         * @returns {ord.Wavelength} Wavelength instance
         */
        Wavelength.create = function create(properties) {
            return new Wavelength(properties);
        };

        /**
         * Encodes the specified Wavelength message. Does not implicitly {@link ord.Wavelength.verify|verify} messages.
         * @function encode
         * @memberof ord.Wavelength
         * @static
         * @param {ord.IWavelength} message Wavelength message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Wavelength.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.value);
            if (message.precision != null && Object.hasOwnProperty.call(message, "precision"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.precision);
            if (message.units != null && Object.hasOwnProperty.call(message, "units"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.units);
            return writer;
        };

        /**
         * Encodes the specified Wavelength message, length delimited. Does not implicitly {@link ord.Wavelength.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.Wavelength
         * @static
         * @param {ord.IWavelength} message Wavelength message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Wavelength.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Wavelength message from the specified reader or buffer.
         * @function decode
         * @memberof ord.Wavelength
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.Wavelength} Wavelength
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Wavelength.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.Wavelength();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.value = reader.float();
                        break;
                    }
                case 2: {
                        message.precision = reader.float();
                        break;
                    }
                case 3: {
                        message.units = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Wavelength message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.Wavelength
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.Wavelength} Wavelength
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Wavelength.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Wavelength message.
         * @function verify
         * @memberof ord.Wavelength
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Wavelength.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.value != null && message.hasOwnProperty("value")) {
                properties._value = 1;
                if (typeof message.value !== "number")
                    return "value: number expected";
            }
            if (message.precision != null && message.hasOwnProperty("precision")) {
                properties._precision = 1;
                if (typeof message.precision !== "number")
                    return "precision: number expected";
            }
            if (message.units != null && message.hasOwnProperty("units"))
                switch (message.units) {
                default:
                    return "units: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a Wavelength message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.Wavelength
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.Wavelength} Wavelength
         */
        Wavelength.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.Wavelength)
                return object;
            let message = new $root.ord.Wavelength();
            if (object.value != null)
                message.value = Number(object.value);
            if (object.precision != null)
                message.precision = Number(object.precision);
            switch (object.units) {
            default:
                if (typeof object.units === "number") {
                    message.units = object.units;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.units = 0;
                break;
            case "NANOMETER":
            case 1:
                message.units = 1;
                break;
            case "WAVENUMBER":
            case 2:
                message.units = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Wavelength message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.Wavelength
         * @static
         * @param {ord.Wavelength} message Wavelength
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Wavelength.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.units = options.enums === String ? "UNSPECIFIED" : 0;
            if (message.value != null && message.hasOwnProperty("value")) {
                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                if (options.oneofs)
                    object._value = "value";
            }
            if (message.precision != null && message.hasOwnProperty("precision")) {
                object.precision = options.json && !isFinite(message.precision) ? String(message.precision) : message.precision;
                if (options.oneofs)
                    object._precision = "precision";
            }
            if (message.units != null && message.hasOwnProperty("units"))
                object.units = options.enums === String ? $root.ord.Wavelength.WavelengthUnit[message.units] === undefined ? message.units : $root.ord.Wavelength.WavelengthUnit[message.units] : message.units;
            return object;
        };

        /**
         * Converts this Wavelength to JSON.
         * @function toJSON
         * @memberof ord.Wavelength
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Wavelength.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Wavelength
         * @function getTypeUrl
         * @memberof ord.Wavelength
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Wavelength.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.Wavelength";
        };

        /**
         * WavelengthUnit enum.
         * @name ord.Wavelength.WavelengthUnit
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} NANOMETER=1 NANOMETER value
         * @property {number} WAVENUMBER=2 WAVENUMBER value
         */
        Wavelength.WavelengthUnit = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "NANOMETER"] = 1;
            values[valuesById[2] = "WAVENUMBER"] = 2;
            return values;
        })();

        return Wavelength;
    })();

    ord.FlowRate = (function() {

        /**
         * Properties of a FlowRate.
         * @memberof ord
         * @interface IFlowRate
         * @property {number|null} [value] FlowRate value
         * @property {number|null} [precision] FlowRate precision
         * @property {ord.FlowRate.FlowRateUnit|null} [units] FlowRate units
         */

        /**
         * Constructs a new FlowRate.
         * @memberof ord
         * @classdesc Represents a FlowRate.
         * @implements IFlowRate
         * @constructor
         * @param {ord.IFlowRate=} [properties] Properties to set
         */
        function FlowRate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FlowRate value.
         * @member {number|null|undefined} value
         * @memberof ord.FlowRate
         * @instance
         */
        FlowRate.prototype.value = null;

        /**
         * FlowRate precision.
         * @member {number|null|undefined} precision
         * @memberof ord.FlowRate
         * @instance
         */
        FlowRate.prototype.precision = null;

        /**
         * FlowRate units.
         * @member {ord.FlowRate.FlowRateUnit} units
         * @memberof ord.FlowRate
         * @instance
         */
        FlowRate.prototype.units = 0;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(FlowRate.prototype, "_value", {
            get: $util.oneOfGetter($oneOfFields = ["value"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(FlowRate.prototype, "_precision", {
            get: $util.oneOfGetter($oneOfFields = ["precision"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new FlowRate instance using the specified properties.
         * @function create
         * @memberof ord.FlowRate
         * @static
         * @param {ord.IFlowRate=} [properties] Properties to set
         * @returns {ord.FlowRate} FlowRate instance
         */
        FlowRate.create = function create(properties) {
            return new FlowRate(properties);
        };

        /**
         * Encodes the specified FlowRate message. Does not implicitly {@link ord.FlowRate.verify|verify} messages.
         * @function encode
         * @memberof ord.FlowRate
         * @static
         * @param {ord.IFlowRate} message FlowRate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FlowRate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.value);
            if (message.precision != null && Object.hasOwnProperty.call(message, "precision"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.precision);
            if (message.units != null && Object.hasOwnProperty.call(message, "units"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.units);
            return writer;
        };

        /**
         * Encodes the specified FlowRate message, length delimited. Does not implicitly {@link ord.FlowRate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.FlowRate
         * @static
         * @param {ord.IFlowRate} message FlowRate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FlowRate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FlowRate message from the specified reader or buffer.
         * @function decode
         * @memberof ord.FlowRate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.FlowRate} FlowRate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FlowRate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.FlowRate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.value = reader.float();
                        break;
                    }
                case 2: {
                        message.precision = reader.float();
                        break;
                    }
                case 3: {
                        message.units = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FlowRate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.FlowRate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.FlowRate} FlowRate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FlowRate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FlowRate message.
         * @function verify
         * @memberof ord.FlowRate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FlowRate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.value != null && message.hasOwnProperty("value")) {
                properties._value = 1;
                if (typeof message.value !== "number")
                    return "value: number expected";
            }
            if (message.precision != null && message.hasOwnProperty("precision")) {
                properties._precision = 1;
                if (typeof message.precision !== "number")
                    return "precision: number expected";
            }
            if (message.units != null && message.hasOwnProperty("units"))
                switch (message.units) {
                default:
                    return "units: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            return null;
        };

        /**
         * Creates a FlowRate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.FlowRate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.FlowRate} FlowRate
         */
        FlowRate.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.FlowRate)
                return object;
            let message = new $root.ord.FlowRate();
            if (object.value != null)
                message.value = Number(object.value);
            if (object.precision != null)
                message.precision = Number(object.precision);
            switch (object.units) {
            default:
                if (typeof object.units === "number") {
                    message.units = object.units;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.units = 0;
                break;
            case "MICROLITER_PER_MINUTE":
            case 1:
                message.units = 1;
                break;
            case "MICROLITER_PER_SECOND":
            case 2:
                message.units = 2;
                break;
            case "MILLILITER_PER_MINUTE":
            case 3:
                message.units = 3;
                break;
            case "MILLILITER_PER_SECOND":
            case 4:
                message.units = 4;
                break;
            case "MICROLITER_PER_HOUR":
            case 5:
                message.units = 5;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a FlowRate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.FlowRate
         * @static
         * @param {ord.FlowRate} message FlowRate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FlowRate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.units = options.enums === String ? "UNSPECIFIED" : 0;
            if (message.value != null && message.hasOwnProperty("value")) {
                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                if (options.oneofs)
                    object._value = "value";
            }
            if (message.precision != null && message.hasOwnProperty("precision")) {
                object.precision = options.json && !isFinite(message.precision) ? String(message.precision) : message.precision;
                if (options.oneofs)
                    object._precision = "precision";
            }
            if (message.units != null && message.hasOwnProperty("units"))
                object.units = options.enums === String ? $root.ord.FlowRate.FlowRateUnit[message.units] === undefined ? message.units : $root.ord.FlowRate.FlowRateUnit[message.units] : message.units;
            return object;
        };

        /**
         * Converts this FlowRate to JSON.
         * @function toJSON
         * @memberof ord.FlowRate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FlowRate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for FlowRate
         * @function getTypeUrl
         * @memberof ord.FlowRate
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FlowRate.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.FlowRate";
        };

        /**
         * FlowRateUnit enum.
         * @name ord.FlowRate.FlowRateUnit
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} MICROLITER_PER_MINUTE=1 MICROLITER_PER_MINUTE value
         * @property {number} MICROLITER_PER_SECOND=2 MICROLITER_PER_SECOND value
         * @property {number} MILLILITER_PER_MINUTE=3 MILLILITER_PER_MINUTE value
         * @property {number} MILLILITER_PER_SECOND=4 MILLILITER_PER_SECOND value
         * @property {number} MICROLITER_PER_HOUR=5 MICROLITER_PER_HOUR value
         */
        FlowRate.FlowRateUnit = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "MICROLITER_PER_MINUTE"] = 1;
            values[valuesById[2] = "MICROLITER_PER_SECOND"] = 2;
            values[valuesById[3] = "MILLILITER_PER_MINUTE"] = 3;
            values[valuesById[4] = "MILLILITER_PER_SECOND"] = 4;
            values[valuesById[5] = "MICROLITER_PER_HOUR"] = 5;
            return values;
        })();

        return FlowRate;
    })();

    ord.Percentage = (function() {

        /**
         * Properties of a Percentage.
         * @memberof ord
         * @interface IPercentage
         * @property {number|null} [value] Percentage value
         * @property {number|null} [precision] Percentage precision
         */

        /**
         * Constructs a new Percentage.
         * @memberof ord
         * @classdesc Represents a Percentage.
         * @implements IPercentage
         * @constructor
         * @param {ord.IPercentage=} [properties] Properties to set
         */
        function Percentage(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Percentage value.
         * @member {number|null|undefined} value
         * @memberof ord.Percentage
         * @instance
         */
        Percentage.prototype.value = null;

        /**
         * Percentage precision.
         * @member {number|null|undefined} precision
         * @memberof ord.Percentage
         * @instance
         */
        Percentage.prototype.precision = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Percentage.prototype, "_value", {
            get: $util.oneOfGetter($oneOfFields = ["value"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Percentage.prototype, "_precision", {
            get: $util.oneOfGetter($oneOfFields = ["precision"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Percentage instance using the specified properties.
         * @function create
         * @memberof ord.Percentage
         * @static
         * @param {ord.IPercentage=} [properties] Properties to set
         * @returns {ord.Percentage} Percentage instance
         */
        Percentage.create = function create(properties) {
            return new Percentage(properties);
        };

        /**
         * Encodes the specified Percentage message. Does not implicitly {@link ord.Percentage.verify|verify} messages.
         * @function encode
         * @memberof ord.Percentage
         * @static
         * @param {ord.IPercentage} message Percentage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Percentage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.value);
            if (message.precision != null && Object.hasOwnProperty.call(message, "precision"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.precision);
            return writer;
        };

        /**
         * Encodes the specified Percentage message, length delimited. Does not implicitly {@link ord.Percentage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.Percentage
         * @static
         * @param {ord.IPercentage} message Percentage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Percentage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Percentage message from the specified reader or buffer.
         * @function decode
         * @memberof ord.Percentage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.Percentage} Percentage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Percentage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.Percentage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.value = reader.float();
                        break;
                    }
                case 2: {
                        message.precision = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Percentage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.Percentage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.Percentage} Percentage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Percentage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Percentage message.
         * @function verify
         * @memberof ord.Percentage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Percentage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.value != null && message.hasOwnProperty("value")) {
                properties._value = 1;
                if (typeof message.value !== "number")
                    return "value: number expected";
            }
            if (message.precision != null && message.hasOwnProperty("precision")) {
                properties._precision = 1;
                if (typeof message.precision !== "number")
                    return "precision: number expected";
            }
            return null;
        };

        /**
         * Creates a Percentage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.Percentage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.Percentage} Percentage
         */
        Percentage.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.Percentage)
                return object;
            let message = new $root.ord.Percentage();
            if (object.value != null)
                message.value = Number(object.value);
            if (object.precision != null)
                message.precision = Number(object.precision);
            return message;
        };

        /**
         * Creates a plain object from a Percentage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.Percentage
         * @static
         * @param {ord.Percentage} message Percentage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Percentage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.value != null && message.hasOwnProperty("value")) {
                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                if (options.oneofs)
                    object._value = "value";
            }
            if (message.precision != null && message.hasOwnProperty("precision")) {
                object.precision = options.json && !isFinite(message.precision) ? String(message.precision) : message.precision;
                if (options.oneofs)
                    object._precision = "precision";
            }
            return object;
        };

        /**
         * Converts this Percentage to JSON.
         * @function toJSON
         * @memberof ord.Percentage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Percentage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Percentage
         * @function getTypeUrl
         * @memberof ord.Percentage
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Percentage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.Percentage";
        };

        return Percentage;
    })();

    ord.FloatValue = (function() {

        /**
         * Properties of a FloatValue.
         * @memberof ord
         * @interface IFloatValue
         * @property {number|null} [value] FloatValue value
         * @property {number|null} [precision] FloatValue precision
         */

        /**
         * Constructs a new FloatValue.
         * @memberof ord
         * @classdesc Represents a FloatValue.
         * @implements IFloatValue
         * @constructor
         * @param {ord.IFloatValue=} [properties] Properties to set
         */
        function FloatValue(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FloatValue value.
         * @member {number|null|undefined} value
         * @memberof ord.FloatValue
         * @instance
         */
        FloatValue.prototype.value = null;

        /**
         * FloatValue precision.
         * @member {number|null|undefined} precision
         * @memberof ord.FloatValue
         * @instance
         */
        FloatValue.prototype.precision = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(FloatValue.prototype, "_value", {
            get: $util.oneOfGetter($oneOfFields = ["value"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(FloatValue.prototype, "_precision", {
            get: $util.oneOfGetter($oneOfFields = ["precision"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new FloatValue instance using the specified properties.
         * @function create
         * @memberof ord.FloatValue
         * @static
         * @param {ord.IFloatValue=} [properties] Properties to set
         * @returns {ord.FloatValue} FloatValue instance
         */
        FloatValue.create = function create(properties) {
            return new FloatValue(properties);
        };

        /**
         * Encodes the specified FloatValue message. Does not implicitly {@link ord.FloatValue.verify|verify} messages.
         * @function encode
         * @memberof ord.FloatValue
         * @static
         * @param {ord.IFloatValue} message FloatValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FloatValue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.value);
            if (message.precision != null && Object.hasOwnProperty.call(message, "precision"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.precision);
            return writer;
        };

        /**
         * Encodes the specified FloatValue message, length delimited. Does not implicitly {@link ord.FloatValue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.FloatValue
         * @static
         * @param {ord.IFloatValue} message FloatValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FloatValue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FloatValue message from the specified reader or buffer.
         * @function decode
         * @memberof ord.FloatValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.FloatValue} FloatValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FloatValue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.FloatValue();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.value = reader.float();
                        break;
                    }
                case 2: {
                        message.precision = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FloatValue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.FloatValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.FloatValue} FloatValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FloatValue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FloatValue message.
         * @function verify
         * @memberof ord.FloatValue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FloatValue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.value != null && message.hasOwnProperty("value")) {
                properties._value = 1;
                if (typeof message.value !== "number")
                    return "value: number expected";
            }
            if (message.precision != null && message.hasOwnProperty("precision")) {
                properties._precision = 1;
                if (typeof message.precision !== "number")
                    return "precision: number expected";
            }
            return null;
        };

        /**
         * Creates a FloatValue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.FloatValue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.FloatValue} FloatValue
         */
        FloatValue.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.FloatValue)
                return object;
            let message = new $root.ord.FloatValue();
            if (object.value != null)
                message.value = Number(object.value);
            if (object.precision != null)
                message.precision = Number(object.precision);
            return message;
        };

        /**
         * Creates a plain object from a FloatValue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.FloatValue
         * @static
         * @param {ord.FloatValue} message FloatValue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FloatValue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.value != null && message.hasOwnProperty("value")) {
                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                if (options.oneofs)
                    object._value = "value";
            }
            if (message.precision != null && message.hasOwnProperty("precision")) {
                object.precision = options.json && !isFinite(message.precision) ? String(message.precision) : message.precision;
                if (options.oneofs)
                    object._precision = "precision";
            }
            return object;
        };

        /**
         * Converts this FloatValue to JSON.
         * @function toJSON
         * @memberof ord.FloatValue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FloatValue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for FloatValue
         * @function getTypeUrl
         * @memberof ord.FloatValue
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FloatValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.FloatValue";
        };

        return FloatValue;
    })();

    ord.Data = (function() {

        /**
         * Properties of a Data.
         * @memberof ord
         * @interface IData
         * @property {number|null} [floatValue] Data floatValue
         * @property {number|null} [integerValue] Data integerValue
         * @property {Uint8Array|null} [bytesValue] Data bytesValue
         * @property {string|null} [stringValue] Data stringValue
         * @property {string|null} [url] Data url
         * @property {string|null} [description] Data description
         * @property {string|null} [format] Data format
         */

        /**
         * Constructs a new Data.
         * @memberof ord
         * @classdesc Represents a Data.
         * @implements IData
         * @constructor
         * @param {ord.IData=} [properties] Properties to set
         */
        function Data(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Data floatValue.
         * @member {number|null|undefined} floatValue
         * @memberof ord.Data
         * @instance
         */
        Data.prototype.floatValue = null;

        /**
         * Data integerValue.
         * @member {number|null|undefined} integerValue
         * @memberof ord.Data
         * @instance
         */
        Data.prototype.integerValue = null;

        /**
         * Data bytesValue.
         * @member {Uint8Array|null|undefined} bytesValue
         * @memberof ord.Data
         * @instance
         */
        Data.prototype.bytesValue = null;

        /**
         * Data stringValue.
         * @member {string|null|undefined} stringValue
         * @memberof ord.Data
         * @instance
         */
        Data.prototype.stringValue = null;

        /**
         * Data url.
         * @member {string|null|undefined} url
         * @memberof ord.Data
         * @instance
         */
        Data.prototype.url = null;

        /**
         * Data description.
         * @member {string} description
         * @memberof ord.Data
         * @instance
         */
        Data.prototype.description = "";

        /**
         * Data format.
         * @member {string} format
         * @memberof ord.Data
         * @instance
         */
        Data.prototype.format = "";

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Data kind.
         * @member {"floatValue"|"integerValue"|"bytesValue"|"stringValue"|"url"|undefined} kind
         * @memberof ord.Data
         * @instance
         */
        Object.defineProperty(Data.prototype, "kind", {
            get: $util.oneOfGetter($oneOfFields = ["floatValue", "integerValue", "bytesValue", "stringValue", "url"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Data instance using the specified properties.
         * @function create
         * @memberof ord.Data
         * @static
         * @param {ord.IData=} [properties] Properties to set
         * @returns {ord.Data} Data instance
         */
        Data.create = function create(properties) {
            return new Data(properties);
        };

        /**
         * Encodes the specified Data message. Does not implicitly {@link ord.Data.verify|verify} messages.
         * @function encode
         * @memberof ord.Data
         * @static
         * @param {ord.IData} message Data message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Data.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.floatValue != null && Object.hasOwnProperty.call(message, "floatValue"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.floatValue);
            if (message.integerValue != null && Object.hasOwnProperty.call(message, "integerValue"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.integerValue);
            if (message.bytesValue != null && Object.hasOwnProperty.call(message, "bytesValue"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.bytesValue);
            if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.stringValue);
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.url);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.description);
            if (message.format != null && Object.hasOwnProperty.call(message, "format"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.format);
            return writer;
        };

        /**
         * Encodes the specified Data message, length delimited. Does not implicitly {@link ord.Data.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord.Data
         * @static
         * @param {ord.IData} message Data message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Data.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Data message from the specified reader or buffer.
         * @function decode
         * @memberof ord.Data
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord.Data} Data
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Data.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord.Data();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.floatValue = reader.float();
                        break;
                    }
                case 2: {
                        message.integerValue = reader.int32();
                        break;
                    }
                case 3: {
                        message.bytesValue = reader.bytes();
                        break;
                    }
                case 4: {
                        message.stringValue = reader.string();
                        break;
                    }
                case 5: {
                        message.url = reader.string();
                        break;
                    }
                case 6: {
                        message.description = reader.string();
                        break;
                    }
                case 7: {
                        message.format = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Data message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord.Data
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord.Data} Data
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Data.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Data message.
         * @function verify
         * @memberof ord.Data
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Data.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.floatValue != null && message.hasOwnProperty("floatValue")) {
                properties.kind = 1;
                if (typeof message.floatValue !== "number")
                    return "floatValue: number expected";
            }
            if (message.integerValue != null && message.hasOwnProperty("integerValue")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                if (!$util.isInteger(message.integerValue))
                    return "integerValue: integer expected";
            }
            if (message.bytesValue != null && message.hasOwnProperty("bytesValue")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                if (!(message.bytesValue && typeof message.bytesValue.length === "number" || $util.isString(message.bytesValue)))
                    return "bytesValue: buffer expected";
            }
            if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                if (!$util.isString(message.stringValue))
                    return "stringValue: string expected";
            }
            if (message.url != null && message.hasOwnProperty("url")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                if (!$util.isString(message.url))
                    return "url: string expected";
            }
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.format != null && message.hasOwnProperty("format"))
                if (!$util.isString(message.format))
                    return "format: string expected";
            return null;
        };

        /**
         * Creates a Data message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord.Data
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord.Data} Data
         */
        Data.fromObject = function fromObject(object) {
            if (object instanceof $root.ord.Data)
                return object;
            let message = new $root.ord.Data();
            if (object.floatValue != null)
                message.floatValue = Number(object.floatValue);
            if (object.integerValue != null)
                message.integerValue = object.integerValue | 0;
            if (object.bytesValue != null)
                if (typeof object.bytesValue === "string")
                    $util.base64.decode(object.bytesValue, message.bytesValue = $util.newBuffer($util.base64.length(object.bytesValue)), 0);
                else if (object.bytesValue.length >= 0)
                    message.bytesValue = object.bytesValue;
            if (object.stringValue != null)
                message.stringValue = String(object.stringValue);
            if (object.url != null)
                message.url = String(object.url);
            if (object.description != null)
                message.description = String(object.description);
            if (object.format != null)
                message.format = String(object.format);
            return message;
        };

        /**
         * Creates a plain object from a Data message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord.Data
         * @static
         * @param {ord.Data} message Data
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Data.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.description = "";
                object.format = "";
            }
            if (message.floatValue != null && message.hasOwnProperty("floatValue")) {
                object.floatValue = options.json && !isFinite(message.floatValue) ? String(message.floatValue) : message.floatValue;
                if (options.oneofs)
                    object.kind = "floatValue";
            }
            if (message.integerValue != null && message.hasOwnProperty("integerValue")) {
                object.integerValue = message.integerValue;
                if (options.oneofs)
                    object.kind = "integerValue";
            }
            if (message.bytesValue != null && message.hasOwnProperty("bytesValue")) {
                object.bytesValue = options.bytes === String ? $util.base64.encode(message.bytesValue, 0, message.bytesValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.bytesValue) : message.bytesValue;
                if (options.oneofs)
                    object.kind = "bytesValue";
            }
            if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                object.stringValue = message.stringValue;
                if (options.oneofs)
                    object.kind = "stringValue";
            }
            if (message.url != null && message.hasOwnProperty("url")) {
                object.url = message.url;
                if (options.oneofs)
                    object.kind = "url";
            }
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.format != null && message.hasOwnProperty("format"))
                object.format = message.format;
            return object;
        };

        /**
         * Converts this Data to JSON.
         * @function toJSON
         * @memberof ord.Data
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Data.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Data
         * @function getTypeUrl
         * @memberof ord.Data
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Data.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord.Data";
        };

        return Data;
    })();

    return ord;
})();

export const ord_test = $root.ord_test = (() => {

    /**
     * Namespace ord_test.
     * @exports ord_test
     * @namespace
     */
    const ord_test = {};

    ord_test.Scalar = (function() {

        /**
         * Properties of a Scalar.
         * @memberof ord_test
         * @interface IScalar
         * @property {number|null} [int32Value] Scalar int32Value
         * @property {number|Long|null} [int64Value] Scalar int64Value
         * @property {number|null} [floatValue] Scalar floatValue
         * @property {string|null} [stringValue] Scalar stringValue
         * @property {Uint8Array|null} [bytesValue] Scalar bytesValue
         * @property {boolean|null} [boolValue] Scalar boolValue
         */

        /**
         * Constructs a new Scalar.
         * @memberof ord_test
         * @classdesc Represents a Scalar.
         * @implements IScalar
         * @constructor
         * @param {ord_test.IScalar=} [properties] Properties to set
         */
        function Scalar(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Scalar int32Value.
         * @member {number} int32Value
         * @memberof ord_test.Scalar
         * @instance
         */
        Scalar.prototype.int32Value = 0;

        /**
         * Scalar int64Value.
         * @member {number|Long} int64Value
         * @memberof ord_test.Scalar
         * @instance
         */
        Scalar.prototype.int64Value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Scalar floatValue.
         * @member {number|null|undefined} floatValue
         * @memberof ord_test.Scalar
         * @instance
         */
        Scalar.prototype.floatValue = null;

        /**
         * Scalar stringValue.
         * @member {string} stringValue
         * @memberof ord_test.Scalar
         * @instance
         */
        Scalar.prototype.stringValue = "";

        /**
         * Scalar bytesValue.
         * @member {Uint8Array} bytesValue
         * @memberof ord_test.Scalar
         * @instance
         */
        Scalar.prototype.bytesValue = $util.newBuffer([]);

        /**
         * Scalar boolValue.
         * @member {boolean|null|undefined} boolValue
         * @memberof ord_test.Scalar
         * @instance
         */
        Scalar.prototype.boolValue = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Scalar.prototype, "_floatValue", {
            get: $util.oneOfGetter($oneOfFields = ["floatValue"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(Scalar.prototype, "_boolValue", {
            get: $util.oneOfGetter($oneOfFields = ["boolValue"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Scalar instance using the specified properties.
         * @function create
         * @memberof ord_test.Scalar
         * @static
         * @param {ord_test.IScalar=} [properties] Properties to set
         * @returns {ord_test.Scalar} Scalar instance
         */
        Scalar.create = function create(properties) {
            return new Scalar(properties);
        };

        /**
         * Encodes the specified Scalar message. Does not implicitly {@link ord_test.Scalar.verify|verify} messages.
         * @function encode
         * @memberof ord_test.Scalar
         * @static
         * @param {ord_test.IScalar} message Scalar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Scalar.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.int32Value != null && Object.hasOwnProperty.call(message, "int32Value"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.int32Value);
            if (message.int64Value != null && Object.hasOwnProperty.call(message, "int64Value"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.int64Value);
            if (message.floatValue != null && Object.hasOwnProperty.call(message, "floatValue"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.floatValue);
            if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.stringValue);
            if (message.bytesValue != null && Object.hasOwnProperty.call(message, "bytesValue"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.bytesValue);
            if (message.boolValue != null && Object.hasOwnProperty.call(message, "boolValue"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.boolValue);
            return writer;
        };

        /**
         * Encodes the specified Scalar message, length delimited. Does not implicitly {@link ord_test.Scalar.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord_test.Scalar
         * @static
         * @param {ord_test.IScalar} message Scalar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Scalar.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Scalar message from the specified reader or buffer.
         * @function decode
         * @memberof ord_test.Scalar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord_test.Scalar} Scalar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Scalar.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord_test.Scalar();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.int32Value = reader.int32();
                        break;
                    }
                case 2: {
                        message.int64Value = reader.int64();
                        break;
                    }
                case 3: {
                        message.floatValue = reader.float();
                        break;
                    }
                case 4: {
                        message.stringValue = reader.string();
                        break;
                    }
                case 5: {
                        message.bytesValue = reader.bytes();
                        break;
                    }
                case 6: {
                        message.boolValue = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Scalar message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord_test.Scalar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord_test.Scalar} Scalar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Scalar.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Scalar message.
         * @function verify
         * @memberof ord_test.Scalar
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Scalar.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.int32Value != null && message.hasOwnProperty("int32Value"))
                if (!$util.isInteger(message.int32Value))
                    return "int32Value: integer expected";
            if (message.int64Value != null && message.hasOwnProperty("int64Value"))
                if (!$util.isInteger(message.int64Value) && !(message.int64Value && $util.isInteger(message.int64Value.low) && $util.isInteger(message.int64Value.high)))
                    return "int64Value: integer|Long expected";
            if (message.floatValue != null && message.hasOwnProperty("floatValue")) {
                properties._floatValue = 1;
                if (typeof message.floatValue !== "number")
                    return "floatValue: number expected";
            }
            if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                if (!$util.isString(message.stringValue))
                    return "stringValue: string expected";
            if (message.bytesValue != null && message.hasOwnProperty("bytesValue"))
                if (!(message.bytesValue && typeof message.bytesValue.length === "number" || $util.isString(message.bytesValue)))
                    return "bytesValue: buffer expected";
            if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                properties._boolValue = 1;
                if (typeof message.boolValue !== "boolean")
                    return "boolValue: boolean expected";
            }
            return null;
        };

        /**
         * Creates a Scalar message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord_test.Scalar
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord_test.Scalar} Scalar
         */
        Scalar.fromObject = function fromObject(object) {
            if (object instanceof $root.ord_test.Scalar)
                return object;
            let message = new $root.ord_test.Scalar();
            if (object.int32Value != null)
                message.int32Value = object.int32Value | 0;
            if (object.int64Value != null)
                if ($util.Long)
                    (message.int64Value = $util.Long.fromValue(object.int64Value)).unsigned = false;
                else if (typeof object.int64Value === "string")
                    message.int64Value = parseInt(object.int64Value, 10);
                else if (typeof object.int64Value === "number")
                    message.int64Value = object.int64Value;
                else if (typeof object.int64Value === "object")
                    message.int64Value = new $util.LongBits(object.int64Value.low >>> 0, object.int64Value.high >>> 0).toNumber();
            if (object.floatValue != null)
                message.floatValue = Number(object.floatValue);
            if (object.stringValue != null)
                message.stringValue = String(object.stringValue);
            if (object.bytesValue != null)
                if (typeof object.bytesValue === "string")
                    $util.base64.decode(object.bytesValue, message.bytesValue = $util.newBuffer($util.base64.length(object.bytesValue)), 0);
                else if (object.bytesValue.length >= 0)
                    message.bytesValue = object.bytesValue;
            if (object.boolValue != null)
                message.boolValue = Boolean(object.boolValue);
            return message;
        };

        /**
         * Creates a plain object from a Scalar message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord_test.Scalar
         * @static
         * @param {ord_test.Scalar} message Scalar
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Scalar.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.int32Value = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.int64Value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.int64Value = options.longs === String ? "0" : 0;
                object.stringValue = "";
                if (options.bytes === String)
                    object.bytesValue = "";
                else {
                    object.bytesValue = [];
                    if (options.bytes !== Array)
                        object.bytesValue = $util.newBuffer(object.bytesValue);
                }
            }
            if (message.int32Value != null && message.hasOwnProperty("int32Value"))
                object.int32Value = message.int32Value;
            if (message.int64Value != null && message.hasOwnProperty("int64Value"))
                if (typeof message.int64Value === "number")
                    object.int64Value = options.longs === String ? String(message.int64Value) : message.int64Value;
                else
                    object.int64Value = options.longs === String ? $util.Long.prototype.toString.call(message.int64Value) : options.longs === Number ? new $util.LongBits(message.int64Value.low >>> 0, message.int64Value.high >>> 0).toNumber() : message.int64Value;
            if (message.floatValue != null && message.hasOwnProperty("floatValue")) {
                object.floatValue = options.json && !isFinite(message.floatValue) ? String(message.floatValue) : message.floatValue;
                if (options.oneofs)
                    object._floatValue = "floatValue";
            }
            if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                object.stringValue = message.stringValue;
            if (message.bytesValue != null && message.hasOwnProperty("bytesValue"))
                object.bytesValue = options.bytes === String ? $util.base64.encode(message.bytesValue, 0, message.bytesValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.bytesValue) : message.bytesValue;
            if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                object.boolValue = message.boolValue;
                if (options.oneofs)
                    object._boolValue = "boolValue";
            }
            return object;
        };

        /**
         * Converts this Scalar to JSON.
         * @function toJSON
         * @memberof ord_test.Scalar
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Scalar.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Scalar
         * @function getTypeUrl
         * @memberof ord_test.Scalar
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Scalar.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord_test.Scalar";
        };

        return Scalar;
    })();

    ord_test.RepeatedScalar = (function() {

        /**
         * Properties of a RepeatedScalar.
         * @memberof ord_test
         * @interface IRepeatedScalar
         * @property {Array.<number>|null} [values] RepeatedScalar values
         */

        /**
         * Constructs a new RepeatedScalar.
         * @memberof ord_test
         * @classdesc Represents a RepeatedScalar.
         * @implements IRepeatedScalar
         * @constructor
         * @param {ord_test.IRepeatedScalar=} [properties] Properties to set
         */
        function RepeatedScalar(properties) {
            this.values = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RepeatedScalar values.
         * @member {Array.<number>} values
         * @memberof ord_test.RepeatedScalar
         * @instance
         */
        RepeatedScalar.prototype.values = $util.emptyArray;

        /**
         * Creates a new RepeatedScalar instance using the specified properties.
         * @function create
         * @memberof ord_test.RepeatedScalar
         * @static
         * @param {ord_test.IRepeatedScalar=} [properties] Properties to set
         * @returns {ord_test.RepeatedScalar} RepeatedScalar instance
         */
        RepeatedScalar.create = function create(properties) {
            return new RepeatedScalar(properties);
        };

        /**
         * Encodes the specified RepeatedScalar message. Does not implicitly {@link ord_test.RepeatedScalar.verify|verify} messages.
         * @function encode
         * @memberof ord_test.RepeatedScalar
         * @static
         * @param {ord_test.IRepeatedScalar} message RepeatedScalar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RepeatedScalar.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.values != null && message.values.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.values.length; ++i)
                    writer.float(message.values[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified RepeatedScalar message, length delimited. Does not implicitly {@link ord_test.RepeatedScalar.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord_test.RepeatedScalar
         * @static
         * @param {ord_test.IRepeatedScalar} message RepeatedScalar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RepeatedScalar.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RepeatedScalar message from the specified reader or buffer.
         * @function decode
         * @memberof ord_test.RepeatedScalar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord_test.RepeatedScalar} RepeatedScalar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RepeatedScalar.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord_test.RepeatedScalar();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.values && message.values.length))
                            message.values = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.values.push(reader.float());
                        } else
                            message.values.push(reader.float());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RepeatedScalar message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord_test.RepeatedScalar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord_test.RepeatedScalar} RepeatedScalar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RepeatedScalar.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RepeatedScalar message.
         * @function verify
         * @memberof ord_test.RepeatedScalar
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RepeatedScalar.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.values != null && message.hasOwnProperty("values")) {
                if (!Array.isArray(message.values))
                    return "values: array expected";
                for (let i = 0; i < message.values.length; ++i)
                    if (typeof message.values[i] !== "number")
                        return "values: number[] expected";
            }
            return null;
        };

        /**
         * Creates a RepeatedScalar message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord_test.RepeatedScalar
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord_test.RepeatedScalar} RepeatedScalar
         */
        RepeatedScalar.fromObject = function fromObject(object) {
            if (object instanceof $root.ord_test.RepeatedScalar)
                return object;
            let message = new $root.ord_test.RepeatedScalar();
            if (object.values) {
                if (!Array.isArray(object.values))
                    throw TypeError(".ord_test.RepeatedScalar.values: array expected");
                message.values = [];
                for (let i = 0; i < object.values.length; ++i)
                    message.values[i] = Number(object.values[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a RepeatedScalar message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord_test.RepeatedScalar
         * @static
         * @param {ord_test.RepeatedScalar} message RepeatedScalar
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RepeatedScalar.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.values = [];
            if (message.values && message.values.length) {
                object.values = [];
                for (let j = 0; j < message.values.length; ++j)
                    object.values[j] = options.json && !isFinite(message.values[j]) ? String(message.values[j]) : message.values[j];
            }
            return object;
        };

        /**
         * Converts this RepeatedScalar to JSON.
         * @function toJSON
         * @memberof ord_test.RepeatedScalar
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RepeatedScalar.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RepeatedScalar
         * @function getTypeUrl
         * @memberof ord_test.RepeatedScalar
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RepeatedScalar.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord_test.RepeatedScalar";
        };

        return RepeatedScalar;
    })();

    ord_test.Enum = (function() {

        /**
         * Properties of an Enum.
         * @memberof ord_test
         * @interface IEnum
         * @property {ord_test.Enum.EnumValues|null} [value] Enum value
         */

        /**
         * Constructs a new Enum.
         * @memberof ord_test
         * @classdesc Represents an Enum.
         * @implements IEnum
         * @constructor
         * @param {ord_test.IEnum=} [properties] Properties to set
         */
        function Enum(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Enum value.
         * @member {ord_test.Enum.EnumValues} value
         * @memberof ord_test.Enum
         * @instance
         */
        Enum.prototype.value = 0;

        /**
         * Creates a new Enum instance using the specified properties.
         * @function create
         * @memberof ord_test.Enum
         * @static
         * @param {ord_test.IEnum=} [properties] Properties to set
         * @returns {ord_test.Enum} Enum instance
         */
        Enum.create = function create(properties) {
            return new Enum(properties);
        };

        /**
         * Encodes the specified Enum message. Does not implicitly {@link ord_test.Enum.verify|verify} messages.
         * @function encode
         * @memberof ord_test.Enum
         * @static
         * @param {ord_test.IEnum} message Enum message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Enum.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.value);
            return writer;
        };

        /**
         * Encodes the specified Enum message, length delimited. Does not implicitly {@link ord_test.Enum.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord_test.Enum
         * @static
         * @param {ord_test.IEnum} message Enum message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Enum.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Enum message from the specified reader or buffer.
         * @function decode
         * @memberof ord_test.Enum
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord_test.Enum} Enum
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Enum.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord_test.Enum();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.value = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Enum message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord_test.Enum
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord_test.Enum} Enum
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Enum.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Enum message.
         * @function verify
         * @memberof ord_test.Enum
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Enum.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.value != null && message.hasOwnProperty("value"))
                switch (message.value) {
                default:
                    return "value: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates an Enum message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord_test.Enum
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord_test.Enum} Enum
         */
        Enum.fromObject = function fromObject(object) {
            if (object instanceof $root.ord_test.Enum)
                return object;
            let message = new $root.ord_test.Enum();
            switch (object.value) {
            default:
                if (typeof object.value === "number") {
                    message.value = object.value;
                    break;
                }
                break;
            case "UNSPECIFIED":
            case 0:
                message.value = 0;
                break;
            case "FIRST":
            case 1:
                message.value = 1;
                break;
            case "SECOND":
            case 2:
                message.value = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an Enum message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord_test.Enum
         * @static
         * @param {ord_test.Enum} message Enum
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Enum.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.value = options.enums === String ? "UNSPECIFIED" : 0;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = options.enums === String ? $root.ord_test.Enum.EnumValues[message.value] === undefined ? message.value : $root.ord_test.Enum.EnumValues[message.value] : message.value;
            return object;
        };

        /**
         * Converts this Enum to JSON.
         * @function toJSON
         * @memberof ord_test.Enum
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Enum.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Enum
         * @function getTypeUrl
         * @memberof ord_test.Enum
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Enum.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord_test.Enum";
        };

        /**
         * EnumValues enum.
         * @name ord_test.Enum.EnumValues
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} FIRST=1 FIRST value
         * @property {number} SECOND=2 SECOND value
         */
        Enum.EnumValues = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "FIRST"] = 1;
            values[valuesById[2] = "SECOND"] = 2;
            return values;
        })();

        return Enum;
    })();

    ord_test.RepeatedEnum = (function() {

        /**
         * Properties of a RepeatedEnum.
         * @memberof ord_test
         * @interface IRepeatedEnum
         * @property {Array.<ord_test.RepeatedEnum.EnumValues>|null} [values] RepeatedEnum values
         */

        /**
         * Constructs a new RepeatedEnum.
         * @memberof ord_test
         * @classdesc Represents a RepeatedEnum.
         * @implements IRepeatedEnum
         * @constructor
         * @param {ord_test.IRepeatedEnum=} [properties] Properties to set
         */
        function RepeatedEnum(properties) {
            this.values = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RepeatedEnum values.
         * @member {Array.<ord_test.RepeatedEnum.EnumValues>} values
         * @memberof ord_test.RepeatedEnum
         * @instance
         */
        RepeatedEnum.prototype.values = $util.emptyArray;

        /**
         * Creates a new RepeatedEnum instance using the specified properties.
         * @function create
         * @memberof ord_test.RepeatedEnum
         * @static
         * @param {ord_test.IRepeatedEnum=} [properties] Properties to set
         * @returns {ord_test.RepeatedEnum} RepeatedEnum instance
         */
        RepeatedEnum.create = function create(properties) {
            return new RepeatedEnum(properties);
        };

        /**
         * Encodes the specified RepeatedEnum message. Does not implicitly {@link ord_test.RepeatedEnum.verify|verify} messages.
         * @function encode
         * @memberof ord_test.RepeatedEnum
         * @static
         * @param {ord_test.IRepeatedEnum} message RepeatedEnum message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RepeatedEnum.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.values != null && message.values.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.values.length; ++i)
                    writer.int32(message.values[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified RepeatedEnum message, length delimited. Does not implicitly {@link ord_test.RepeatedEnum.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord_test.RepeatedEnum
         * @static
         * @param {ord_test.IRepeatedEnum} message RepeatedEnum message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RepeatedEnum.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RepeatedEnum message from the specified reader or buffer.
         * @function decode
         * @memberof ord_test.RepeatedEnum
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord_test.RepeatedEnum} RepeatedEnum
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RepeatedEnum.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord_test.RepeatedEnum();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.values && message.values.length))
                            message.values = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.values.push(reader.int32());
                        } else
                            message.values.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RepeatedEnum message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord_test.RepeatedEnum
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord_test.RepeatedEnum} RepeatedEnum
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RepeatedEnum.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RepeatedEnum message.
         * @function verify
         * @memberof ord_test.RepeatedEnum
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RepeatedEnum.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.values != null && message.hasOwnProperty("values")) {
                if (!Array.isArray(message.values))
                    return "values: array expected";
                for (let i = 0; i < message.values.length; ++i)
                    switch (message.values[i]) {
                    default:
                        return "values: enum value[] expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
            }
            return null;
        };

        /**
         * Creates a RepeatedEnum message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord_test.RepeatedEnum
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord_test.RepeatedEnum} RepeatedEnum
         */
        RepeatedEnum.fromObject = function fromObject(object) {
            if (object instanceof $root.ord_test.RepeatedEnum)
                return object;
            let message = new $root.ord_test.RepeatedEnum();
            if (object.values) {
                if (!Array.isArray(object.values))
                    throw TypeError(".ord_test.RepeatedEnum.values: array expected");
                message.values = [];
                for (let i = 0; i < object.values.length; ++i)
                    switch (object.values[i]) {
                    default:
                        if (typeof object.values[i] === "number") {
                            message.values[i] = object.values[i];
                            break;
                        }
                    case "UNSPECIFIED":
                    case 0:
                        message.values[i] = 0;
                        break;
                    case "FIRST":
                    case 1:
                        message.values[i] = 1;
                        break;
                    case "SECOND":
                    case 2:
                        message.values[i] = 2;
                        break;
                    }
            }
            return message;
        };

        /**
         * Creates a plain object from a RepeatedEnum message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord_test.RepeatedEnum
         * @static
         * @param {ord_test.RepeatedEnum} message RepeatedEnum
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RepeatedEnum.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.values = [];
            if (message.values && message.values.length) {
                object.values = [];
                for (let j = 0; j < message.values.length; ++j)
                    object.values[j] = options.enums === String ? $root.ord_test.RepeatedEnum.EnumValues[message.values[j]] === undefined ? message.values[j] : $root.ord_test.RepeatedEnum.EnumValues[message.values[j]] : message.values[j];
            }
            return object;
        };

        /**
         * Converts this RepeatedEnum to JSON.
         * @function toJSON
         * @memberof ord_test.RepeatedEnum
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RepeatedEnum.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RepeatedEnum
         * @function getTypeUrl
         * @memberof ord_test.RepeatedEnum
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RepeatedEnum.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord_test.RepeatedEnum";
        };

        /**
         * EnumValues enum.
         * @name ord_test.RepeatedEnum.EnumValues
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} FIRST=1 FIRST value
         * @property {number} SECOND=2 SECOND value
         */
        RepeatedEnum.EnumValues = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "FIRST"] = 1;
            values[valuesById[2] = "SECOND"] = 2;
            return values;
        })();

        return RepeatedEnum;
    })();

    ord_test.Nested = (function() {

        /**
         * Properties of a Nested.
         * @memberof ord_test
         * @interface INested
         * @property {ord_test.Nested.IChild|null} [child] Nested child
         */

        /**
         * Constructs a new Nested.
         * @memberof ord_test
         * @classdesc Represents a Nested.
         * @implements INested
         * @constructor
         * @param {ord_test.INested=} [properties] Properties to set
         */
        function Nested(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Nested child.
         * @member {ord_test.Nested.IChild|null|undefined} child
         * @memberof ord_test.Nested
         * @instance
         */
        Nested.prototype.child = null;

        /**
         * Creates a new Nested instance using the specified properties.
         * @function create
         * @memberof ord_test.Nested
         * @static
         * @param {ord_test.INested=} [properties] Properties to set
         * @returns {ord_test.Nested} Nested instance
         */
        Nested.create = function create(properties) {
            return new Nested(properties);
        };

        /**
         * Encodes the specified Nested message. Does not implicitly {@link ord_test.Nested.verify|verify} messages.
         * @function encode
         * @memberof ord_test.Nested
         * @static
         * @param {ord_test.INested} message Nested message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Nested.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.child != null && Object.hasOwnProperty.call(message, "child"))
                $root.ord_test.Nested.Child.encode(message.child, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Nested message, length delimited. Does not implicitly {@link ord_test.Nested.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord_test.Nested
         * @static
         * @param {ord_test.INested} message Nested message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Nested.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Nested message from the specified reader or buffer.
         * @function decode
         * @memberof ord_test.Nested
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord_test.Nested} Nested
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Nested.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord_test.Nested();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.child = $root.ord_test.Nested.Child.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Nested message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord_test.Nested
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord_test.Nested} Nested
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Nested.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Nested message.
         * @function verify
         * @memberof ord_test.Nested
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Nested.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.child != null && message.hasOwnProperty("child")) {
                let error = $root.ord_test.Nested.Child.verify(message.child);
                if (error)
                    return "child." + error;
            }
            return null;
        };

        /**
         * Creates a Nested message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord_test.Nested
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord_test.Nested} Nested
         */
        Nested.fromObject = function fromObject(object) {
            if (object instanceof $root.ord_test.Nested)
                return object;
            let message = new $root.ord_test.Nested();
            if (object.child != null) {
                if (typeof object.child !== "object")
                    throw TypeError(".ord_test.Nested.child: object expected");
                message.child = $root.ord_test.Nested.Child.fromObject(object.child);
            }
            return message;
        };

        /**
         * Creates a plain object from a Nested message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord_test.Nested
         * @static
         * @param {ord_test.Nested} message Nested
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Nested.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.child = null;
            if (message.child != null && message.hasOwnProperty("child"))
                object.child = $root.ord_test.Nested.Child.toObject(message.child, options);
            return object;
        };

        /**
         * Converts this Nested to JSON.
         * @function toJSON
         * @memberof ord_test.Nested
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Nested.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Nested
         * @function getTypeUrl
         * @memberof ord_test.Nested
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Nested.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord_test.Nested";
        };

        Nested.Child = (function() {

            /**
             * Properties of a Child.
             * @memberof ord_test.Nested
             * @interface IChild
             * @property {number|null} [value] Child value
             */

            /**
             * Constructs a new Child.
             * @memberof ord_test.Nested
             * @classdesc Represents a Child.
             * @implements IChild
             * @constructor
             * @param {ord_test.Nested.IChild=} [properties] Properties to set
             */
            function Child(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Child value.
             * @member {number|null|undefined} value
             * @memberof ord_test.Nested.Child
             * @instance
             */
            Child.prototype.value = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            // Virtual OneOf for proto3 optional field
            Object.defineProperty(Child.prototype, "_value", {
                get: $util.oneOfGetter($oneOfFields = ["value"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Child instance using the specified properties.
             * @function create
             * @memberof ord_test.Nested.Child
             * @static
             * @param {ord_test.Nested.IChild=} [properties] Properties to set
             * @returns {ord_test.Nested.Child} Child instance
             */
            Child.create = function create(properties) {
                return new Child(properties);
            };

            /**
             * Encodes the specified Child message. Does not implicitly {@link ord_test.Nested.Child.verify|verify} messages.
             * @function encode
             * @memberof ord_test.Nested.Child
             * @static
             * @param {ord_test.Nested.IChild} message Child message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Child.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.value);
                return writer;
            };

            /**
             * Encodes the specified Child message, length delimited. Does not implicitly {@link ord_test.Nested.Child.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ord_test.Nested.Child
             * @static
             * @param {ord_test.Nested.IChild} message Child message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Child.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Child message from the specified reader or buffer.
             * @function decode
             * @memberof ord_test.Nested.Child
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ord_test.Nested.Child} Child
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Child.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord_test.Nested.Child();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.value = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Child message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ord_test.Nested.Child
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ord_test.Nested.Child} Child
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Child.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Child message.
             * @function verify
             * @memberof ord_test.Nested.Child
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Child.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.value != null && message.hasOwnProperty("value")) {
                    properties._value = 1;
                    if (typeof message.value !== "number")
                        return "value: number expected";
                }
                return null;
            };

            /**
             * Creates a Child message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ord_test.Nested.Child
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ord_test.Nested.Child} Child
             */
            Child.fromObject = function fromObject(object) {
                if (object instanceof $root.ord_test.Nested.Child)
                    return object;
                let message = new $root.ord_test.Nested.Child();
                if (object.value != null)
                    message.value = Number(object.value);
                return message;
            };

            /**
             * Creates a plain object from a Child message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ord_test.Nested.Child
             * @static
             * @param {ord_test.Nested.Child} message Child
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Child.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.value != null && message.hasOwnProperty("value")) {
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                    if (options.oneofs)
                        object._value = "value";
                }
                return object;
            };

            /**
             * Converts this Child to JSON.
             * @function toJSON
             * @memberof ord_test.Nested.Child
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Child.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Child
             * @function getTypeUrl
             * @memberof ord_test.Nested.Child
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Child.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/ord_test.Nested.Child";
            };

            return Child;
        })();

        return Nested;
    })();

    ord_test.RepeatedNested = (function() {

        /**
         * Properties of a RepeatedNested.
         * @memberof ord_test
         * @interface IRepeatedNested
         * @property {Array.<ord_test.RepeatedNested.IChild>|null} [children] RepeatedNested children
         */

        /**
         * Constructs a new RepeatedNested.
         * @memberof ord_test
         * @classdesc Represents a RepeatedNested.
         * @implements IRepeatedNested
         * @constructor
         * @param {ord_test.IRepeatedNested=} [properties] Properties to set
         */
        function RepeatedNested(properties) {
            this.children = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RepeatedNested children.
         * @member {Array.<ord_test.RepeatedNested.IChild>} children
         * @memberof ord_test.RepeatedNested
         * @instance
         */
        RepeatedNested.prototype.children = $util.emptyArray;

        /**
         * Creates a new RepeatedNested instance using the specified properties.
         * @function create
         * @memberof ord_test.RepeatedNested
         * @static
         * @param {ord_test.IRepeatedNested=} [properties] Properties to set
         * @returns {ord_test.RepeatedNested} RepeatedNested instance
         */
        RepeatedNested.create = function create(properties) {
            return new RepeatedNested(properties);
        };

        /**
         * Encodes the specified RepeatedNested message. Does not implicitly {@link ord_test.RepeatedNested.verify|verify} messages.
         * @function encode
         * @memberof ord_test.RepeatedNested
         * @static
         * @param {ord_test.IRepeatedNested} message RepeatedNested message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RepeatedNested.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.children != null && message.children.length)
                for (let i = 0; i < message.children.length; ++i)
                    $root.ord_test.RepeatedNested.Child.encode(message.children[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RepeatedNested message, length delimited. Does not implicitly {@link ord_test.RepeatedNested.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord_test.RepeatedNested
         * @static
         * @param {ord_test.IRepeatedNested} message RepeatedNested message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RepeatedNested.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RepeatedNested message from the specified reader or buffer.
         * @function decode
         * @memberof ord_test.RepeatedNested
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord_test.RepeatedNested} RepeatedNested
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RepeatedNested.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord_test.RepeatedNested();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.children && message.children.length))
                            message.children = [];
                        message.children.push($root.ord_test.RepeatedNested.Child.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RepeatedNested message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord_test.RepeatedNested
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord_test.RepeatedNested} RepeatedNested
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RepeatedNested.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RepeatedNested message.
         * @function verify
         * @memberof ord_test.RepeatedNested
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RepeatedNested.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.children != null && message.hasOwnProperty("children")) {
                if (!Array.isArray(message.children))
                    return "children: array expected";
                for (let i = 0; i < message.children.length; ++i) {
                    let error = $root.ord_test.RepeatedNested.Child.verify(message.children[i]);
                    if (error)
                        return "children." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RepeatedNested message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord_test.RepeatedNested
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord_test.RepeatedNested} RepeatedNested
         */
        RepeatedNested.fromObject = function fromObject(object) {
            if (object instanceof $root.ord_test.RepeatedNested)
                return object;
            let message = new $root.ord_test.RepeatedNested();
            if (object.children) {
                if (!Array.isArray(object.children))
                    throw TypeError(".ord_test.RepeatedNested.children: array expected");
                message.children = [];
                for (let i = 0; i < object.children.length; ++i) {
                    if (typeof object.children[i] !== "object")
                        throw TypeError(".ord_test.RepeatedNested.children: object expected");
                    message.children[i] = $root.ord_test.RepeatedNested.Child.fromObject(object.children[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a RepeatedNested message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord_test.RepeatedNested
         * @static
         * @param {ord_test.RepeatedNested} message RepeatedNested
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RepeatedNested.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.children = [];
            if (message.children && message.children.length) {
                object.children = [];
                for (let j = 0; j < message.children.length; ++j)
                    object.children[j] = $root.ord_test.RepeatedNested.Child.toObject(message.children[j], options);
            }
            return object;
        };

        /**
         * Converts this RepeatedNested to JSON.
         * @function toJSON
         * @memberof ord_test.RepeatedNested
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RepeatedNested.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RepeatedNested
         * @function getTypeUrl
         * @memberof ord_test.RepeatedNested
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RepeatedNested.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord_test.RepeatedNested";
        };

        RepeatedNested.Child = (function() {

            /**
             * Properties of a Child.
             * @memberof ord_test.RepeatedNested
             * @interface IChild
             * @property {number|null} [value] Child value
             */

            /**
             * Constructs a new Child.
             * @memberof ord_test.RepeatedNested
             * @classdesc Represents a Child.
             * @implements IChild
             * @constructor
             * @param {ord_test.RepeatedNested.IChild=} [properties] Properties to set
             */
            function Child(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Child value.
             * @member {number|null|undefined} value
             * @memberof ord_test.RepeatedNested.Child
             * @instance
             */
            Child.prototype.value = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            // Virtual OneOf for proto3 optional field
            Object.defineProperty(Child.prototype, "_value", {
                get: $util.oneOfGetter($oneOfFields = ["value"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Child instance using the specified properties.
             * @function create
             * @memberof ord_test.RepeatedNested.Child
             * @static
             * @param {ord_test.RepeatedNested.IChild=} [properties] Properties to set
             * @returns {ord_test.RepeatedNested.Child} Child instance
             */
            Child.create = function create(properties) {
                return new Child(properties);
            };

            /**
             * Encodes the specified Child message. Does not implicitly {@link ord_test.RepeatedNested.Child.verify|verify} messages.
             * @function encode
             * @memberof ord_test.RepeatedNested.Child
             * @static
             * @param {ord_test.RepeatedNested.IChild} message Child message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Child.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.value);
                return writer;
            };

            /**
             * Encodes the specified Child message, length delimited. Does not implicitly {@link ord_test.RepeatedNested.Child.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ord_test.RepeatedNested.Child
             * @static
             * @param {ord_test.RepeatedNested.IChild} message Child message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Child.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Child message from the specified reader or buffer.
             * @function decode
             * @memberof ord_test.RepeatedNested.Child
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ord_test.RepeatedNested.Child} Child
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Child.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord_test.RepeatedNested.Child();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.value = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Child message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ord_test.RepeatedNested.Child
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ord_test.RepeatedNested.Child} Child
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Child.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Child message.
             * @function verify
             * @memberof ord_test.RepeatedNested.Child
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Child.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.value != null && message.hasOwnProperty("value")) {
                    properties._value = 1;
                    if (typeof message.value !== "number")
                        return "value: number expected";
                }
                return null;
            };

            /**
             * Creates a Child message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ord_test.RepeatedNested.Child
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ord_test.RepeatedNested.Child} Child
             */
            Child.fromObject = function fromObject(object) {
                if (object instanceof $root.ord_test.RepeatedNested.Child)
                    return object;
                let message = new $root.ord_test.RepeatedNested.Child();
                if (object.value != null)
                    message.value = Number(object.value);
                return message;
            };

            /**
             * Creates a plain object from a Child message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ord_test.RepeatedNested.Child
             * @static
             * @param {ord_test.RepeatedNested.Child} message Child
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Child.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.value != null && message.hasOwnProperty("value")) {
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                    if (options.oneofs)
                        object._value = "value";
                }
                return object;
            };

            /**
             * Converts this Child to JSON.
             * @function toJSON
             * @memberof ord_test.RepeatedNested.Child
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Child.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Child
             * @function getTypeUrl
             * @memberof ord_test.RepeatedNested.Child
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Child.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/ord_test.RepeatedNested.Child";
            };

            return Child;
        })();

        return RepeatedNested;
    })();

    ord_test.Map = (function() {

        /**
         * Properties of a Map.
         * @memberof ord_test
         * @interface IMap
         * @property {Object.<string,number>|null} [values] Map values
         */

        /**
         * Constructs a new Map.
         * @memberof ord_test
         * @classdesc Represents a Map.
         * @implements IMap
         * @constructor
         * @param {ord_test.IMap=} [properties] Properties to set
         */
        function Map(properties) {
            this.values = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Map values.
         * @member {Object.<string,number>} values
         * @memberof ord_test.Map
         * @instance
         */
        Map.prototype.values = $util.emptyObject;

        /**
         * Creates a new Map instance using the specified properties.
         * @function create
         * @memberof ord_test.Map
         * @static
         * @param {ord_test.IMap=} [properties] Properties to set
         * @returns {ord_test.Map} Map instance
         */
        Map.create = function create(properties) {
            return new Map(properties);
        };

        /**
         * Encodes the specified Map message. Does not implicitly {@link ord_test.Map.verify|verify} messages.
         * @function encode
         * @memberof ord_test.Map
         * @static
         * @param {ord_test.IMap} message Map message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Map.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.values != null && Object.hasOwnProperty.call(message, "values"))
                for (let keys = Object.keys(message.values), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 5 =*/21).float(message.values[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Map message, length delimited. Does not implicitly {@link ord_test.Map.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord_test.Map
         * @static
         * @param {ord_test.IMap} message Map message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Map.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Map message from the specified reader or buffer.
         * @function decode
         * @memberof ord_test.Map
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord_test.Map} Map
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Map.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord_test.Map(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (message.values === $util.emptyObject)
                            message.values = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = 0;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.float();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.values[key] = value;
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Map message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord_test.Map
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord_test.Map} Map
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Map.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Map message.
         * @function verify
         * @memberof ord_test.Map
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Map.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.values != null && message.hasOwnProperty("values")) {
                if (!$util.isObject(message.values))
                    return "values: object expected";
                let key = Object.keys(message.values);
                for (let i = 0; i < key.length; ++i)
                    if (typeof message.values[key[i]] !== "number")
                        return "values: number{k:string} expected";
            }
            return null;
        };

        /**
         * Creates a Map message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord_test.Map
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord_test.Map} Map
         */
        Map.fromObject = function fromObject(object) {
            if (object instanceof $root.ord_test.Map)
                return object;
            let message = new $root.ord_test.Map();
            if (object.values) {
                if (typeof object.values !== "object")
                    throw TypeError(".ord_test.Map.values: object expected");
                message.values = {};
                for (let keys = Object.keys(object.values), i = 0; i < keys.length; ++i)
                    message.values[keys[i]] = Number(object.values[keys[i]]);
            }
            return message;
        };

        /**
         * Creates a plain object from a Map message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord_test.Map
         * @static
         * @param {ord_test.Map} message Map
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Map.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.objects || options.defaults)
                object.values = {};
            let keys2;
            if (message.values && (keys2 = Object.keys(message.values)).length) {
                object.values = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.values[keys2[j]] = options.json && !isFinite(message.values[keys2[j]]) ? String(message.values[keys2[j]]) : message.values[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this Map to JSON.
         * @function toJSON
         * @memberof ord_test.Map
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Map.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Map
         * @function getTypeUrl
         * @memberof ord_test.Map
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Map.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord_test.Map";
        };

        return Map;
    })();

    ord_test.MapNested = (function() {

        /**
         * Properties of a MapNested.
         * @memberof ord_test
         * @interface IMapNested
         * @property {Object.<string,ord_test.MapNested.IChild>|null} [children] MapNested children
         */

        /**
         * Constructs a new MapNested.
         * @memberof ord_test
         * @classdesc Represents a MapNested.
         * @implements IMapNested
         * @constructor
         * @param {ord_test.IMapNested=} [properties] Properties to set
         */
        function MapNested(properties) {
            this.children = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MapNested children.
         * @member {Object.<string,ord_test.MapNested.IChild>} children
         * @memberof ord_test.MapNested
         * @instance
         */
        MapNested.prototype.children = $util.emptyObject;

        /**
         * Creates a new MapNested instance using the specified properties.
         * @function create
         * @memberof ord_test.MapNested
         * @static
         * @param {ord_test.IMapNested=} [properties] Properties to set
         * @returns {ord_test.MapNested} MapNested instance
         */
        MapNested.create = function create(properties) {
            return new MapNested(properties);
        };

        /**
         * Encodes the specified MapNested message. Does not implicitly {@link ord_test.MapNested.verify|verify} messages.
         * @function encode
         * @memberof ord_test.MapNested
         * @static
         * @param {ord_test.IMapNested} message MapNested message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MapNested.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.children != null && Object.hasOwnProperty.call(message, "children"))
                for (let keys = Object.keys(message.children), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.ord_test.MapNested.Child.encode(message.children[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified MapNested message, length delimited. Does not implicitly {@link ord_test.MapNested.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ord_test.MapNested
         * @static
         * @param {ord_test.IMapNested} message MapNested message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MapNested.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MapNested message from the specified reader or buffer.
         * @function decode
         * @memberof ord_test.MapNested
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ord_test.MapNested} MapNested
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MapNested.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord_test.MapNested(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (message.children === $util.emptyObject)
                            message.children = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.ord_test.MapNested.Child.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.children[key] = value;
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MapNested message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ord_test.MapNested
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ord_test.MapNested} MapNested
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MapNested.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MapNested message.
         * @function verify
         * @memberof ord_test.MapNested
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MapNested.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.children != null && message.hasOwnProperty("children")) {
                if (!$util.isObject(message.children))
                    return "children: object expected";
                let key = Object.keys(message.children);
                for (let i = 0; i < key.length; ++i) {
                    let error = $root.ord_test.MapNested.Child.verify(message.children[key[i]]);
                    if (error)
                        return "children." + error;
                }
            }
            return null;
        };

        /**
         * Creates a MapNested message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ord_test.MapNested
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ord_test.MapNested} MapNested
         */
        MapNested.fromObject = function fromObject(object) {
            if (object instanceof $root.ord_test.MapNested)
                return object;
            let message = new $root.ord_test.MapNested();
            if (object.children) {
                if (typeof object.children !== "object")
                    throw TypeError(".ord_test.MapNested.children: object expected");
                message.children = {};
                for (let keys = Object.keys(object.children), i = 0; i < keys.length; ++i) {
                    if (typeof object.children[keys[i]] !== "object")
                        throw TypeError(".ord_test.MapNested.children: object expected");
                    message.children[keys[i]] = $root.ord_test.MapNested.Child.fromObject(object.children[keys[i]]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a MapNested message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ord_test.MapNested
         * @static
         * @param {ord_test.MapNested} message MapNested
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MapNested.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.objects || options.defaults)
                object.children = {};
            let keys2;
            if (message.children && (keys2 = Object.keys(message.children)).length) {
                object.children = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.children[keys2[j]] = $root.ord_test.MapNested.Child.toObject(message.children[keys2[j]], options);
            }
            return object;
        };

        /**
         * Converts this MapNested to JSON.
         * @function toJSON
         * @memberof ord_test.MapNested
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MapNested.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MapNested
         * @function getTypeUrl
         * @memberof ord_test.MapNested
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MapNested.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ord_test.MapNested";
        };

        MapNested.Child = (function() {

            /**
             * Properties of a Child.
             * @memberof ord_test.MapNested
             * @interface IChild
             * @property {number|null} [value] Child value
             */

            /**
             * Constructs a new Child.
             * @memberof ord_test.MapNested
             * @classdesc Represents a Child.
             * @implements IChild
             * @constructor
             * @param {ord_test.MapNested.IChild=} [properties] Properties to set
             */
            function Child(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Child value.
             * @member {number|null|undefined} value
             * @memberof ord_test.MapNested.Child
             * @instance
             */
            Child.prototype.value = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            // Virtual OneOf for proto3 optional field
            Object.defineProperty(Child.prototype, "_value", {
                get: $util.oneOfGetter($oneOfFields = ["value"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Child instance using the specified properties.
             * @function create
             * @memberof ord_test.MapNested.Child
             * @static
             * @param {ord_test.MapNested.IChild=} [properties] Properties to set
             * @returns {ord_test.MapNested.Child} Child instance
             */
            Child.create = function create(properties) {
                return new Child(properties);
            };

            /**
             * Encodes the specified Child message. Does not implicitly {@link ord_test.MapNested.Child.verify|verify} messages.
             * @function encode
             * @memberof ord_test.MapNested.Child
             * @static
             * @param {ord_test.MapNested.IChild} message Child message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Child.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.value);
                return writer;
            };

            /**
             * Encodes the specified Child message, length delimited. Does not implicitly {@link ord_test.MapNested.Child.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ord_test.MapNested.Child
             * @static
             * @param {ord_test.MapNested.IChild} message Child message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Child.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Child message from the specified reader or buffer.
             * @function decode
             * @memberof ord_test.MapNested.Child
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ord_test.MapNested.Child} Child
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Child.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ord_test.MapNested.Child();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.value = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Child message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ord_test.MapNested.Child
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ord_test.MapNested.Child} Child
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Child.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Child message.
             * @function verify
             * @memberof ord_test.MapNested.Child
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Child.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.value != null && message.hasOwnProperty("value")) {
                    properties._value = 1;
                    if (typeof message.value !== "number")
                        return "value: number expected";
                }
                return null;
            };

            /**
             * Creates a Child message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ord_test.MapNested.Child
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ord_test.MapNested.Child} Child
             */
            Child.fromObject = function fromObject(object) {
                if (object instanceof $root.ord_test.MapNested.Child)
                    return object;
                let message = new $root.ord_test.MapNested.Child();
                if (object.value != null)
                    message.value = Number(object.value);
                return message;
            };

            /**
             * Creates a plain object from a Child message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ord_test.MapNested.Child
             * @static
             * @param {ord_test.MapNested.Child} message Child
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Child.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.value != null && message.hasOwnProperty("value")) {
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                    if (options.oneofs)
                        object._value = "value";
                }
                return object;
            };

            /**
             * Converts this Child to JSON.
             * @function toJSON
             * @memberof ord_test.MapNested.Child
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Child.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Child
             * @function getTypeUrl
             * @memberof ord_test.MapNested.Child
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Child.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/ord_test.MapNested.Child";
            };

            return Child;
        })();

        return MapNested;
    })();

    return ord_test;
})();

export { $root as default };
